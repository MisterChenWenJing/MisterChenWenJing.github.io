{
  "version": "https://jsonfeed.org/version/1.1",
  "title": "Mr.Chen",
  "home_page_url": "https://github.com/MisterChen9527/",
  "feed_url": "https://github.com/MisterChen9527/feed.json",
  "description": "Where there is light, there is hope.",
  "items": [
    {
      "title": "代码笔记",
      "url": "https://github.com/MisterChen9527/code/",
      "id": "https://github.com/MisterChen9527/code/",
      "summary": "此处是 Mr.Chen 存放的一些代码笔记。\n",
      "content_html": "<p>此处是 Mr.Chen 存放的一些代码笔记。</p>\n\n<h2 id=\"目录\" tabindex=\"-1\"> 目录</h2>\n<h3 id=\"基础\" tabindex=\"-1\"> 基础</h3>\n<ul>\n<li>\n<p><a href=\"/code/basic/\">基础知识</a></p>\n</li>\n<li>\n<p><a href=\"/code/windows/\">Windows 基础</a></p>\n</li>\n<li>\n<p><a href=\"/code/github/\">GitHub 介绍</a></p>\n</li>\n</ul>\n<h3 id=\"前端开发\" tabindex=\"-1\"> 前端开发</h3>\n<ul>\n<li>\n<p><a href=\"/code/website/\">网站相关</a></p>\n</li>\n<li>\n<p><a href=\"/code/vue/\">Vue 相关</a></p>\n</li>\n<li>\n<p><a href=\"/code/mini-app/\">小程序教程</a></p>\n</li>\n<li>\n<p><a href=\"/code/node-js/\">Node.js</a></p>\n</li>\n</ul>\n<h3 id=\"代码学习\" tabindex=\"-1\"> 代码学习</h3>\n<ul>\n<li>\n<p><a href=\"/code/language/\">代码学习</a></p>\n</li>\n<li>\n<p><a href=\"/code/language/learning.html\">如何学习一门语言</a></p>\n</li>\n<li>\n<p><a href=\"/code/language/js/\">JavaScript 教程</a></p>\n</li>\n<li>\n<p><a href=\"/code/language/typescript/\">TypeScript 教程</a></p>\n</li>\n<li>\n<p><a href=\"/code/language/python/\">Python 教程</a> (编写中...)</p>\n</li>\n<li>\n<p><a href=\"/code/language/markdown/\">Markdown 教程</a></p>\n</li>\n<li>\n<p><a href=\"/code/language/yaml/\">YAML 教程</a></p>\n</li>\n<li>\n<p><a href=\"/code/language/json/\">JSON 教程</a></p>\n</li>\n</ul>\n<h3 id=\"app\" tabindex=\"-1\"> APP</h3>\n<ul>\n<li><a href=\"/code/Android/\">Android 开发</a></li>\n</ul>\n<h3 id=\"后端开发\" tabindex=\"-1\"> 后端开发</h3>\n<ul>\n<li><a href=\"/code/backEnd/\">后端开发</a></li>\n</ul>\n<h3 id=\"代码学习网站\" tabindex=\"-1\"> 代码学习网站</h3>\n<h3 id=\"优质网站\" tabindex=\"-1\"> 优质网站</h3>\n<ul>\n<li>\n<p><a href=\"https://wangdoc.com/\" target=\"_blank\" rel=\"noopener noreferrer\">网道</a></p>\n</li>\n<li>\n<p><a href=\"https://www.liaoxuefeng.com/\" target=\"_blank\" rel=\"noopener noreferrer\">廖雪峰的网站</a></p>\n</li>\n<li>\n<p><a href=\"https://developer.mozilla.org/zh-CN/\" target=\"_blank\" rel=\"noopener noreferrer\">MDN</a></p>\n<div><p>相关信息</p>\n<p>MDN 的中文文档翻译很差，大多都是机翻，十分建议直接阅读英文文档。</p>\n</div>\n</li>\n</ul>\n<h3 id=\"杂牌网站\" tabindex=\"-1\"> 杂牌网站</h3>\n<ul>\n<li>\n<p><a href=\"https://www.runoob.com/\" target=\"_blank\" rel=\"noopener noreferrer\">菜鸟教程</a> <i>Content not supported</i></p>\n</li>\n<li>\n<p><a href=\"https://www.w3cschool.cn\" target=\"_blank\" rel=\"noopener noreferrer\">w3cschool</a> <i>Content not supported</i> <i>Content not supported</i> <i>Content not supported</i></p>\n</li>\n<li>\n<p><a href=\"http://www.w3school.com.cn/\" target=\"_blank\" rel=\"noopener noreferrer\">w3school</a> <i>Content not supported</i></p>\n</li>\n</ul>\n",
      "date_published": "2022-08-20T08:54:00.000Z",
      "date_modified": "2022-08-20T08:54:00.000Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "APP 组件设计规范",
      "url": "https://github.com/MisterChen9527/design/APP.html",
      "id": "https://github.com/MisterChen9527/design/APP.html",
      "summary": "本文对应用程序设计中常见的组件及其作用进行了介绍。\n",
      "content_html": "<p>本文对应用程序设计中常见的组件及其作用进行了介绍。</p>\n\n<h2 id=\"页面总体布局\" tabindex=\"-1\"> 页面总体布局</h2>\n<ul>\n<li>\n<h3 id=\"navigationbar\" tabindex=\"-1\"> navigationbar</h3>\n<p>简称 Navbar 也就是导航栏。</p>\n<p>主要负责承接页面的导航操作。</p>\n<p>在内部界面上，一般左侧展示返回操作，居中显示页面标题，右侧展示更多操作。</p>\n<p>在主页上，主要承载 tabpage 对应的功能展示与触发。</p>\n<p>在 navbar 上，设计要突出质感，应该以简约为主。</p>\n<p>使用不鲜明的颜色，可以使用 APP 或网页对的主体色。</p>\n<p>可附以纯色 icon。</p>\n<p>不能太吸睛导致用户对页面内容注意的分散。</p>\n<p>有条件的情况下应该设计其切换动效。</p>\n<p><img src=\"@source/design/assets/navbar1.jpg\" alt=\"图片\">\n<img src=\"@source/design/assets/navbar2.jpg\" alt=\"图片\">\n<img src=\"@source/design/assets/navbar3.jpg\" alt=\"图片\"></p>\n</li>\n</ul>\n<p>好文推荐: <a href=\"https://www.jianshu.com/p/6037e4f79f4d\" target=\"_blank\" rel=\"noopener noreferrer\">iOS 导航栏动效设计思路</a></p>\n<ul>\n<li>\n<h3 id=\"tabbar\" tabindex=\"-1\"> Tabbar</h3>\n<p>APP 打开后底部的操作栏叫 tabbar，一般设置 2-5 个模块，每个模块应该设计 logo 与文字，对应的界面叫 tabpage。</p>\n<p>在 logo 上应以简约为主，应当设计设置点击与激活效果。</p>\n<p>tabpage 的设置要慎重，分类展示 APP 最关键的几个分项设置，并在每个界面内展示具体内容。</p>\n<p><img src=\"@source/design/assets/tab1.jpg\" alt=\"图片\">\n<img src=\"@source/design/assets/tab2.jpg\" alt=\"图片\"></p>\n</li>\n</ul>\n<h3 id=\"page\" tabindex=\"-1\"> Page</h3>\n<p>App 每个页面的背景色，除了纯文章之外不应采用纯白色，设计可以向 APP 主题色靠拢。</p>\n<p>应当针对不同设备造成的不同长宽比、分辨率设置不同的页面排版样式，并制作不同的 UI 布局。</p>\n<p><img src=\"@source/design/assets/pc.png\" alt=\"图片\">\n<img src=\"@source/design/assets/phone.png\" alt=\"图片\">\n<img src=\"@source/design/assets/phone1.png\" alt=\"图片\">\n<img src=\"@source/design/assets/phone2.png\" alt=\"图片\"></p>\n<ul>\n<li>\n<h3 id=\"sider\" tabindex=\"-1\"> Sider</h3>\n<p>侧边栏，可以设置侧边固定按钮点击弹出或者从左向右滑动弹出式。</p>\n<p>一般用于承载不需要展示的一些设置项、介绍项、个人信息项。</p>\n<p><img src=\"@source/design/assets/sider1.jpg\" alt=\"图片\">\n<img src=\"@source/design/assets/sider2.png\" alt=\"图片\"></p>\n</li>\n</ul>\n<h2 id=\"ui-元素\" tabindex=\"-1\"> UI 元素</h2>\n<ul>\n<li>\n<h3 id=\"grid\" tabindex=\"-1\"> Grid</h3>\n<p>九宫格结构，实际使用的时候 3×3、4×2 都有广泛使用。</p>\n<p>Gird 结构主要用于罗列展示各项功能，或者是各项板块。</p>\n<p>各元素应该以上部的圆形或异形图标于下部的说明文字为主。</p>\n<p>在移动设备上一般不显示边框、不设计点击动效，而在 PC 与 HD 恰好相反。</p>\n<p><img src=\"@source/design/assets/grid1.jpg\" alt=\"图片\">\n<img src=\"@source/design/assets/grid2.jpg\" alt=\"图片\"></p>\n</li>\n<li>\n<h3 id=\"menu\" tabindex=\"-1\"> Menu</h3>\n<p>菜单有多种表现方式，比如 float menu、pop-up menu、modal menu、dropdown 等。</p>\n</li>\n<li>\n<h3 id=\"其他元素可以参考ant-design\" tabindex=\"-1\"> 其他元素可以参考<a href=\"https://vue.ant.design/docs/vue/introduce-cn/\" target=\"_blank\" rel=\"noopener noreferrer\">Ant-design</a></h3>\n</li>\n</ul>\n<h2 id=\"杂项\" tabindex=\"-1\"> 杂项</h2>\n<h3 id=\"mask-设计\" tabindex=\"-1\"> Mask 设计</h3>\n<p>灰色的半透明遮罩叫 mask</p>\n<p>当透明度很高，感受很小的时候一般设计成可穿透，也就是说点击相当于直接点击蒙层下部区域。</p>\n<p>透明度中等的一般式可触摸做取消热区的，也就是点击会取消。</p>\n<p>不可穿透的 mask，也就是说点击没有反应，一般要给非常高的不透明度，用户只能点叉号取消。(一般用于弹出推广)</p>\n<h3 id=\"设计趋势\" tabindex=\"-1\"> 设计趋势</h3>\n<p>目前以 iOS 特有的苹果风，Windows 上的 Aero 效果(毛玻璃效果)与安卓的 Material Design 设计为主。</p>\n<h4 id=\"图标\" tabindex=\"-1\"> 图标</h4>\n<p>常用实心矢量图标</p>\n<h4 id=\"移动端\" tabindex=\"-1\"> 移动端</h4>\n<p>分割线和边框目前采用已经比较少。</p>\n<h4 id=\"pc\" tabindex=\"-1\"> PC</h4>\n<p>增强鼠标移动与网页的交互带来沉浸式的体验。</p>\n<h4 id=\"突出质感\" tabindex=\"-1\"> 突出质感</h4>\n<p>因为不同机型现实效果不一样，普遍采用圆角、阴影、以及毛玻璃效果，还有避免用纯色背景转而用略蓝略灰的色调突出质感。</p>\n<h4 id=\"增强反馈感\" tabindex=\"-1\"> 增强反馈感</h4>\n<p>每次点击时和点击之后出发的效果都能在屏幕上让用户感知自己的操作(即我刚刚点了按钮，按钮生效产生了某种操作)</p>\n",
      "date_published": "2019-11-24T00:00:00.000Z",
      "date_modified": "2022-08-20T08:54:00.000Z",
      "authors": [],
      "tags": [
        "设计"
      ]
    },
    {
      "title": "UI 设计",
      "url": "https://github.com/MisterChen9527/design/",
      "id": "https://github.com/MisterChen9527/design/",
      "summary": "本文列出了一些 UI 设计相关的资源。\n",
      "content_html": "<p>本文列出了一些 UI 设计相关的资源。</p>\n\n<h2 id=\"相关教程\" tabindex=\"-1\"> 相关教程</h2>\n<ul>\n<li>\n<p><a href=\"/design/icon/\">图标设计教程</a></p>\n</li>\n<li>\n<p><a href=\"/design/navigation/\">导航设计教程</a></p>\n</li>\n</ul>\n<h2 id=\"配色\" tabindex=\"-1\"> 配色</h2>\n<ul>\n<li>\n<p><a href=\"http://www.ruanyifeng.com/blog/2019/03/coloring-scheme.html\" target=\"_blank\" rel=\"noopener noreferrer\">阮一峰 - 配色方案</a></p>\n</li>\n<li>\n<p><a href=\"https://webgradients.com/\" target=\"_blank\" rel=\"noopener noreferrer\">网页背景渐变色</a></p>\n</li>\n</ul>\n<h2 id=\"设计\" tabindex=\"-1\"> 设计</h2>\n<ul>\n<li>\n<p><a href=\"https://developer.apple.com/design/tips/\" target=\"_blank\" rel=\"noopener noreferrer\">Apple 设计原则</a></p>\n</li>\n<li>\n<p><a href=\"https://developer.apple.com/design/\" target=\"_blank\" rel=\"noopener noreferrer\">Apple 设计</a></p>\n</li>\n<li>\n<p><a href=\"/design/APP.html\">App 组件设计规范</a></p>\n</li>\n</ul>\n<h2 id=\"网站组件\" tabindex=\"-1\"> 网站组件</h2>\n<ul>\n<li>\n<p><a href=\"https://ant.design/index-cn\" target=\"_blank\" rel=\"noopener noreferrer\">Ant Design</a></p>\n</li>\n<li>\n<p><a href=\"https://weui.io/\" target=\"_blank\" rel=\"noopener noreferrer\">WeUI</a></p>\n</li>\n</ul>\n<h2 id=\"小程序组件库\" tabindex=\"-1\"> 小程序组件库</h2>\n<ul>\n<li>\n<p><a href=\"https://youzan.github.io/vant-weapp/\" target=\"_blank\" rel=\"noopener noreferrer\">Vant</a></p>\n</li>\n<li>\n<p><a href=\"https://www.color-ui.com/\" target=\"_blank\" rel=\"noopener noreferrer\">Color UI</a></p>\n</li>\n</ul>\n",
      "date_published": "2019-11-24T00:00:00.000Z",
      "date_modified": "2022-08-20T08:54:00.000Z",
      "authors": [],
      "tags": [
        "设计"
      ]
    },
    {
      "title": "机械硬盘",
      "url": "https://github.com/MisterChen9527/hardware/HDD.html",
      "id": "https://github.com/MisterChen9527/hardware/HDD.html",
      "content_html": "<p>现代计算机大部分文件存储功能都是由机械硬盘这种设备提供的。(现在的 SSD 和闪存从概念和逻辑上都部分继承自机械硬盘，所以使用机械硬盘来进行理解也是没有问题的)</p>\n<p>机械硬盘能实现信息存储的功能基于: 磁性存储介质能够被磁化，且磁化后会长久保留被磁化的状态，这种被磁化状态能够被读取出来，同时这种磁化状态还能够不断被修改，磁化正好有两个方向，所以可以表示 0 和 1。\n于是硬盘就是把这种磁性存储介质做成一个个盘片，每一个盘片上都分布着数量巨大的磁性存储单位，使用磁性读写头对盘片进行写入和读取(从原理上类似黑胶唱片的播放)。</p>\n<p>一个硬盘中的磁性存储单位数以亿计(1T 硬盘就有约 80 亿个)，所以需要一套规则来规划信息如何存取(比如一本存储信息的书我们还会分为页，每一页从上到下从左到右读取，同时还有章节目录)\n于是就有了这些物理、逻辑概念:</p>\n<ol>\n<li>\n<p>一个硬盘有多张盘片叠成，不同盘片有编号</p>\n</li>\n<li>\n<p>每张盘片上的存储颗粒成环形一圈圈地排布，每一圈称为磁道，有编号</p>\n</li>\n<li>\n<p>每条磁道上都有一圈存储颗粒，每 512 * 8(512 字节，0.5KB)个存储颗粒作为一个扇区，扇区是硬盘上存储的最小物理单位</p>\n</li>\n<li>\n<p>N 个扇区可以组成簇，N 取决于不同的文件系统或是文件系统的配置，簇是此文件系统中的最小存储单位</p>\n</li>\n<li>\n<p>所有盘面上的同一磁道构成一个圆柱，称为柱面，柱面是系统分区的最小单位</p>\n</li>\n</ol>\n<p>磁头读写文件的时候，首先是分区读写的，由 inode 编号(区内唯一的编号)找到对应的磁道和扇区，然后一个柱面一个柱面地进行读写。机械硬盘的读写控制系统是一个令人叹为观止的精密工程(一个盘面上有几亿个存储单位，每个磁道宽度不到几十纳米，磁盘每分钟上万转)，同时关于读写的逻辑也是有诸多细节(比如扇区的编号并不是连续的)，非常有意思，可以自行搜索文章拓展阅读。</p>\n",
      "date_published": "2020-06-05T00:00:00.000Z",
      "date_modified": "2022-08-20T08:54:00.000Z",
      "authors": [],
      "tags": [
        "硬件"
      ]
    },
    {
      "title": "硬件相关",
      "url": "https://github.com/MisterChen9527/hardware/",
      "id": "https://github.com/MisterChen9527/hardware/",
      "summary": " 硬件相关\n这里是一些常见的硬件相关的问题总结，供访客查阅。\n",
      "content_html": "<h1 id=\"硬件相关\" tabindex=\"-1\"> 硬件相关</h1>\n<p>这里是一些常见的硬件相关的问题总结，供访客查阅。</p>\n\n",
      "date_published": "2022-08-20T08:54:00.000Z",
      "date_modified": "2022-08-20T08:54:00.000Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "CPU 的架构",
      "url": "https://github.com/MisterChen9527/hardware/structure.html",
      "id": "https://github.com/MisterChen9527/hardware/structure.html",
      "content_html": "<p>CPU 内部已经含有一些微指令，我们所使用的软件都要经过 CPU 内部的微指令集来达成才行。那这些指令集的设计主要又被分为两种设计理念，这就是目前世界上常见到的两种主要 CPU 架构，分别是: 精简指令集(RISC)与复杂指令集(CISC) 系统。</p>\n<h2 id=\"精简指令集\" tabindex=\"-1\"> 精简指令集</h2>\n<p>精简指令集，(Reduced Instruction Set Computer, RISC) 的设计中，微指令集较为精简。每个指令的执行时间都很短，完成的动作也很单纯，指令的执行性能较佳；但是若要做复杂的事情，就要由多个指令来完成。常见的 RISC 微指令集 CPU 主要例如甲骨文(Oracle) 公司的 SPARC 系列、IBM 公司的 Power Architecture (包括 PowerPC) 系列、与 ARM 公司(ARM Holdings) 的 ARM CPU 系列等。</p>\n<p>在应用方面，SPARC CPU 的电脑常用于学术领域的大型工作站中，包括银行金融体系的主要伺服器也都有这类的电脑架构；至于 PowerPC 架构的应用上，例如索尼(Sony)公司出产的 Play Station 3(PS3)就是使用 PowerPC 架构的 Cell 处理器；那 ARM 的 ARM 呢? 您常使用的各厂牌手机、PDA、导航系统、网络设备(交换器、路由器等)等，几乎都是使用 ARM 架构的 CPU。目前世界上使用范围最广的 CPU 可能就是 ARM 这种架构。</p>\n<h2 id=\"复杂指令集\" tabindex=\"-1\"> 复杂指令集</h2>\n<p>复杂指令集，(Complex Instruction Set Computer, CISC)。与 RISC 不同的，CISC 在微指令集的每个小指令可以执行一些较低阶的硬体操作，指令数目多而且复杂，每条指令的长度并不相同。因为指令执行较为复杂所以每条指令花费的时间较长，但每条个别指令可以处理的工作较为丰富。常见的 CISC 微指令集 CPU 主要有 AMD、Intel、VIA 等的 x86 架构的 CPU。</p>\n<p>由于 AMD、Intel、VIA 所开发出来的 x86 架构 CPU 被大量使用于个人电脑(Personal computer)用途上面，因此，个人电脑常被称为 x86 架构的电脑! 那为何称为 x86 架构呢? 这是因为最早的那颗 Intel 发展出来的 CPU 代号称为 8086，后来依此架构又开发出 80286, 80386...，因此这种架构的 CPU 就被称为 x86 架构了。</p>\n<p>在 2003 年以前由 Intel 所开发的 x86 架构 CPU 由 8 位数升级到 16、32 位数，后来 AMD 依此架构修改新一代的 CPU 为 64 位数， 为了区别两者的差异，因此 64 位数的个人电脑 CPU 又被统称为 x86_64 的架构。</p>\n<div><p>提示</p>\n<p>所谓的位数指的是 CPU 一次资料读取的最大量! 64 位数 CPU 代表 CPU 一次可以读写 64bits 这么多的资料，32 位数 CPU 则是 CPU 一次只能读取 32 位数的意思。因为 CPU 读取资料量有限制，因此能够从记忆体中读写的资料也就有所限制。所以，一般 32 位数的 CPU 所能读写的最大资料量是 4GB。</p>\n</div>\n<p>那么不同的 x86 架构的 CPU 有什么差异呢? 除了 CPU 的整体结构(如第二层快取、每次运行可执行的指令数等)之外， 主要是在于微指令集的不同。新的 x86 的 CPU 大多含有很先进的微指令集， 这些微指令集可以加速多媒体程序的运行，也能够加强虚拟化的性能，而且某些微指令集更能够增加能源效率，降低 CPU 耗电量。</p>\n",
      "date_published": "2020-06-05T00:00:00.000Z",
      "date_modified": "2022-08-20T08:54:00.000Z",
      "authors": [],
      "tags": [
        "硬件"
      ]
    },
    {
      "title": "Linux",
      "url": "https://github.com/MisterChen9527/linux/",
      "id": "https://github.com/MisterChen9527/linux/",
      "content_html": "<h2 id=\"linux-教程\" tabindex=\"-1\"> Linux 教程</h2>\n<ul>\n<li>\n<p><a href=\"/linux/intro/\">Linux 介绍</a></p>\n<ul>\n<li>\n<p><a href=\"/linux/intro/intro.html\">Linux 介绍</a></p>\n</li>\n<li>\n<p><a href=\"/linux/intro/history.html\">Linux 历史</a></p>\n</li>\n<li>\n<p><a href=\"/linux/intro/language.html\">Linux 编写语言</a></p>\n</li>\n<li>\n<p><a href=\"/linux/intro/advantage.html\">Linux 优势</a></p>\n</li>\n<li>\n<p><a href=\"/linux/intro/desktop.html\">Linux 桌面环境</a></p>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"/linux/file/\">Linux 文件</a></p>\n<ul>\n<li>\n<p><a href=\"/linux/file/file.html\">Linux 文件</a></p>\n</li>\n<li>\n<p><a href=\"/linux/file/dir.html\">Linux 目录</a></p>\n</li>\n<li>\n<p><a href=\"/linux/file/mount.html\">挂载</a></p>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"/linux/command/\">Linux 命令</a></p>\n<ul>\n<li>\n<p><a href=\"/linux/command/command.html\">命令格式简介</a></p>\n</li>\n<li>\n<p><a href=\"/linux/command/dir.html\">目录相关</a></p>\n</li>\n<li>\n<p><a href=\"/linux/command/file.html\">文件相关</a></p>\n</li>\n<li>\n<p><a href=\"/linux/command/other.html\">其他命令</a></p>\n</li>\n<li>\n<p><a href=\"/linux/command/add.html\">命令的自动补全</a></p>\n</li>\n<li>\n<p><a href=\"/linux/command/excu.html\">命令的执行</a></p>\n</li>\n<li>\n<p><a href=\"/linux/command/path.html\">环境变量</a></p>\n</li>\n<li>\n<p><a href=\"/linux/command/ln.html\">创建链接</a></p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"ubuntu\" tabindex=\"-1\"> ubuntu</h2>\n<ul>\n<li><a href=\"/linux/ubuntu/\">点击前往</a></li>\n</ul>\n<h2 id=\"centos\" tabindex=\"-1\"> CentOS</h2>\n<ul>\n<li><a href=\"/linux/centos.html\">点击前往</a></li>\n</ul>\n<h2 id=\"wsl\" tabindex=\"-1\"> WSL</h2>\n<ul>\n<li><a href=\"/linux/WSL.html\">点击前往</a></li>\n</ul>\n",
      "date_published": "2019-11-15T00:00:00.000Z",
      "date_modified": "2022-08-20T08:54:00.000Z",
      "authors": [],
      "tags": [
        "Linux"
      ]
    },
    {
      "title": "WSL",
      "url": "https://github.com/MisterChen9527/linux/WSL.html",
      "id": "https://github.com/MisterChen9527/linux/WSL.html",
      "summary": "WSL 可以直接在 Windows 系统上安装并运行 Linux。目前最新的版本是 WSL2。\n",
      "content_html": "<p>WSL 可以直接在 Windows 系统上安装并运行 Linux。目前最新的版本是 WSL2。</p>\n\n<h2 id=\"ubuntu\" tabindex=\"-1\"> Ubuntu</h2>\n<p>Windows 上的功能有很大缺失。已知不能用 Snap。</p>\n<h2 id=\"wsl-文件位置\" tabindex=\"-1\"> WSL 文件位置</h2>\n<div><pre><code>C:\\Users\\%USERNAME%\\AppData\\Local\\Packages\\CanonicalGroupLimited.UbuntuonWindows_79rhkp1fndgsc\\LocalState\\rootfs\n</code></pre><div aria-hidden=\"true\"><div></div></div></div><h2 id=\"重启-wsl\" tabindex=\"-1\"> 重启 WSL</h2>\n<p>使用</p>\n<div><pre><code>net stop LxssManager\n</code></pre><div aria-hidden=\"true\"><div></div></div></div><p>和</p>\n<div><pre><code>net start LxssManager\n</code></pre><div aria-hidden=\"true\"><div></div></div></div>",
      "date_published": "2019-11-23T00:00:00.000Z",
      "date_modified": "2022-08-20T08:54:00.000Z",
      "authors": [],
      "tags": [
        "Linux"
      ]
    },
    {
      "title": "CentOS 教程",
      "url": "https://github.com/MisterChen9527/linux/centos.html",
      "id": "https://github.com/MisterChen9527/linux/centos.html",
      "content_html": "<h2 id=\"管理工具\" tabindex=\"-1\"> 管理工具</h2>\n<ul>\n<li>yum (Centos 7)</li>\n<li>dnf (Centos 8)</li>\n</ul>\n<h2 id=\"yarn\" tabindex=\"-1\"> yarn</h2>\n<div><pre><code><span>curl</span> --silent --location https://dl.yarnpkg.com/rpm/yarn.repo <span>|</span> <span>sudo</span> <span>tee</span> /etc/yum.repos.d/yarn.repo\n\n<span>sudo</span> yum <span>install</span> <span>yarn</span>\n<span>## OR ##</span>\n<span>sudo</span> dnf <span>install</span> <span>yarn</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div></div></div><p>测试是否安装成功:</p>\n<div><pre><code><span>yarn</span> --version\n</code></pre><div aria-hidden=\"true\"><div></div></div></div>",
      "date_published": "2019-11-23T00:00:00.000Z",
      "date_modified": "2022-08-20T08:54:00.000Z",
      "authors": [],
      "tags": [
        "Linux"
      ]
    },
    {
      "title": "ssh",
      "url": "https://github.com/MisterChen9527/linux/ssh.html",
      "id": "https://github.com/MisterChen9527/linux/ssh.html",
      "content_html": "<h2 id=\"使用密码登录\" tabindex=\"-1\"> 使用密码登录</h2>\n<ol>\n<li>\n<p>执行以下命令，连接 Linux 云服务器。</p>\n<div><pre><code><span>ssh</span> <span>&lt;</span>username<span>></span>@<span>&lt;</span>hostname or IP address<span>></span>\n</code></pre><div aria-hidden=\"true\"><div></div></div></div><ul>\n<li>username 即为前提条件中获得的默认帐号。</li>\n<li>hostname or IP address 为您的 Linux 实例公网 IP 或自定义域名。</li>\n</ul>\n</li>\n<li>\n<p>输入已获取的密码，按 Enter，即可完成登录。</p>\n</li>\n</ol>\n<h2 id=\"使用密钥登录\" tabindex=\"-1\"> 使用密钥登录</h2>\n<ol>\n<li>\n<p>执行以下命令，赋予私钥文件仅本人可读权限。</p>\n<div><pre><code><span>chmod</span> <span>400</span> <span>&lt;</span>下载的与云服务器关联的私钥的绝对路径<span>></span>\n</code></pre><div aria-hidden=\"true\"><div></div></div></div></li>\n<li>\n<p>执行以下命令，进行远程登录。</p>\n<div><pre><code><span>ssh</span> -i <span>&lt;</span>下载的与云服务器关联的私钥的绝对路径<span>></span> <span>&lt;</span>username<span>></span>@<span>&lt;</span>hostname or IP address<span>></span>\n</code></pre><div aria-hidden=\"true\"><div></div></div></div><ul>\n<li>username 即为前提条件中获得的默认帐号。</li>\n<li>hostname or IP address 为您的 Linux 实例公网 IP 或自定义域名。</li>\n</ul>\n<p>例如，执行 <code>ssh -i &quot;id_rsa&quot; ubuntu@123.206.113.227</code> 命令，远程登录 Linux 云服务器。</p>\n</li>\n</ol>\n<h2 id=\"断开链接\" tabindex=\"-1\"> 断开链接</h2>\n<p><code>Ctrl + D</code> 或 输入 <code>logout</code>.</p>\n",
      "date_published": "2019-11-23T00:00:00.000Z",
      "date_modified": "2022-08-20T08:54:00.000Z",
      "authors": [],
      "tags": [
        "基础"
      ]
    },
    {
      "title": "Mr.Chen 的随笔",
      "url": "https://github.com/MisterChen9527/note/",
      "id": "https://github.com/MisterChen9527/note/",
      "content_html": "<div><p>提示</p>\n<p>这里是 Mr.Chen 的一些随笔，后续会被整理进博客中。</p>\n</div>\n<h2 id=\"node-js-相关\" tabindex=\"-1\"> Node.js 相关</h2>\n<ul>\n<li><a href=\"/note/node-js/current-path.html\">current-path 相关</a></li>\n</ul>\n",
      "date_published": "2022-08-20T08:54:00.000Z",
      "date_modified": "2022-08-20T08:54:00.000Z",
      "authors": [],
      "tags": [
        "随笔"
      ]
    },
    {
      "title": "软件教程",
      "url": "https://github.com/MisterChen9527/software/",
      "id": "https://github.com/MisterChen9527/software/",
      "content_html": "<h2 id=\"代码编辑器\" tabindex=\"-1\"> 代码编辑器</h2>\n<ul>\n<li><a href=\"/software/editor.html\">编辑器介绍</a></li>\n</ul>\n<h2 id=\"团队协作\" tabindex=\"-1\"> 团队协作</h2>\n<p>开发项目的代码版本管理以及多人协作使用 Git 软件</p>\n<ul>\n<li>\n<p><a href=\"/software/git/\">Git 教程</a></p>\n</li>\n<li>\n<p><a href=\"/code/github/\">GitHub 介绍</a></p>\n</li>\n</ul>\n<h2 id=\"浏览器\" tabindex=\"-1\"> 浏览器</h2>\n<p>在开发中，调试网页推荐使用 Chrome。</p>\n<ul>\n<li><a href=\"/software/chrome.html\">Chrome 介绍</a></li>\n</ul>\n<h2 id=\"后端\" tabindex=\"-1\"> 后端</h2>\n<h3 id=\"http-server\" tabindex=\"-1\"> Http Server</h3>\n<p>网站已经停止使用 Apache Lounge 编译的 httpd Apache。目前迁移到更加轻量，并发性能更好的 Nginx 上。</p>\n<ul>\n<li>\n<p><a href=\"/software/apache.html\">Apache</a> <i>Content not supported</i></p>\n</li>\n<li>\n<p><a href=\"/software/nginx.html\">Nginx</a></p>\n</li>\n</ul>\n<h3 id=\"抓包与-api-调试\" tabindex=\"-1\"> 抓包与 API 调试</h3>\n<ul>\n<li><a href=\"/software/postman.html\">Postman</a></li>\n</ul>\n<h2 id=\"工具软件\" tabindex=\"-1\"> 工具软件</h2>\n<ul>\n<li><a href=\"/software/tool/\">查看详情</a></li>\n</ul>\n<h2 id=\"手机-app\" tabindex=\"-1\"> 手机 APP</h2>\n<h3 id=\"sololearn\" tabindex=\"-1\"> soloLearn</h3>\n<p>一个代码在线学习社区，只有英文版。由于代码语义贴近英文原生逻辑，十分建议在编辑代码时 “think in English”。</p>\n<p>软件中的 code playground 可以在线运行大部分代码，大家在手机上就可以进行练习与尝试。</p>\n<h2 id=\"adobe-软件\" tabindex=\"-1\"> Adobe 软件</h2>\n<p>Adobe 全系软件的获取，请见 <a href=\"https://www.weibo.com/vposy\" target=\"_blank\" rel=\"noopener noreferrer\">vposy 的微博</a> 的置顶帖。</p>\n",
      "date_published": "2022-08-20T08:54:00.000Z",
      "date_modified": "2022-08-20T08:54:00.000Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "Apache",
      "url": "https://github.com/MisterChen9527/software/apache.html",
      "id": "https://github.com/MisterChen9527/software/apache.html",
      "summary": "Apache 是世界使用排名第一的 Web 服务器软件。它可以运行在几乎所有广泛使用的计算机平台上，由于其跨平台和安全性被广泛使用，是最流行的 Web 服务器端软件之一。它快速、可靠并且可通过简单的 API 扩充，将 Perl/Python 等解释器编译到服务器中。\n",
      "content_html": "<p>Apache 是世界使用排名第一的 Web 服务器软件。它可以运行在几乎所有广泛使用的计算机平台上，由于其跨平台和安全性被广泛使用，是最流行的 Web 服务器端软件之一。它快速、可靠并且可通过简单的 API 扩充，将 Perl/Python 等解释器编译到服务器中。</p>\n\n<h2 id=\"apache-是什么\" tabindex=\"-1\"> Apache 是什么</h2>\n<p>Apache HTTP Server (简称 Apache )是 Apache 软件基金会的一个开放源码的网页服务器，可以在大多数计算机操作系统中运行，由于其多平台和安全性被广泛使用，是最流行的 Web 服务器端软件之一。它快速、可靠并且可通过简单的 API 扩展，将 Perl/Python 等解释器编译到服务器中。</p>\n<p>Apache HTTP 服务器是一个模块化的服务器，源于 NCSAhttpd 服务器，经过多次修改，成为世界使用排名第一的 Web 服务器软件。\n它可以运行在几乎所有广泛使用的计算机平台上。</p>\n<h2 id=\"apache-模块\" tabindex=\"-1\"> Apache 模块</h2>\n<p>Apache 通过引入各种模块来完成不同的功能。</p>\n<h2 id=\"apache-官方文档\" tabindex=\"-1\"> Apache 官方文档</h2>\n<ul>\n<li><a href=\"https://httpd.apache.org/docs/2.4/zh-cn/\" target=\"_blank\" rel=\"noopener noreferrer\">文档地址</a></li>\n</ul>\n<h2 id=\"apache-配置\" tabindex=\"-1\"> Apache 配置</h2>\n<p>Apache 通过 conf 文件夹下的 httpd.conf 来配置。</p>\n<div><pre><code><span># 此处填入 Apache 的路径</span>\n<span>Define</span> SRVROOT <span>\"U:/Apache\"</span>\n<span>ServerRoot</span> <span>\"<span>${SRVROOT}</span>\"</span>\n<span>Listen</span> 127.0.0.1:80\n<span>Listen</span> 127.0.0.1:443\n\n<span>LoadModule</span> auth_basic_module modules/mod_auth_basic.so\n<span>LoadModule</span> authz_core_module modules/mod_authz_core.so\n<span>LoadModule</span> deflate_module modules/mod_deflate.so\n<span>LoadModule</span> dir_module modules/mod_dir.so\n<span>LoadModule</span> env_module modules/mod_env.so\n<span>LoadModule</span> isapi_module modules/mod_isapi.so\n<span>LoadModule</span> log_config_module modules/mod_log_config.so\n<span>LoadModule</span> mime_module modules/mod_mime.so\n<span>LoadModule</span> negotiation_module modules/mod_negotiation.so\n<span>LoadModule</span> proxy_http2_module modules/mod_proxy_http2.so\n<span>LoadModule</span> ratelimit_module modules/mod_ratelimit.so\n<span>LoadModule</span> rewrite_module modules/mod_rewrite.so\n<span>LoadModule</span> setenvif_module modules/mod_setenvif.so\n<span>LoadModule</span> ssl_module modules/mod_ssl.so\n<span># 此处填入 PHP 的 ssh 组件路径</span>\n<span>LoadFile</span> <span>\"u:/php/libssh2.dll\"</span>\n<span># 此处填入 PHP 的 Apache 组件路径</span>\n<span>LoadModule</span> php7_module <span>\"u:/PHP/php7apache2_4.dll\"</span>\n<span># 此处填入 PHP 的路径</span>\nPHPIniDir <span>\"u:/PHP\"</span>\n\n<span><span><span>&lt;</span>IfModule</span><span> unixd_module</span><span>></span></span>\n<span>User</span> daemon\n<span>Group</span> daemon\n<span><span><span>&lt;/</span>IfModule</span><span>></span></span>\n\n<span>ServerAdmin</span> mister-hope@outlook.com\n<span>ServerName</span> localhost\n\n<span><span><span>&lt;</span>Directory</span><span> /</span><span>></span></span>\n  <span>AllowOverride</span> none\n  <span>Require</span> all denied\n<span><span><span>&lt;/</span>Directory</span><span>></span></span>\n\n<span>DocumentRoot</span> <span>\"<span>${SRVROOT}</span>/htdocs\"</span>\n<span><span><span>&lt;</span>Directory</span><span> <span>\"<span>${SRVROOT}</span>/htdocs\"</span></span><span>></span></span>\n  <span>Options</span> FollowSymLinks\n  <span>AllowOverride</span> All\n  <span>Require</span> all granted\n<span><span><span>&lt;/</span>Directory</span><span>></span></span>\n\n<span><span><span>&lt;</span>IfModule</span><span> dir_module</span><span>></span></span>\n  <span>DirectoryIndex</span> index.html index.php\n<span><span><span>&lt;/</span>IfModule</span><span>></span></span>\n\n<span><span><span>&lt;</span>Files</span><span> <span>\".ht*\"</span></span><span>></span></span>\n  <span>Require</span> all denied\n<span><span><span>&lt;/</span>Files</span><span>></span></span>\n\n<span>ErrorLog</span> <span>\"logs/error.log\"</span>\n<span>LogLevel</span> info\n\n<span><span><span>&lt;</span>IfModule</span><span> log_config_module</span><span>></span></span>\n  <span>LogFormat</span> <span>\"<span>%h</span> <span>%l</span> <span>%u</span> <span>%t</span> \\\"<span>%r</span>\\\" %>s <span>%b</span> \\\"<span>%{Referer}</span>i\\\" \\\"<span>%{User-Agent}</span>i\\\"\"</span> combined\n  <span>LogFormat</span> <span>\"<span>%h</span> <span>%l</span> <span>%u</span> <span>%t</span> \\\"<span>%r</span>\\\" %>s <span>%b</span>\"</span> common\n  <span><span><span>&lt;</span>IfModule</span><span> logio_module</span><span>></span></span>\n    <span>LogFormat</span> <span>\"<span>%h</span> <span>%l</span> <span>%u</span> <span>%t</span> \\\"<span>%r</span>\\\" %>s <span>%b</span> \\\"<span>%{Referer}</span>i\\\" \\\"<span>%{User-Agent}</span>i\\\" <span>%I</span> <span>%O</span>\"</span> combinedio\n  <span><span><span>&lt;/</span>IfModule</span><span>></span></span>\n  <span>CustomLog</span> <span>\"logs/access.log\"</span> common\n<span><span><span>&lt;/</span>IfModule</span><span>></span></span>\n\n<span><span><span>&lt;</span>IfModule</span><span> alias_module</span><span>></span></span>\n  <span>ScriptAlias</span> /cgi-bin/ <span>\"<span>${SRVROOT}</span>/cgi-bin/\"</span>\n<span><span><span>&lt;/</span>IfModule</span><span>></span></span>\n\n<span><span><span>&lt;</span>Directory</span><span> <span>\"<span>${SRVROOT}</span>/cgi-bin\"</span></span><span>></span></span>\n  <span>AllowOverride</span> None\n  <span>Options</span> None\n  <span>Require</span> all granted\n<span><span><span>&lt;/</span>Directory</span><span>></span></span>\n\n<span><span><span>&lt;</span>IfModule</span><span> headers_module</span><span>></span></span>\n  <span>RequestHeader</span> unset Proxy early\n<span><span><span>&lt;/</span>IfModule</span><span>></span></span>\n\n<span><span><span>&lt;</span>IfModule</span><span> mime_module</span><span>></span></span>\n  <span>TypesConfig</span> conf/mime.types\n  <span>AddHandler</span> application/x-httpd-php .php\n  <span>AddType</span> application/x-compress .Z\n  <span>AddType</span> application/x-gzip .gz .tgz\n  <span>AddType</span> application/x-httpd-php .php .html\n<span><span><span>&lt;/</span>IfModule</span><span>></span></span>\n\n<span><span><span>&lt;</span>IfModule</span><span> proxy_html_module</span><span>></span></span>\n  <span>Include</span> conf/extra/proxy-html.conf\n<span><span><span>&lt;/</span>IfModule</span><span>></span></span>\n<span><span><span>&lt;</span>IfModule</span><span> ssl_module</span><span>></span></span>\n  <span>SSLRandomSeed</span> startup builtin\n  <span>SSLRandomSeed</span> connect builtin\n<span><span><span>&lt;/</span>IfModule</span><span>></span></span>\n\n<span><span><span>&lt;</span>VirtualHost</span><span> *<span>:</span>80</span><span>></span></span>\n  <span>ServerAdmin</span> mister-hope@outlook.com\n  <span>ServerName</span> nenu.com\n  <span>ServerAlias</span> innenu\n  <span>DocumentRoot</span> <span>\"<span>${SRVROOT}</span>/htdocs\"</span>\n<span><span><span>&lt;/</span>VirtualHost</span><span>></span></span>\n\n<span><span><span>&lt;</span>VirtualHost</span><span> *<span>:</span>443</span><span>></span></span>\n  <span>ServerAdmin</span> mister-hope@outlook.com\n  <span>ServerName</span> mrhope.com\n  <span>ServerAlias</span> mrhope\n  <span>DocumentRoot</span> <span>\"<span>${SRVROOT}</span>/htdocs\"</span>\n<span><span><span>&lt;/</span>VirtualHost</span><span>></span></span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><ul>\n<li>\n<h3 id=\"serverroot\" tabindex=\"-1\"> ServerRoot</h3>\n<p>指定服务器的根目录</p>\n</li>\n<li>\n<h3 id=\"listen\" tabindex=\"-1\"> Listen</h3>\n<p>指定服务器监听的 IP 与 port</p>\n</li>\n<li>\n<h3 id=\"loadmodule\" tabindex=\"-1\"> LoadModule</h3>\n<p>加载指定的模块来使服务器调用</p>\n</li>\n<li>\n<h3 id=\"phpinidir\" tabindex=\"-1\"> PHPIniDir</h3>\n<p>指定 PHP 目录</p>\n</li>\n<li>\n<h3 id=\"unixd-module\" tabindex=\"-1\"> unixd_module</h3>\n<p>分配用户权限</p>\n</li>\n<li>\n<h3 id=\"serveradmin\" tabindex=\"-1\"> ServerAdmin</h3>\n<p>服务器管理员</p>\n</li>\n<li>\n<h3 id=\"servername\" tabindex=\"-1\"> ServerName</h3>\n<p>服务器名称</p>\n</li>\n</ul>\n",
      "date_published": "2019-12-12T00:00:00.000Z",
      "date_modified": "2022-08-20T08:54:00.000Z",
      "authors": [],
      "tags": [
        "服务器"
      ]
    },
    {
      "title": "Chrome",
      "url": "https://github.com/MisterChen9527/software/chrome.html",
      "id": "https://github.com/MisterChen9527/software/chrome.html",
      "summary": "Chrome 是谷歌出品的浏览器。其内核使用 Chromium，基于 JavaScript V8，是全球比例最大的浏览器内核。\n",
      "content_html": "<p>Chrome 是谷歌出品的浏览器。其内核使用 Chromium，基于 JavaScript V8，是全球比例最大的浏览器内核。</p>\n\n<h2 id=\"简介\" tabindex=\"-1\"> 简介</h2>\n<p>Chrome 如今可以说是一家独大。很多国内浏览器都是基于 Chromium 内核的套壳浏览器。</p>\n<p>Chrome 内核更新频繁，速度和安全性高，对新特性支持非常良好。另外谷歌具有十分强大的开发者工具，是前端开发使用的首选浏览器。目前最新的版本是 85。</p>\n<h2 id=\"配置\" tabindex=\"-1\"> 配置</h2>\n<p>由于 Chrome 是谷歌出品的浏览器，所以搜索栏默认使用 Google 搜索，而在中国无法访问 Google 服务，所以需要在右上角的菜单中选择设置，在搜索引擎设置中改为百度即可正常使用。</p>\n<p><img src=\"@source/software/assets/searchEngine.png\" alt=\"更改页面\"></p>\n<h2 id=\"快捷键\" tabindex=\"-1\"> 快捷键</h2>\n<p>Chrome 具有很多快捷键，熟练掌握后可以大幅减少时间。</p>\n<ul>\n<li><code>Ctrl + J</code>: 打开下载页面；</li>\n<li><code>Ctrl + H</code>: 打开历史页面；</li>\n<li><code>Ctrl + T</code>: 打开新标签页；</li>\n<li><code>Ctrl + Shift + T</code>: 恢复上一个关闭的标签页；</li>\n<li><code>Ctrl + N</code>: 打开新的窗口；</li>\n<li><code>Ctrl + W</code>: 关闭当前标签页；</li>\n<li><code>Ctrl + Tab</code>: 切换标签页；</li>\n<li><code>Ctrl + Shift + Tab</code>: 反向切换标签页；</li>\n<li><code>Ctrl + F</code>: 反向切换标签页；</li>\n<li><code>Ctrl + Shift + I</code> 或 <code>F12</code>: 打开开发者工具；</li>\n</ul>\n<h2 id=\"开发者工具\" tabindex=\"-1\"> 开发者工具</h2>\n<p><img src=\"@source/software/assets/devTool.png\" alt=\"开发者工具\"></p>\n<p>使用 <code>Ctrl + Shift + I</code> 或 <code>F12</code> 即可打开开发者工具，在开发者工具里，您可以自由的对任何网页进行调试。</p>\n<h2 id=\"chrome-推荐扩展\" tabindex=\"-1\"> Chrome 推荐扩展</h2>\n<ul>\n<li>AdGuard: 广告屏蔽；</li>\n<li>Adobe Acrobat: 将当前网页转为 Adobe PDF 文件；</li>\n<li>Betternet Unlimited Free VPN Proxy: 免费的 VPN 代理；</li>\n<li>Checker Plus for Gmail™: Gmail 邮件管理；</li>\n<li>Convertio: 非常强大的文件在线转换；</li>\n<li>Dark Reader: 为网页启用夜间模式；</li>\n<li>Enhanced GitHub: 能够展示仓库大小，文件大小和快速下载按钮；</li>\n<li>Evernote Web Clipper: 印象笔记剪藏，非常好用的保存工具；</li>\n<li>Google 翻译: 谷歌翻译软件；</li>\n<li>ImTranslator: 翻译，字典，声音</li>\n<li>Infinity: 一款非常好的标签页软件；</li>\n<li>Office Online: 在线查看并编辑 Office 文件；</li>\n<li>React Developer Tools: React 开发者工具</li>\n<li>Save to Pocket: 离线网页的最佳插件；</li>\n<li>VPN Free - Betternet Unlimited VPN Proxy: 一款免费的 VPN 插件；</li>\n<li>Vue.js Devtools: Vue.js 的开发者工具；</li>\n</ul>\n",
      "date_published": "2019-12-13T00:00:00.000Z",
      "date_modified": "2022-08-20T08:54:00.000Z",
      "authors": [],
      "tags": [
        "软件"
      ]
    },
    {
      "title": "代码编辑器",
      "url": "https://github.com/MisterChen9527/software/editor.html",
      "id": "https://github.com/MisterChen9527/software/editor.html",
      "content_html": "<ul>\n<li>\n<p><a href=\"/software/vscode/\">VS Code</a></p>\n<p>VS Code 的全称是 Visual Studio Code，是一款开源的、免费的、跨平台的、高性能的、轻量级的代码编辑器。它在性能、语言支持、开源社区方面，都做的很不错。</p>\n<p>VS Code 具有最大的编辑器社区，插件是所有编辑器里最全的。可以通过安装扩展实现几乎所有的功能，但扩展设置界面对新手不够友好，适合有一定经验的开发者。</p>\n<div><p>提示</p>\n<p>推荐使用轻量的 Visual Studio Code。</p>\n</div>\n</li>\n<li>\n<p>其他代码编辑器</p>\n<p>在不同领域的开发者可能会偏向不同种类的开发工具。下面列举其他常见的代码编辑器。</p>\n<ul>\n<li>WebStorm 是专业的 web 开发工具，提供格式化、代码补全等选项。</li>\n<li>PhpStorm 是专业的 php 开发工具，提供格式化、代码补全等选项。</li>\n<li><a href=\"https://notepad-plus-plus.org/\" target=\"_blank\" rel=\"noopener noreferrer\">notepad++</a></li>\n<li><a href=\"https://atom.io/\" target=\"_blank\" rel=\"noopener noreferrer\">atom</a></li>\n<li><a href=\"https://www.sublimetext.com/3\" target=\"_blank\" rel=\"noopener noreferrer\">sublime text</a></li>\n</ul>\n</li>\n</ul>\n<div><p>IDE 与编辑器</p>\n<p>IDE 和编辑器是有区别的:</p>\n<ul>\n<li>\n<p>IDE: 对代码会有较好的智能提示，同时侧重于工程项目，对项目的开发、调试工作有较好的图像化界面的支持，因此比较笨重。比如 Eclipse 的定位就是 IDE。</p>\n</li>\n<li>\n<p>编辑器: 要相对轻量许多，侧重于文本的编辑。比如 Sublime Text 的定位就是编辑器。再比如 Windows 系统自带的「记事本」就是最简单的编辑器。</p>\n</li>\n</ul>\n<p>需要注意的是，VS Code 的定位是编辑器，而非 IDE。但 VS Code 又比一般的编辑器的功能要丰富许多。</p>\n</div>\n",
      "date_published": "2022-08-20T08:54:00.000Z",
      "date_modified": "2022-08-20T08:54:00.000Z",
      "authors": [],
      "tags": [
        "软件"
      ]
    },
    {
      "title": "Nginx",
      "url": "https://github.com/MisterChen9527/software/nginx.html",
      "id": "https://github.com/MisterChen9527/software/nginx.html",
      "summary": "Nginx 是一个高性能的 HTTP 和反向代理服务器，也是一个 IMAP / POP3 / SMTP 代理服务器。其特点是占有内存少，并发能力强，稳定性高，并且 Nginx 也拥有友好灵活的配置。\n",
      "content_html": "<p>Nginx 是一个高性能的 HTTP 和反向代理服务器，也是一个 IMAP / POP3 / SMTP 代理服务器。其特点是占有内存少，并发能力强，稳定性高，并且 Nginx 也拥有友好灵活的配置。</p>\n\n<h2 id=\"启动-停止和重新加载配置\" tabindex=\"-1\"> 启动，停止和重新加载配置</h2>\n<p>要启动 nginx，请运行可执行文件。一旦启动 nginx，就可以通过使用 <code>-s</code> 参数调用可执行文件来对其进行控制。使用以下语法:</p>\n<div><pre><code>nginx -s signal\n</code></pre><div aria-hidden=\"true\"><div></div></div></div><p>其中 <code>signal</code> 可能是以下之一:</p>\n<ul>\n<li>stop - 快速关机</li>\n<li>quit — 正常关机</li>\n<li>reload — 重新加载配置文件</li>\n<li>reopen — 重新打开日志文件</li>\n</ul>\n<h2 id=\"配置文件的结构\" tabindex=\"-1\"> 配置文件的结构</h2>\n<p>Nginx 由受配置文件中指定的指令控制的模块组成。指令分为简单指令和块指令。一个简单的指令由名称和参数组成，这些名称和参数之间用空格分隔，并以分号(<code>;</code>)结尾。块指令的结构与简单指令的结构相同，但是它不以分号结尾，而是带有一组用括号 (<code>{</code> 和 <code>}</code>) 括起来的附加指令。如果一个块指令在括号内可以有其他指令，则称为 context (例如: <code>events</code>, <code>http</code>, <code>server</code> 和 <code>location</code>)。</p>\n<p>放置在任何 context 外部的配置文件中的指令都被视为在 main context 中。<code>events</code> 和 <code>http</code> 指令位于 <code>main</code> context 中，<code>server</code> 位于 <code>http</code> 中, 并且 <code>location</code> 在 <code>server</code> 中</p>\n<p><code>#</code> 号后的其余行被视为注释。</p>\n<h2 id=\"提供静态内容\" tabindex=\"-1\"> 提供静态内容</h2>\n<p>Web 服务器的一项重要任务是分发文件(例如图像或静态 HTML 页面)。您将实现一个示例，其中将根据请求从不同的本地目录提供文件: <code>/data/www</code> (可能包含 HTML 文件)和 <code>/data/images</code>(包含图像)。这将需要编辑配置文件，并在带有两个位置块的 http 块内设置服务器块。</p>\n<p>首先，创建 <code>/data/www</code> 目录，并将包含任何文本内容的 <code>index.html</code> 文件放入其中，并创建 <code>/data/images</code> 目录并将一些图像放入其中。</p>\n<p>接下来，打开配置文件。默认配置文件已经包含了服务器块的几个示例，大部分已被注释掉。现在，注释掉所有这些块并启动一个新的服务器块:</p>\n<div><pre><code><span><span>http</span></span> <span>{</span>\n  <span><span>server</span></span> <span>{</span>\n  <span>}</span>\n<span>}</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div></div></div><p>通常，配置文件可以包括几个服务器块，这些服务器块通过它们侦听的端口和服务器名称来区分。一旦 nginx 决定了哪个服务器处理请求，它就会根据服务器块内定义的 location 指令的参数测试请求标头中指定的 URI。</p>\n<p>将以下位置块添加到服务器块:</p>\n<div><pre><code><span><span>location</span> /</span> <span>{</span>\n  <span><span>root</span> /data/www</span><span>;</span>\n<span>}</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div></div></div><p>与请求中的 URI 相比，此位置块指定 “<code>/</code>” 前缀。对于匹配的请求，URI 将被添加到 root 指令中指定的路径，即 <code>/data/www</code>，以形成本地文件系统上所请求文件的路径。如果有多个匹配的位置块，nginx 将选择前缀最长的位置块。上面的位置块提供了最短的前缀，长度为 1，因此，只有在所有其他位置块均未提供匹配项时，才会使用该块。</p>\n<p>接下来，添加第二个位置块:</p>\n<div><pre><code><span><span>location</span> /images/</span> <span>{</span>\n  <span><span>root</span> /data</span><span>;</span>\n<span>}</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div></div></div><p>这将匹配以 <code>/images/</code> 开头的请求(位置 <code>/</code> 也匹配此类请求，但前缀较短)。</p>\n<p>服务器块的最终配置应如下所示:</p>\n<div><pre><code><span><span>server</span></span> <span>{</span>\n  <span><span>location</span> /</span> <span>{</span>\n    <span><span>root</span> /data/www</span><span>;</span>\n  <span>}</span>\n\n  <span><span>location</span> /images/</span> <span>{</span>\n    <span><span>root</span> /data</span><span>;</span>\n  <span>}</span>\n<span>}</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>这已经是服务器的工作配置，可以在标准端口 <code>80</code> 上侦听，并且可以在本地计算机上的 <code>http://localhost/</code> 上访问。响应以 <code>/images/</code> 开头的 URI 请求，服务器将从 <code>/data/images</code> 目录中发送文件。例如，为响应 <code>http://localhost/images/example.png</code> 请求，nginx 将发送文件 <code>/data/images/example.png</code>。如果该文件不存在，nginx 将发送一个注明 404 错误的响应。URI 不以 <code>/images/</code> 开头的请求将被映射到 <code>/data/www</code> 目录。例如，nginx 会响应 <code>http://localhost/some/example.html</code> 请求发送 <code>/data/www/some/example.html</code> 文件。</p>\n<p>要应用新配置，请启动 nginx (如果尚未启动)，或通过执行以下命令向 nginx 的主进程发送 <code>reload</code> 信号:</p>\n<div><pre><code>nginx -s reload\n</code></pre><div aria-hidden=\"true\"><div></div></div></div><p>如果某些东西无法按预期工作，则可以尝试在目录 <code>/usr/local/nginx/logs</code> 或目录 <code>/var/log/nginx</code> 中的 access.log 和 error.log 文件中找出原因。。</p>\n<h2 id=\"设置简单的代理服务器\" tabindex=\"-1\"> 设置简单的代理服务器</h2>\n<p>Nginx 的一种常用用法是将其设置为代理服务器，这意味着服务器可以接收请求，将请求传递给代理服务器，从请求中检索响应并将它们发送给客户端。</p>\n<p>我们将配置一个基本的代理服务器，该服务器为图像请求和本地目录中的文件提供服务，并将所有其他请求发送到代理服务器。在此示例中，两个服务器都将在单个 nginx 实例上定义。</p>\n<p>首先，通过向 nginx 的配置文件中添加另一个 <code>server</code> 块来定义代理服务器，其内容如下:</p>\n<div><pre><code><span><span>server</span></span> <span>{</span>\n  <span><span>listen</span> <span>8080</span></span><span>;</span>\n  <span><span>root</span> /data/up1</span><span>;</span>\n\n  <span><span>location</span> /</span> <span>{</span>\n  <span>}</span>\n<span>}</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>这将是一个简单的服务器，它在端口 8080 上侦听 (以前，自从使用标准端口 80 以来，未指定 listen 指令) 并将所有请求映射到本地文件系统的 <code>/data/up1</code> 目录中。创建此目录，并将 <code>index.html</code> 文件放入其中。请注意，根指令位于服务器上下文中。当选择用于服务请求的位置块不包括自己的根指令时，将使用这种根指令。</p>\n<p>接下来，使用上一部分中的服务器配置并对其进行修改以使其成为代理服务器配置。在第一个位置块中，将 <code>proxy_pass</code> 指令与参数中指定的代理服务器的协议，名称和端口放在一起 (在本例中为 <code>http://localhost:8080</code> ):</p>\n<div><pre><code><span><span>server</span></span> <span>{</span>\n  <span><span>location</span> /</span> <span>{</span>\n    <span><span>proxy_pass</span> http://localhost:8080</span><span>;</span>\n  <span>}</span>\n\n  <span><span>location</span> /images/</span> <span>{</span>\n    <span><span>root</span> /data</span><span>;</span>\n  <span>}</span>\n<span>}</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>我们将修改第二个 location 块，该位置块当前将带有 <code>/images/</code> 前缀的请求映射到 <code>/data/images</code> 目录下的文件，以使其与具有典型文件扩展名的图像的请求相匹配。修改后的位置块如下所示:</p>\n<div><pre><code><span><span>location</span> ~ \\.(gif|jpg|png)$</span> <span>{</span>\n  <span><span>root</span> /data/images</span><span>;</span>\n<span>}</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div></div></div><p>该参数是一个正则表达式，它匹配以 <code>.gif</code>，<code>.jpg</code> 或 <code>.png</code> 结尾的所有 URI。正则表达式应以 <code>~</code> 开头。相应的请求将被映射到 <code>/ data/images</code> 目录。</p>\n<p>当 nginx 选择一个 <code>location</code> 块来服务请求时，它首先检查指定前缀的 <code>location</code> 指令，记住带有最长前缀的 <code>location</code>，然后检查正则表达式。如果存在与正则表达式匹配的内容，nginx 会选择该 “<code>location</code>”，否则，它将选择之前记住的位置。</p>\n<p>代理服务器的最终配置如下所示:</p>\n<div><pre><code><span><span>server</span></span> <span>{</span>\n  <span><span>location</span> /</span> <span>{</span>\n    <span><span>proxy_pass</span> http://localhost:8080/</span><span>;</span>\n  <span>}</span>\n\n  <span><span>location</span> ~ \\.(gif|jpg|png)$</span> <span>{</span>\n    <span><span>root</span> /data/images</span><span>;</span>\n  <span>}</span>\n<span>}</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>该服务器将过滤以 <code>.gif</code>，<code>.jpg</code> 或 <code>.png</code> 结尾的请求，并将它们映射到目录 <code>/data/images</code>(通过将 URI 添加到根指令的参数)，并将所有其他请求传递给上面配置的代理服务器。</p>\n<p>要应用新配置，请按照前面几节的说明将重载信号发送到 nginx。</p>\n<p>还有许多其他指令可用于进一步配置代理连接。</p>\n<h2 id=\"设置-fastcgi-代理\" tabindex=\"-1\"> 设置 FastCGI 代理</h2>\n<p>Nginx 可用于将请求路由到 FastCGI 服务器，该服务器运行使用各种框架和编程语言 (例如 PHP) 构建的应用程序。</p>\n<p>与 FastCGI 服务器一起使用的最基本的 Nginx 配置包括使用 <code>fastcgi_pass</code> 指令而不是 <code>proxy_pass</code> 指令和 <code>fastcgi_param</code> 指令来设置传递给 FastCGI 服务器的参数。假设 FastCGI 服务器可以在 <code>localhost:9000</code> 上访问。以上一节中的代理配置为基础，用 <code>fastcgi_pass</code> 指令替换 <code>proxy_pass</code> 指令，并将参数更改为 <code>localhost:9000</code>。在 PHP 中， <code>SCRIPT_FILENAME</code> 参数用于确定脚本名称，而 <code>QUERY_STRING</code> 参数用于传递请求参数。配置的结果为:</p>\n<div><pre><code><span><span>server</span></span> <span>{</span>\n  <span><span>location</span> /</span> <span>{</span>\n    <span><span>fastcgi_pass</span>  localhost:9000</span><span>;</span>\n    <span><span>fastcgi_param</span> SCRIPT_FILENAME <span>$document_root</span><span>$fastcgi_script_name</span></span><span>;</span>\n    <span><span>fastcgi_param</span> QUERY_STRING    <span>$query_string</span></span><span>;</span>\n  <span>}</span>\n\n  <span><span>location</span> ~ \\.(gif|jpg|png)$</span> <span>{</span>\n    <span><span>root</span> /data/images</span><span>;</span>\n  <span>}</span>\n<span>}</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>这将设置一个服务器，该服务器将通过 FastCGI 协议将除静态图像请求以外的所有请求路由到运行在 <code>localhost:9000</code> 上的代理服务器。</p>\n<h2 id=\"官方文档\" tabindex=\"-1\"> 官方文档</h2>\n<ul>\n<li><a href=\"https://docs.nginx.com/nginx/admin-guide/\" target=\"_blank\" rel=\"noopener noreferrer\">点击此处</a></li>\n</ul>\n",
      "date_published": "2019-12-13T00:00:00.000Z",
      "date_modified": "2022-08-20T08:54:00.000Z",
      "authors": [],
      "tags": [
        "服务器"
      ]
    },
    {
      "title": "Postman",
      "url": "https://github.com/MisterChen9527/software/postman.html",
      "id": "https://github.com/MisterChen9527/software/postman.html",
      "content_html": "<h1 id=\"postman\" tabindex=\"-1\"> Postman</h1>\n<p>Postman 是一个强大的抓包与网络调试工具。</p>\n",
      "date_published": "2022-08-20T08:54:00.000Z",
      "date_modified": "2022-08-20T08:54:00.000Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "应用基础知识",
      "url": "https://github.com/MisterChen9527/code/Android/base.html",
      "id": "https://github.com/MisterChen9527/code/Android/base.html",
      "summary": "本章包含了一些关于 Android 开发的基础内容。\n",
      "content_html": "<p>本章包含了一些关于 Android 开发的基础内容。</p>\n\n<p>您可以使用 Kotlin、Java 和 C++ 语言编写 Android 应用。Android SDK 工具会将您的代码连同任何数据和资源文件编译成一个 APK(Android 软件包)，即带有 <code>.apk</code> 后缀的归档文件。一个 APK 文件包含 Android 应用的所有内容，它也是 Android 设备用来安装应用的文件。</p>\n<p>每个 Android 应用都处于各自的安全沙盒中，并受以下 Android 安全功能的保护:</p>\n<ul>\n<li>\n<p>Android 操作系统是一种多用户 Linux 系统，其中的每个应用都是一个不同的用户；\n默认情况下，系统会为每个应用分配一个唯一的 Linux 用户 ID(该 ID 仅由系统使用，应用并不知晓)。系统会为应用中的所有文件设置权限，使得只有分配给该应用的用户 ID 才能访问这些文件；</p>\n</li>\n<li>\n<p>每个进程都拥有自己的虚拟机 (VM)，因此应用代码独立于其他应用而运行。</p>\n</li>\n<li>\n<p>默认情况下，每个应用都在其自己的 Linux 进程内运行。Android 系统会在需要执行任何应用组件时启动该进程，然后当不再需要该进程或系统必须为其他应用恢复内存时，其便会关闭该进程。</p>\n</li>\n</ul>\n<p>Android 系统实现了最小权限原则。换言之，默认情况下，每个应用只能访问执行其工作所需的组件，而不能访问其他组件。这样便能创建非常安全的环境，在此环境中，应用无法访问其未获得权限的系统部分。不过，应用仍可通过一些途径与其他应用共享数据以及访问系统服务:</p>\n<ul>\n<li>\n<p>可以安排两个应用共享同一 Linux 用户 ID，在此情况下，二者便能访问彼此的文件。为节省系统资源，也可安排拥有相同用户 ID 的应用在同一 Linux 进程中运行，并共享同一 VM。应用还必须使用相同的证书进行签名。</p>\n</li>\n<li>\n<p>应用可以请求访问设备数据(如用户的联系人、短信消息、可装载存储装置(SD 卡)、相机、蓝牙等)的权限。用户必须明确授予这些权限。如需了解详细信息，请参阅使用系统权限。</p>\n</li>\n</ul>\n<h2 id=\"应用组件\" tabindex=\"-1\"> 应用组件</h2>\n<p>应用组件是 Android 应用的基本构建块。每个组件都是一个入口点，系统或用户可通过该入口点进入您的应用。有些组件会依赖于其他组件。</p>\n<p>共有四种不同的应用组件类型:</p>\n<ul>\n<li>Activity</li>\n<li>服务</li>\n<li>广播接收器</li>\n<li>内容提供程序</li>\n</ul>\n<p>每种类型都有不同的用途和生命周期，后者会定义如何创建和销毁组件。</p>\n<h3 id=\"activity\" tabindex=\"-1\"> Activity</h3>\n<p>Activity 是与用户交互的入口点。它表示拥有界面的单个屏幕。例如，电子邮件应用可能有一个显示新电子邮件列表的 Activity、一个用于撰写电子邮件的 Activity 以及一个用于阅读电子邮件的 Activity。尽管这些 Activity 通过协作在电子邮件应用中形成一种紧密结合的用户体验，但每个 Activity 都独立于其他 Activity 而存在。因此，其他应用可以启动其中任何一个 Activity(如果电子邮件应用允许)。例如，相机应用可以启动电子邮件应用内用于撰写新电子邮件的 Activity，以便用户共享图片。Activity 有助于完成系统和应用程序之间的以下重要交互:</p>\n<ul>\n<li>\n<p>追踪用户当前关心的内容(屏幕上显示的内容)，以确保系统继续运行托管 Activity 的进程。</p>\n</li>\n<li>\n<p>了解先前使用的进程包含用户可能返回的内容(已停止的 Activity)，从而更优先保留这些进程。</p>\n</li>\n<li>\n<p>帮助应用处理终止其进程的情况，以便用户可以返回已恢复其先前状态的 Activity。</p>\n</li>\n<li>\n<p>提供一种途径，让应用实现彼此之间的用户流，并让系统协调这些用户流。(此处最经典的示例是共享。)</p>\n</li>\n</ul>\n<p>您需将 Activity 作为 Activity 类的子类来实现。如需了解有关 Activity 类的更多信息，请参阅 Activity 开发者指南。</p>\n<h2 id=\"服务\" tabindex=\"-1\"> 服务</h2>\n<p>服务是一个通用入口点，用于因各种原因使应用在后台保持运行状态。它是一种在后台运行的组件，用于执行长时间运行的操作或为远程进程执行作业。服务不提供界面。例如，当用户使用其他应用时，服务可能会在后台播放音乐或通过网络获取数据，但这不会阻断用户与 Activity 的交互。诸如 Activity 等其他组件可以启动服务，使该服务运行或绑定到该服务，以便与其进行交互。事实上，有两种截然不同的语义服务可以告知系统如何管理应用: 已启动服务会告知系统使其运行至工作完毕。此类工作可以是在后台同步一些数据，或者在用户离开应用后继续播放音乐。在后台同步数据或播放音乐也代表了两种不同类型的已启动服务，而这些服务可以修改系统处理它们的方式:</p>\n<ul>\n<li>\n<p>音乐播放是用户可直接感知的服务，因此，应用会向用户发送通知，表明其希望成为前台，从而告诉系统此消息；在此情况下，系统明白它应尽全力维持该服务进程运行，因为进程消失会令用户感到不快。</p>\n</li>\n<li>\n<p>通常，用户不会意识到常规后台服务正处于运行状态，因此系统可以更自由地管理其进程。如果系统需要使用 RAM 来处理用户更迫切关注的内容，则其可能允许终止服务(然后在稍后的某个时刻重启服务)。</p>\n</li>\n</ul>\n<p>绑定服务之所以能运行，原因是某些其他应用(或系统)已表示希望使用该服务。从根本上讲，这是为另一个进程提供 API 的服务。因此，系统会知晓这些进程之间存在依赖关系，所以如果进程 A 绑定到进程 B 中的服务，系统便知道自己需使进程 B(及其服务)为进程 A 保持运行状态。此外，如果进程 A 是用户关心的内容，系统随即也知道将进程 B 视为用户关心的内容。由于存在灵活性(无论好坏)，服务已成为非常有用的构建块，并且可实现各种高级系统概念。动态壁纸、通知侦听器、屏幕保护程序、输入方法、无障碍功能服务以及众多其他核心系统功能均可构建为在其运行时由应用实现、系统绑定的服务。</p>\n<p>您需将服务作为 Service 的子类来实现。如需了解有关 Service 类的更多信息，请参阅服务开发者指南。</p>\n<h2 id=\"广播接收器\" tabindex=\"-1\"> 广播接收器</h2>\n<p>借助广播接收器组件，系统能够在常规用户流之外向应用传递事件，从而允许应用响应系统范围内的广播通知。由于广播接收器是另一个明确定义的应用入口，因此系统甚至可以向当前未运行的应用传递广播。例如，应用可通过调度提醒来发布通知，以告知用户即将发生的事件。而且，通过将该提醒传递给应用的广播接收器，应用在提醒响起之前即无需继续运行。许多广播均由系统发起，例如，通知屏幕已关闭、电池电量不足或已拍摄照片的广播。应用也可发起广播，例如，通知其他应用某些数据已下载至设备，并且可供其使用。尽管广播接收器不会显示界面，但其可以创建状态栏通知，在发生广播事件时提醒用户。但广播接收器更常见的用途只是作为通向其他组件的通道，旨在执行极少量的工作。例如，它可能会根据带 JobScheduler 的事件调度 JobService 来执行某项工作\n广播接收器作为 BroadcastReceiver 的子类实现，并且每条广播都作为 Intent 对象进行传递。如需了解详细信息，请参阅 BroadcastReceiver 类。</p>\n<h2 id=\"内容提供程序\" tabindex=\"-1\"> 内容提供程序</h2>\n<p>内容提供程序管理一组共享的应用数据，您可以将这些数据存储在文件系统、SQLite 数据库、网络中或者您的应用可访问的任何其他持久化存储位置。其他应用可通过内容提供程序查询或修改数据(如果内容提供程序允许)。例如，Android 系统可提供管理用户联系人信息的内容提供程序。因此，任何拥有适当权限的应用均可查询内容提供程序(如 <code>ContactsContract.Data</code>)，以读取和写入特定人员的相关信息。我们很容易将内容提供程序看作数据库上的抽象，因为其内置的大量 API 和支持时常适用于这一情况。但从系统设计的角度看，二者的核心目的不同。对系统而言，内容提供程序是应用的入口点，用于发布由 URI 架构识别的已命名数据项。因此，应用可以决定如何将其包含的数据映射到 URI 命名空间，进而将这些 URI 分发给其他实体。反之，这些实体也可使用分发的 URI 来访问数据。在管理应用的过程中，系统可以执行以下特殊操作:</p>\n<ul>\n<li>\n<p>分配 URI 无需应用保持运行状态，因此 URI 可在其所属的应用退出后继续保留。当系统必须从相应的 URI 检索应用数据时，系统只需确保所属应用仍处于运行状态。</p>\n</li>\n<li>\n<p>这些 URI 还会提供重要的细粒度安全模型。例如，应用可将其所拥有图像的 URI 放到剪贴板上，但将其内容提供程序锁定，以便其他应用程序无法随意访问它。当第二个应用尝试访问剪贴板上的 URI 时，系统可允许该应用通过临时的 URI 授权来访问数据，这样便只能访问 URI 后面的数据，而非第二个应用中的其他任何内容。</p>\n</li>\n</ul>\n<p>内容提供程序也适用于读取和写入您的应用不共享的私有数据。</p>\n<p>内容提供程序作为 ContentProvider 的子类实现，并且其必须实现一组标准 API，以便其他应用能够执行事务。如需了解详细信息，请参阅内容提供程序开发者指南。</p>\n<hr>\n<p>Android 系统设计的独特之处在于，任何应用都可启动其他应用的组件。例如，当您想让用户使用设备相机拍摄照片时，另一个应用可能也可执行该操作，因而您的应用便可使用该应用，而非自行产生一个 Activity 来拍摄照片。您无需加入甚至链接到该相机应用的代码。只需启动拍摄照片的相机应用中的 Activity 即可。完成拍摄时，系统甚至会将照片返回您的应用，以便您使用。对用户而言，这就如同相机是您应用的一部分。</p>\n<p>当系统启动某个组件时，它会启动该应用的进程(如果尚未运行)，并实例化该组件所需的类。例如，如果您的应用启动相机应用中拍摄照片的 Activity，则该 Activity 会在属于相机应用的进程(而非您的应用进程)中运行。因此，与大多数其他系统上的应用不同，Android 应用并没有单个入口点(即没有 main() 函数)。</p>\n<p>由于系统在单独的进程中运行每个应用，且其文件权限会限制对其他应用的访问，因此您的应用无法直接启动其他应用中的组件，但 Android 系统可以。如要启动其他应用中的组件，请向系统传递一条消息，说明启动特定组件的 Intent。系统随后便会为您启动该组件。</p>\n<h2 id=\"启动组件\" tabindex=\"-1\"> 启动组件</h2>\n<p>在四种组件类型中，有三种(Activity、服务和广播接收器)均通过异步消息 Intent 进行启动。Intent 会在运行时对各个组件进行互相绑定。您可以将 Intent 视为从其他组件(无论该组件是属于您的应用还是其他应用)请求操作的信使。</p>\n<p>您需使用 Intent 对象创建 Intent，该对象通过定义消息来启动特定组件(显式 Intent)或特定的组件类型(隐式 Intent)。</p>\n<p>对于 Activity 和服务，Intent 会定义要执行的操作(例如，查看或发送某内容)，并且可指定待操作数据的 URI，以及正在启动的组件可能需要了解的信息。例如，Intent 可能会传达对 Activity 的请求，以便显示图像或打开网页。在某些情况下，您可以通过启动 Activity 来接收结果，这样 Activity 还会返回 Intent 中的结果。例如，您可以发出一个 Intent，让用户选取某位联系人并将其返回给您。返回 Intent 包含指向所选联系人的 URI。</p>\n<p>对于广播接收器，Intent 只会定义待广播的通知。例如，指示设备电池电量不足的广播只包含指示“电池电量不足”的已知操作字符串。</p>\n<p>与 Activity、服务和广播接收器不同，内容提供程序并非由 Intent 启动。相反，它们会在成为 ContentResolver 的请求目标时启动。内容解析程序会通过内容提供程序处理所有直接事务，因此通过提供程序执行事务的组件便无需执行事务，而是改为在 ContentResolver 对象上调用方法。这会在内容提供程序与请求信息的组件之间留出一个抽象层(以确保安全)。</p>\n<p>每种组件都有不同的启动方法:</p>\n<ul>\n<li>\n<p>如要启动 Activity，您可以向 startActivity() 或 startActivityForResult() 传递 Intent(当您想让 Activity 返回结果时)，或者为其安排新任务。</p>\n</li>\n<li>\n<p>在 Android 5.0(API 级别 21)及更高版本中，您可以使用 JobScheduler 类来调度操作。对于早期 Android 版本，您可以通过向 startService() 传递 Intent 来启动服务(或对执行中的服务下达新指令)。您也可通过向将 bindService() 传递 Intent 来绑定到该服务。</p>\n</li>\n<li>\n<p>您可以通过向 <code>sendBroadcast()</code>、<code>sendOrderedBroadcast()</code> 或 <code>sendStickyBroadcast()</code> 等方法传递 Intent 来发起广播。</p>\n</li>\n<li>\n<p>您可以通过在 ContentResolver 上调用 <code>query()</code>，对内容提供程序执行查询。</p>\n</li>\n</ul>\n<p>如需了解有关 Intent 用法的详细信息，请参阅 Intent 和 Intent 过滤器文档。以下文档将为您详细介绍如何启动特定组件: Activity、服务、BroadcastReceiver 和内容提供程序。</p>\n<h2 id=\"清单文件\" tabindex=\"-1\"> 清单文件</h2>\n<p>在 Android 系统启动应用组件之前，系统必须通过读取应用的清单文件 (AndroidManifest.xml) 确认组件存在。您的应用必须在此文件中声明其所有组件，该文件必须位于应用项目目录的根目录中。</p>\n<p>除了声明应用的组件外，清单文件还有许多其他作用，如:</p>\n<ul>\n<li>\n<p>确定应用需要的任何用户权限，如互联网访问权限或对用户联系人的读取权限。</p>\n</li>\n<li>\n<p>根据应用使用的 API，声明应用所需的最低 API 级别。</p>\n</li>\n<li>\n<p>声明应用使用或需要的硬件和软件功能，如相机、蓝牙服务或多点触摸屏幕。</p>\n</li>\n<li>\n<p>声明应用需要链接的 API 库(Android 框架 API 除外)，如 Google 地图库。</p>\n</li>\n</ul>\n<h3 id=\"声明组件\" tabindex=\"-1\"> 声明组件</h3>\n<p>清单文件的主要任务是告知系统应用组件的相关信息。例如，清单文件可按如下所示声明 Activity:</p>\n<div><pre><code><span>&lt;?xml version=\"1.0\" encoding=\"utf-8\"?></span>\n<span><span><span>&lt;</span>manifest</span> <span>...</span> <span>></span></span>\n  <span><span><span>&lt;</span>application</span> <span><span>android:</span>icon</span><span><span>=</span><span>\"</span>@drawable/app_icon.png<span>\"</span></span> <span>...</span> <span>></span></span>\n    <span><span><span>&lt;</span>activity</span> <span><span>android:</span>name</span><span><span>=</span><span>\"</span>com.example.project.ExampleActivity<span>\"</span></span> <span><span>android:</span>label</span><span><span>=</span><span>\"</span>@string/example_label<span>\"</span></span> <span>...</span> <span>></span></span>\n    <span><span><span>&lt;/</span>activity</span><span>></span></span>\n    ...\n  <span><span><span>&lt;/</span>application</span><span>></span></span>\n<span><span><span>&lt;/</span>manifest</span><span>></span></span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>在 <code>&lt;application&gt;</code> 元素中，android:icon 属性指向标识应用的图标所对应的资源。</p>\n<p>在 <code>&lt;activity&gt;</code> 元素中，android:name 属性指定 Activity 子类的完全限定类名，<code>android:label</code> 属性指定用作 Activity 的用户可见标签的字符串。</p>\n<p>您必须使用以下元素声明所有应用组件:</p>\n<ul>\n<li>\n<p>Activity 的 <code>&lt;activity&gt;</code> 元素。</p>\n</li>\n<li>\n<p>服务的 <code>&lt;service&gt;</code> 元素。</p>\n</li>\n<li>\n<p>广播接收器的 <code>&lt;receiver&gt;</code> 元素。</p>\n</li>\n<li>\n<p>内容提供程序的 <code>&lt;provider&gt;</code> 元素。</p>\n</li>\n</ul>\n<p>如果未在清单文件中声明源代码中包含的 Activity、服务和内容提供程序，则这些组件对系统不可见，因此也永远不会运行。不过，您可以 BroadcastReceiver 对象的形式，在清单中声明或在代码中动态创建广播接收器；以及通过调用 <code>registerReceiver()</code>，在系统中注册广播接收器。</p>\n<p>如需详细了解如何为您的应用构建清单文件，请参阅 AndroidManifest.xml 文件文档。</p>\n<h3 id=\"声明组件功能\" tabindex=\"-1\"> 声明组件功能</h3>\n<p>如上文启动组件中所述，您可以使用 Intent 来启动 Activity、服务和广播接收器。您可以通过在 Intent 中显式命名目标组件(使用组件类名)来使用 Intent。您还可使用隐式 Intent，通过它来描述要执行的操作类型和待操作数据(可选)。借助隐式 Intent，系统能够在设备上找到可执行该操作的组件，并启动该组件。如果有多个组件可以执行 Intent 所描述的操作，则由用户选择使用哪一个组件。</p>\n<div><p>警告</p>\n<p>如果您使用 Intent 来启动 Service，请使用显式 Intent 来确保应用的安全性。使用隐式 Intent 启动服务存在安全隐患，因为您无法确定哪些服务将响应 Intent，且用户无法看到哪些服务已启动。从 Android 5.0 (API 级别 21) 开始，如果使用隐式 Intent 调用 <code>bindService()</code>，系统会抛出异常。请勿为您的服务声明 Intent 过滤器。</p>\n</div>\n<p>通过将收到的 Intent 与设备上其他应用的清单文件中提供的 Intent 过滤器进行比较，系统便可识别能响应 Intent 的组件。</p>\n<p>在应用的清单文件中声明 Activity 时，您可以选择性地加入声明 Activity 功能的 Intent 过滤器，以便响应来自其他应用的 Intent。您可以将 <code>&lt;intent-filter&gt;</code> 元素作为组件声明元素的子项进行添加，从而为您的组件声明 Intent 过滤器。</p>\n<p>例如，如果您构建的电子邮件应用包含用于撰写新电子邮件的 Activity，则可通过声明 Intent 过滤器来响应 “send” Intent(目的是发送新电子邮件)，如下方示例所示:</p>\n<div><pre><code><span><span><span>&lt;</span>manifest</span> <span>...</span> <span>></span></span>\n  ...\n  <span><span><span>&lt;</span>application</span> <span>...</span> <span>></span></span>\n    <span><span><span>&lt;</span>activity</span> <span><span>android:</span>name</span><span><span>=</span><span>\"</span>com.example.project.ComposeEmailActivity<span>\"</span></span><span>></span></span>\n      <span><span><span>&lt;</span>intent-filter</span><span>></span></span>\n        <span><span><span>&lt;</span>action</span> <span><span>android:</span>name</span><span><span>=</span><span>\"</span>android.intent.action.SEND<span>\"</span></span> <span>/></span></span>\n        <span><span><span>&lt;</span>data</span> <span><span>android:</span>type</span><span><span>=</span><span>\"</span>*/*<span>\"</span></span> <span>/></span></span>\n        <span><span><span>&lt;</span>category</span> <span><span>android:</span>name</span><span><span>=</span><span>\"</span>android.intent.category.DEFAULT<span>\"</span></span> <span>/></span></span>\n      <span><span><span>&lt;/</span>intent-filter</span><span>></span></span>\n    <span><span><span>&lt;/</span>activity</span><span>></span></span>\n  <span><span><span>&lt;/</span>application</span><span>></span></span>\n<span><span><span>&lt;/</span>manifest</span><span>></span></span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>如果另一个应用创建包含 <code>ACTION_SEND</code> 操作的 Intent 并将其传递到 <code>startActivity()</code>，则系统可能会启动您的 Activity，以便用户能够草拟并发送电子邮件。</p>\n<p>如需了解有关创建 Intent 过滤器的详细信息，请参阅 Intent 和 Intent 过滤器文档。</p>\n<h3 id=\"声明应用要求\" tabindex=\"-1\"> 声明应用要求</h3>\n<p>Android 设备多种多样，但并非所有设备都提供相同的特性和功能。以防将您的应用安装在缺少应用所需特性的设备上，您必须通过在清单文件中声明设备和软件要求，为该应用支持的设备类型明确定义一个配置文件。其中的大多数声明只是为了提供信息，系统并不会读取它们，但 Google Play 等外部服务会读取它们，以便在用户通过其设备搜索应用时为用户提供过滤功能。</p>\n<p>例如，如果您的应用需要相机功能，并使用 Android 2.1 (API 级别 7) 中引入的 API，您必须在清单文件中声明以下要求，如下方示例所示</p>\n<div><pre><code><span><span><span>&lt;</span>manifest</span> <span>...</span> <span>></span></span>\n  <span><span><span>&lt;</span>uses-feature</span> <span><span>android:</span>name</span><span><span>=</span><span>\"</span>android.hardware.camera.any<span>\"</span></span> <span><span>android:</span>required</span><span><span>=</span><span>\"</span>true<span>\"</span></span> <span>/></span></span>\n  <span><span><span>&lt;</span>uses-sdk</span> <span><span>android:</span>minSdkVersion</span><span><span>=</span><span>\"</span>7<span>\"</span></span> <span><span>android:</span>targetSdkVersion</span><span><span>=</span><span>\"</span>19<span>\"</span></span> <span>/></span></span>\n  ...\n<span><span><span>&lt;/</span>manifest</span><span>></span></span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div></div></div><p>通过示例中所述的声明，没有相机且 Android 版本低于 2.1 的设备将无法从 Google Play 安装您的应用。不过，您可以声明您的应用使用相机，但并不要求必须使用。在此情况下，您的应用必须将 required 属性设置为 false，并在运行时检查设备是否拥有相机，然后根据需要停用任何相机功能。</p>\n<p>如需详细了解如何管理应用与不同设备的兼容性，请参阅设备兼容性文档。</p>\n<h2 id=\"应用资源\" tabindex=\"-1\"> 应用资源</h2>\n<p>Android 应用并非仅包含代码，它还需要与源代码分离的资源，如图像、音频文件以及任何与应用的视觉呈现有关的内容。例如，您可以通过 XML 文件定义 Activity 界面的动画、菜单、样式、颜色和布局。借助应用资源，您无需修改代码即可轻松更新应用的各种特性。通过提供备用资源集，您可以针对各种设备配置(如不同的语言和屏幕尺寸)优化您的应用。</p>\n<p>对于您在 Android 项目中加入的每一项资源，SDK 构建工具均会定义唯一的整型 ID，您可以利用此 ID 来引用资源，这些资源或来自应用代码，或来自 XML 中定义的其他资源。例如，如果您的应用包含名为 <code>logo.png</code> 的图像文件(保存在 <code>res/drawable/</code> 目录中)，则 SDK 工具会生成名为 <code>R.drawable.logo</code> 的资源 ID。此 ID 映射到应用特定的整型数，您可以利用它来引用该图像，并将其插入您的界面。</p>\n<p>如果提供与源代码分离的资源，则其中最重要的一个优点在于，您可以提供适用于不同设备配置的备用资源。例如，通过在 XML 中定义界面字符串，您可以将字符串翻译为其他语言，并将这些字符串保存在单独的文件中。然后，Android 系统会根据向资源目录名称追加的语言限定符 (如为法语字符串值追加 <code>res/values-fr/</code>) 和用户的语言设置，对您的界面应用相应的语言字符串。</p>\n<p>Android 支持许多不同的备用资源限定符。限定符是资源目录名称中加入的短字符串，用于定义这些资源适用的设备配置。例如，您应根据设备的屏幕方向和尺寸为 Activity 创建不同的布局。当设备屏幕为纵向(长型)时，您可能想要一种垂直排列按钮的布局；但当屏幕为横向(宽型)时，可以按水平方向排列按钮。如要根据方向更改布局，您可以定义两种不同的布局，然后对每个布局的目录名称应用相应的限定符。然后，系统会根据当前设备方向自动应用相应的布局。</p>\n<p>如需详细了解可以在应用中加入的不同资源类型以及如何针对不同设备配置创建备用资源，请阅读提供资源。如要详细了解最佳做法和设计生产质量的稳健应用，请参阅应用架构指南。</p>\n",
      "date_published": "2020-04-08T00:00:00.000Z",
      "date_modified": "2022-08-20T08:54:00.000Z",
      "authors": [],
      "tags": [
        "Android"
      ]
    },
    {
      "title": "应用资源概览",
      "url": "https://github.com/MisterChen9527/code/Android/resource.html",
      "id": "https://github.com/MisterChen9527/code/Android/resource.html",
      "summary": "资源是指代码使用的附加文件和静态内容，例如位图、布局定义、界面字符串、动画说明等。\n",
      "content_html": "<p>资源是指代码使用的附加文件和静态内容，例如位图、布局定义、界面字符串、动画说明等。</p>\n\n<p>您应始终外部化应用资源(例如图像和代码中的字符串)，以便单独对其进行维护。此外，您还应为特定设备配置提供备用资源，方法是将其进行分组并放入专门命名的资源目录中。在运行时，Android 会根据当前配置使用合适的资源。例如，您可能需根据屏幕尺寸提供不同的界面布局，或根据语言设置提供不同的字符串。</p>\n<p>外部化应用资源后，您便可使用在项目 R 类中生成的资源 ID 来访问这些资源。本文档会介绍如何对 Android 项目中的资源进行分组，如何为特定的设备配置提供备用资源，以及如何从您的应用代码或其他 XML 文件访问这些资源。</p>\n<h2 id=\"分组资源类型\" tabindex=\"-1\"> 分组资源类型</h2>\n<p>您应将各类资源放入项目 <code>res/</code> 目录的特定子目录中。例如，以下是一个简单项目的文件层次结构:</p>\n<div><pre><code>MyProject/\n  src/\n    MyActivity.java\n  res/\n    drawable/\n      graphic.png\n    layout/\n      main.xml\n      info.xml\n    mipmap/\n      icon.png\n    values/\n      strings.xml\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>如此示例所示，<code>res/</code> 目录包含所有资源(在子目录中): 一个图像资源、两个布局资源、启动器图标的 <code>mipmap/</code> 目录以及一个字符串资源文件。资源目录名称非常重要，具体说明请见表 1。</p>\n<p>表 1. 项目 <code>res/</code> 目录中支持的资源目录。</p>\n<table>\n<thead>\n<tr>\n<th>目录</th>\n<th>资源类型</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>animator/</td>\n<td>用于定义属性动画的 XML 文件。</td>\n</tr>\n<tr>\n<td>anim/</td>\n<td>用于定义渐变动画的 XML 文件。(属性动画也可保存在此目录中，但为了区分这两种类型，属性动画首选 animator/ 目录。)</td>\n</tr>\n<tr>\n<td>color/</td>\n<td>用于定义颜色状态列表的 XML 文件。请参阅颜色状态列表资源</td>\n</tr>\n<tr>\n<td>drawable/</td>\n<td>位图文件(.png、.9.png、.jpg、.gif)或编译为以下可绘制对象资源子类型的 XML 文件: <br />位图文件<br />九宫格(可调整大小的位图)<br />状态列表<br />形状<br />动画可绘制对象<br />其他可绘制对象<br />请参阅 Drawable 资源。</td>\n</tr>\n<tr>\n<td>mipmap/</td>\n<td>适用于不同启动器图标密度的可绘制对象文件。如需了解有关使用 mipmap/ 文件夹管理启动器图标的详细信息，请参阅管理项目概览。</td>\n</tr>\n<tr>\n<td>layout/</td>\n<td>用于定义用户界面布局的 XML 文件。请参阅布局资源。</td>\n</tr>\n<tr>\n<td>menu/</td>\n<td>用于定义应用菜单(如选项菜单、上下文菜单或子菜单)的 XML 文件。请参阅菜单资源。</td>\n</tr>\n<tr>\n<td>raw/</td>\n<td>需以原始形式保存的任意文件。如要使用原始 InputStream 打开这些资源，请使用资源 ID(即 <code>R.raw.filename</code>)调用 <code>Resources.openRawResource()</code>。<br />但是，如需访问原始文件名和文件层次结构，则可以考虑将某些资源保存在 <code>assets/</code> 目录(而非 <code>res/raw/</code>)下。<code>assets/</code> 中的文件没有资源 ID，因此您只能使用 AssetManager 读取这些文件。</td>\n</tr>\n<tr>\n<td>values/</td>\n<td>包含字符串、整型数和颜色等简单值的 XML 文件。<br />其他 <code>res/</code> 子目录中的 XML 资源文件会根据 XML 文件名定义单个资源，而 <code>values/</code> 目录中的文件可描述多个资源。对于此目录中的文件，<code>&lt;resources&gt;</code> 元素的每个子元素均会定义一个资源。例如，<code>&lt;string&gt;</code> 元素会创建 R.string 资源，<code>&lt;color&gt;</code> 元素会创建 R.color 资源。<br />由于每个资源均使用自己的 XML 元素进行定义，因此您可以随意命名文件，并在某个文件中放入不同的资源类型。但是，您可能需要将独特的资源类型放在不同的文件中，使其一目了然。例如，对于可在此目录中创建的资源，下面给出了相应的文件名约定: <br />arrays.xml: 资源数组(类型数组)。<br />colors.xml: 颜色值。<br />dimens.xml: 尺寸值。<br />strings.xml: 字符串值。<br />styles.xml: 样式。<br />请参阅字符串资源、样式资源和更多资源类型。</td>\n</tr>\n<tr>\n<td>xml/</td>\n<td>可在运行时通过调用 Resources.getXML() 读取的任意 XML 文件。各种 XML 配置文件(如可搜索配置)都必须保存在此处。</td>\n</tr>\n<tr>\n<td>font/</td>\n<td>带有扩展名的字体文件(如 .ttf、.otf 或 .ttc)，或包含 <code>&lt;font-family&gt;</code> 元素的 XML 文件。如需详细了解作为资源的字体，请参阅 XML 中的字体。</td>\n</tr>\n</tbody>\n</table>\n<div><p>警告</p>\n<p>切勿将资源文件直接保存在 <code>res/</code> 目录内，因为这样会造成编译错误。</p>\n</div>\n",
      "date_published": "2020-04-09T00:00:00.000Z",
      "date_modified": "2022-08-20T08:54:00.000Z",
      "authors": [],
      "tags": [
        "Android"
      ]
    },
    {
      "title": "Angular",
      "url": "https://github.com/MisterChen9527/code/angular/",
      "id": "https://github.com/MisterChen9527/code/angular/",
      "summary": "Angular 是 Google 官方在 2016 年 9 月出品的一款框架。\n框架强制 Typescript，更倾向于大型项目。\n",
      "content_html": "<p>Angular 是 Google 官方在 2016 年 9 月出品的一款框架。</p>\n<p>框架强制 Typescript，更倾向于大型项目。</p>\n\n<div><p>Angular 的优点</p>\n<ol>\n<li>零配置 CLI，享受到 webpack 每次升级的好处，但是不用关心任何 webpack config</li>\n<li>官方提供所有的必须组件(http、router、animation、ssr、e2e 等等)，在 2000+ 内部应用测试之后才会发布，基本零 bug，并且保证在未来很多年内一直保证兼容升级</li>\n<li>提供官方的应用市场和 low code 生成工具，一行命令就可以生成 Dashboard 和各种页面</li>\n<li>框架 100% 由 TypeScript 开发，并且生态内的所有三方库都是(只能用) TypeScript 开发</li>\n<li>内置 RxJS，并且从 View 的操作到 Http 全部都是 Reactive 的，可以随意组合</li>\n<li>每次升级只要运行一行命令就会帮您修复所有的可能的不兼容问题</li>\n<li>通过 Template 隔绝底层的 Compiler 升级成本，Compiler 迭代了三代，性能不断提升，bundle size 不断减少，但是用户代码一行不用改</li>\n</ol>\n</div>\n<p>Angular 写起来其实是有诸多限制的，但是对企业的大型项目来说，这些限制与规范会带来多人协同开发和后期维护上的简便。</p>\n<p>如果您在前端框架上追求的更多是: 升级稳定、标准统一、长期维护成本低、协作方便，不需要频繁重构，Angular 的使用感受应该还是相当不错的，这也是为什么目前大量企业用户会选择 Angular 的原因。</p>\n<h2 id=\"相关链接\" tabindex=\"-1\"> 相关链接</h2>\n<ul>\n<li><a href=\"https://angular.io/docs\" target=\"_blank\" rel=\"noopener noreferrer\">官方文档</a></li>\n<li><a href=\"https://angular.cn/docs\" target=\"_blank\" rel=\"noopener noreferrer\">中文文档</a></li>\n</ul>\n",
      "date_published": "2020-05-06T00:00:00.000Z",
      "date_modified": "2022-08-20T08:54:00.000Z",
      "authors": [],
      "tags": [
        "前端"
      ]
    },
    {
      "title": "后端开发",
      "url": "https://github.com/MisterChen9527/code/backEnd/",
      "id": "https://github.com/MisterChen9527/code/backEnd/",
      "content_html": "<h2 id=\"后端入门\" tabindex=\"-1\"> 后端入门</h2>\n<h3 id=\"php\" tabindex=\"-1\"> PHP</h3>\n<p>PHP 是一种创建动态交互性站点的强有力的服务器端脚本语言，免费，并且使用非常广泛。PHP (全称 Hypertext Preprocessor，即超文本预处理器)是一种通用开源脚本语言。</p>\n<p>PHP 手册:</p>\n<ul>\n<li>\n<p><a href=\"http://www.w3school.com.cn/php/index.asp\" target=\"_blank\" rel=\"noopener noreferrer\">W3School 教程</a></p>\n</li>\n<li>\n<p><a href=\"https://www.runoob.com/php/php-tutorial.html\" target=\"_blank\" rel=\"noopener noreferrer\">菜鸟教程</a></p>\n</li>\n</ul>\n<p>如果服务器访问数量不大的情况下，PHP 作为一种门槛低，开发方便的脚本语言，还是挺受到欢迎的。</p>\n<h3 id=\"asp\" tabindex=\"-1\"> ASP</h3>\n<p>ASP 文件可包含文本、HTML 标签和脚本。ASP 文件中的脚本可在服务器上执行。由于 ASP 在服务器上运行，浏览器无需支持客户端脚本就可以显示 ASP 文件!</p>\n<ul>\n<li>\n<p><a href=\"http://www.w3school.com.cn/asp/index.asp\" target=\"_blank\" rel=\"noopener noreferrer\">W3School 教程</a></p>\n</li>\n<li>\n<p><a href=\"https://www.runoob.com/asp/asp-tutorial.html\" target=\"_blank\" rel=\"noopener noreferrer\">菜鸟教程</a></p>\n</li>\n</ul>\n<div><p>提示</p>\n<p>更多详情有待日后补充</p>\n</div>\n",
      "date_published": "2019-09-10T00:00:00.000Z",
      "date_modified": "2022-08-20T08:54:00.000Z",
      "authors": [],
      "tags": [
        "后端"
      ]
    },
    {
      "title": "操作系统",
      "url": "https://github.com/MisterChen9527/code/basic/OS.html",
      "id": "https://github.com/MisterChen9527/code/basic/OS.html",
      "summary": "操作系统 (Operating System，OS) 是软件的一部分，它是硬件基础上的第一层软件，是硬件和其它软件沟通的桥梁(或者说接口、中间人、中介等)。\n",
      "content_html": "<p>操作系统 (Operating System，OS) 是软件的一部分，它是硬件基础上的第一层软件，是硬件和其它软件沟通的桥梁(或者说接口、中间人、中介等)。</p>\n\n<p>操作系统会控制其他程序运行，管理系统资源，提供最基本的计算功能，如管理及配置内存、决定系统资源供需的优先次序等，同时还提供一些基本的服务程序，例如:</p>\n<ol>\n<li>\n<p>文件系统</p>\n<p>提供计算机存储信息的结构，信息存储在文件中，文件主要存储在计算机的内部硬盘里，在目录的分层结构中组织文件。文件系统为操作系统提供了组织管理数据的方式。</p>\n</li>\n<li>\n<p>设备驱动程序</p>\n<p>提供连接计算机的每个硬件设备的接口，设备驱动器使程序能够写入设备，而不需要了解执行每个硬件的细节。简单来说，就是让您能吃到鸡蛋，但不用养一只鸡。</p>\n</li>\n<li>\n<p>用户接口</p>\n<p>操作系统需要为用户提供一种运行程序和访问文件系统的方法。如常用的 Windows 图形界面，可以理解为一种用户与操作系统交互的方式；智能手机的 Android 或 iOS 系统，也是一种操作系统的交互方式。</p>\n</li>\n<li>\n<p>系统服务程序</p>\n<p>当计算机启动时，会自启动许多系统服务程序，执行安装文件系统、启动网络服务、运行预定任务等操作。</p>\n</li>\n</ol>\n<p>打个比方，操作系统就好像是一个政府，其它软件都会被它管控；操作系统在给其他软件提供各种便利的同时，还会约束其他软件不能为所欲为。</p>\n<p><img src=\"@source/code/basic/assets/OS.gif\" alt=\"操作系统结构示意图\"></p>\n<p>目前流行的服务器和 PC 端操作系统有 Linux、Windows、UNIX 等，手机操作系统有 Android、iOS，嵌入式操作系统有 Windows CE、PalmOS、eCos、uClinux 等。</p>\n",
      "date_published": "2019-12-26T00:00:00.000Z",
      "date_modified": "2022-08-20T08:54:00.000Z",
      "authors": [],
      "tags": [
        "基础"
      ]
    },
    {
      "title": "基础介绍",
      "url": "https://github.com/MisterChen9527/code/basic/",
      "id": "https://github.com/MisterChen9527/code/basic/",
      "summary": "这些是一些最为基础的内容，是后来补充进博客中的，供访客查阅。\n",
      "content_html": "<p>这些是一些最为基础的内容，是后来补充进博客中的，供访客查阅。</p>\n\n<ul>\n<li>\n<p><a href=\"/code/basic/computer.html\">计算机</a></p>\n</li>\n<li>\n<p><a href=\"/code/basic/OS.html\">操作系统</a></p>\n</li>\n<li>\n<p><a href=\"/code/basic/file-extension.html\">文件扩展名</a></p>\n</li>\n<li>\n<p><a href=\"/code/basic/encoding.html\">文件编码</a></p>\n</li>\n<li>\n<p><a href=\"/code/basic/path.html\">路径</a></p>\n</li>\n<li>\n<p><a href=\"/code/basic/debug.html\">开发简介</a></p>\n</li>\n<li>\n<p><a href=\"/code/basic/ci.html\">持续集成</a></p>\n</li>\n<li>\n<p><a href=\"/code/basic/open-source-and-free.html\">开源与免费</a></p>\n</li>\n</ul>\n",
      "date_published": "2019-12-26T00:00:00.000Z",
      "date_modified": "2022-08-20T08:54:00.000Z",
      "authors": [],
      "tags": [
        "基础"
      ]
    },
    {
      "title": "持续集成",
      "url": "https://github.com/MisterChen9527/code/basic/ci.html",
      "id": "https://github.com/MisterChen9527/code/basic/ci.html",
      "summary": "持续集成 (Continuous Integration) 指的是，频繁地 (一天多次) 将代码集成到主干，每次集成都通过自动化的构建 (包括编译，发布，自动化测试) 来验证，从而尽早地发现集成错误。\n持续集成的目的让产品可以快速迭代，同时还能保持高质量。就是说每完成一个完整的部分，就向下个环节交付，发现问题可以马上调整，使得问题不会放大到其他部分和后面的环节。\n",
      "content_html": "<p>持续集成 (Continuous Integration) 指的是，频繁地 (一天多次) 将代码集成到主干，每次集成都通过自动化的构建 (包括编译，发布，自动化测试) 来验证，从而尽早地发现集成错误。</p>\n<p>持续集成的目的让产品可以快速迭代，同时还能保持高质量。就是说每完成一个完整的部分，就向下个环节交付，发现问题可以马上调整，使得问题不会放大到其他部分和后面的环节。</p>\n\n<h2 id=\"介绍\" tabindex=\"-1\"> 介绍</h2>\n<p>持续集成 (CI) 是一种需要频繁提交代码到共享仓库的软件实践。频繁提交代码能较早检测到错误，减少在查找错误来源时开发者需要调试的代码量。 频繁的代码更新也更便于从软件开发团队的不同成员合并更改。 这对开发者非常有益，他们可以将更多时间用于编写代码，而减少在调试错误或解决合并冲突上所花的时间。</p>\n<p>提交代码到仓库时，可以持续创建并测试代码，以确保提交未引入错误。 您的测试可以包括代码语法检查 (检查样式格式) 、安全性检查、代码覆盖率、功能测试及其他自定义检查。</p>\n<p>创建和测试代码需要服务器。 您可以在推送代码到仓库之前在本地创建并测试更新，也可以使用 CI 服务器检查仓库中的新代码提交。</p>\n<h3 id=\"要点\" tabindex=\"-1\"> 要点</h3>\n<p>它的核心措施是，代码集成到主干之前，必须通过自动化测试。只要有一个测试用例失败，就不能集成。</p>\n<h3 id=\"优点\" tabindex=\"-1\"> 优点</h3>\n<ol>\n<li>\n<p>提高开发效率</p>\n</li>\n<li>\n<p>快速发现并定位 Bugs</p>\n</li>\n<li>\n<p>更快速发布更新</p>\n</li>\n</ol>\n<hr>\n<p>与持续集成相关的，还有两个概念，分别是持续交付和持续部署。</p>\n<h2 id=\"持续交付\" tabindex=\"-1\"> 持续交付</h2>\n<p><strong>持续交付 (Continuous Delivery) 指的是，频繁地将软件的新版本，交付给质量团队或者用户，以供评审。</strong> 如果评审通过，代码就进入生产阶段。</p>\n<p>持续交付可以看作持续集成的下一步。它强调的是，不管怎么更新，软件是随时随地可以交付的。</p>\n<p>持续交付意味着所有的变更都可以被部署到生产环境中，如果代码没有问题，可以继续手动部署到生产环境中。</p>\n<h2 id=\"持续部署\" tabindex=\"-1\"> 持续部署</h2>\n<p><strong>持续部署 (Continuous Deployment) 是持续交付的下一步，指的是代码通过评审以后，自动部署到生产环境。</strong></p>\n<p>持续部署的目标是，代码在任何时刻都是可部署的，可以进入生产阶段。</p>\n<h2 id=\"流程\" tabindex=\"-1\"> 流程</h2>\n<p>一个大型项目严格的流程如下:</p>\n<ol>\n<li>\n<p>提交</p>\n<p>流程的第一步，是开发者向代码仓库提交代码。所有后面的步骤都始于本地代码的一次提交 (commit)。</p>\n</li>\n<li>\n<p>测试 (第一轮)</p>\n<p>代码仓库对 commit 操作配置了钩子 (hook) ，只要提交代码或者合并进主干，就会跑自动化测试。</p>\n<p>测试分为好几种,</p>\n<ul>\n<li>单元测试: 针对函数或模块的测试</li>\n<li>集成测试: 针对整体产品的某个功能的测试，又称功能测试</li>\n<li>端对端测试: 从用户界面直达数据库的全链路测试</li>\n</ul>\n<p>第一轮至少要跑单元测试。</p>\n</li>\n<li>\n<p>构建</p>\n<p>通过第一轮测试，代码就可以合并进主干，就算可以交付了。</p>\n<p>交付后，就先进行构建 (build)，再进入第二轮测试。所谓构建，指的是将源码转换为可以运行的实际代码，比如安装依赖，配置各种资源 (样式表、JS 脚本、图片) 等等。</p>\n<p>常用的构建工具如下,</p>\n<ul>\n<li>Jenkins</li>\n<li>Travis</li>\n<li>Codeship</li>\n<li>Strider</li>\n</ul>\n<p>Jenkins 和 Strider 是开源软件， Travis 和 Codeship 对于开源项目可以免费使用。它们都会将构建和测试，在一次运行中执行完成。</p>\n</li>\n<li>\n<p>测试 (第二轮)</p>\n<p>构建完成，就要进行第二轮测试。如果第一轮已经涵盖了所有测试内容，第二轮可以省略，当然，这时构建步骤也要移到第一轮测试前面。</p>\n<p>第二轮是全面测试，单元测试和集成测试都会跑，有条件的话，也要做端对端测试。所有测试以自动化为主，少数无法自动化的测试用例，就要人工跑。</p>\n<p>需要强调的是，新版本的每一个更新点都必须测试到。如果测试的覆盖率不高，进入后面的部署阶段后，很可能会出现严重的问题。</p>\n</li>\n<li>\n<p>部署</p>\n<p>通过了第二轮测试，当前代码就是一个可以直接部署的版本 (artifact)。将这个版本的所有文件打包 (tar filename.tar *) 存档，发到生产服务器。</p>\n<p>生产服务器将打包文件，解包成本地的一个目录，再将运行路径的符号链接 (symlink) 指向这个目录，然后重新启动应用。这方面的部署工具有 Ansible， Chef， Puppet 等。</p>\n</li>\n<li>\n<p>回滚</p>\n<p>一旦当前版本发生问题，就要回滚到上一个版本的构建结果。最简单的做法就是修改一下符号链接，指向上一个版本的目录。</p>\n</li>\n</ol>\n",
      "date_published": "2021-02-18T00:00:00.000Z",
      "date_modified": "2022-08-20T08:54:00.000Z",
      "authors": [],
      "tags": [
        "基础"
      ]
    },
    {
      "title": "计算机",
      "url": "https://github.com/MisterChen9527/code/basic/computer.html",
      "id": "https://github.com/MisterChen9527/code/basic/computer.html",
      "summary": "计算机是一台机器，它按照用户的要求接收信息、存储数据、处理数据，然后再将处理结果输出(文字、图片、音频、视频等)。\n计算机的核心就是: 接受使用者输入指令与资料，经由中央处理器的数学与逻辑单元运算处理后，以产生或储存成有用的资讯。\n",
      "content_html": "<p>计算机是一台机器，它按照用户的要求接收信息、存储数据、处理数据，然后再将处理结果输出(文字、图片、音频、视频等)。</p>\n<p>计算机的核心就是: 接受使用者输入指令与资料，经由中央处理器的数学与逻辑单元运算处理后，以产生或储存成有用的资讯。</p>\n\n<div><p>提示</p>\n<p>也就是说一般商店用的简易型加减乘除计算机、手机、卫星定位系统(GPS)、提款机(ATM)、个人电脑、笔记本电脑(包括 notebook 与 netbook)，还有平板电脑与智能手机等，都叫计算机。</p>\n</div>\n<h2 id=\"组成\" tabindex=\"-1\"> 组成</h2>\n<p>计算机由硬件和软件组成:</p>\n<h3 id=\"硬件\" tabindex=\"-1\"> 硬件</h3>\n<p>硬件是计算机赖以工作的实体，包括显示器、键盘、鼠标、硬盘、CPU、主板等；</p>\n<p>严格意义上讲，硬件可以分为三个部分:</p>\n<ul>\n<li>输入单元: 包括键盘、鼠标、读卡器、扫描器、手写板、触控屏等等一堆；</li>\n<li>主机部分: 这个就是系统单元，被主机机壳保护住了，里面含有主板、CPU 、内存、硬盘等；</li>\n<li>输出单元: 例如显示器、打印机等等</li>\n</ul>\n<p>计算机的重点在于中央处理器 (Central Processing Unit, CPU)，CPU 为一个具有特定功能的晶片，里头含有微指令集，如果您想要让主机进行什么特异的功能，就得要参考这颗 CPU 是否有相关内建的微指令集才可以。由于 CPU 的工作主要在于管理与运算，因此在 CPU 内又可分为两个主要的单元，分别是: 算数逻辑单元与控制单元。其中算数逻辑单元主要负责程式运算与逻辑判断，控制单元则主要在协调各周边元件与各单元间的工作。</p>\n<p>既然 CPU 的重点是在进行运算与判断，那么要被运算与判断的资料是从哪里来的? CPU 读取的资料都是从内存来的! 内存内的资料则是从输入单元所传输进来! 而 CPU 处理完毕的资料也必须要先写回内存中，最后资料才从内存传输到输出单元。</p>\n<h3 id=\"软件\" tabindex=\"-1\"> 软件</h3>\n<p>软件会按照用户的要求协调整台计算机的工作，比如 Windows、Linux、Mac OS、Android 等操作系统，以及 Office、QQ、迅雷、微信等应用程序。</p>\n",
      "date_published": "2019-12-26T00:00:00.000Z",
      "date_modified": "2022-08-20T08:54:00.000Z",
      "authors": [],
      "tags": [
        "基础"
      ]
    },
    {
      "title": "开发简介",
      "url": "https://github.com/MisterChen9527/code/basic/debug.html",
      "id": "https://github.com/MisterChen9527/code/basic/debug.html",
      "summary": "开发是根据用户要求建造出合理程序的过程。过程一般是用某种程序设计语言来实现的。通常采用开发工具可以进行开发。\n",
      "content_html": "<p>开发是根据用户要求建造出合理程序的过程。过程一般是用某种程序设计语言来实现的。通常采用开发工具可以进行开发。</p>\n\n<h2 id=\"小团队的具体分工\" tabindex=\"-1\"> 小团队的具体分工</h2>\n<p>对于小团队而言，经典的划分主要还分为三个板块</p>\n<h3 id=\"ui-设计\" tabindex=\"-1\"> UI 设计</h3>\n<p>UI 即 User Interface (用户界面) 的简称。泛指用户的操作界面。UI 设计主要指界面的样式，美观程度。而使用上，对软件的人机交互、操作逻辑、界面美观的整体设计则是同样重要的另一个门道。</p>\n<p>UI 可以让软件变得有个性有品味，还要让软件的操作变得舒适、简单、自由，充分体现软件的定位和特点。</p>\n<div><p>提示</p>\n<p>在开发中，UI 设计主要指<strong>界面元素设计</strong>和<strong>交互设计</strong>两部分。</p>\n</div>\n<h3 id=\"前端开发\" tabindex=\"-1\"> 前端开发</h3>\n<p>前端开发是创建 Web 页面或 App 等前端界面呈现给用户的过程。前端开发通过 HTML，CSS 及 JavaScript 以及衍生出来的各种技术、框架、解决方案，来实现互联网产品的用户界面交互。</p>\n<div><p>提示</p>\n<p>在开发中，前端开发直接<strong>使用 UI 设计提供的素材</strong>并参照 UI 设计提供的<strong>界面图与交互逻辑</strong>对其设想进行<strong>实现</strong>。</p>\n</div>\n<h3 id=\"后端开发\" tabindex=\"-1\"> 后端开发</h3>\n<p>根据正在处理的应用程序的大小和范围，后端开发人员要做的事情有很大的不同。在 Web 开发世界中，大多数后端开发人员从事于构建他们正在工作的应用程序背后的实际逻辑。其负责是网站后台逻辑的设计和实现还有用户及网站的数据的保存和读取。</p>\n<div><p>提示</p>\n<p>在开发中，后端开发提供与其他服务器<strong>交互数据</strong>，为用户<strong>检索或转换数据</strong>并<strong>对用户数据加以收集与储存</strong>。</p>\n</div>\n<h2 id=\"公司开发\" tabindex=\"-1\"> 公司开发</h2>\n<div><p>注</p>\n<p>如果从职位细分的话，可以分出产品、交互、设计、开发、测试、策划、运营、维护等。</p>\n</div>\n<h3 id=\"产品设计\" tabindex=\"-1\"> 产品设计</h3>\n<p>产品设计对应产品经理，一般负责整体内容的构思，这一过程可能还包括用户和市场调研，确定要做的产品的功能、大致交互格式，也就是将成品的草稿设计出来，</p>\n<h3 id=\"设计师\" tabindex=\"-1\"> 设计师</h3>\n<p>设计师主要和产品设计合作，对一个 App 或者网站的大致页面布局、交互流程进行设计，并提供大致的页面切图，交互流程文档等。</p>\n<h3 id=\"交互\" tabindex=\"-1\"> 交互</h3>\n<p>交互一般负责具体交互流程的细节，会逐步细化，考虑用户习惯，操作的步骤以及长度。综合考量整个交互设计对用户体验以及流失率、活跃程度的影响。</p>\n<h3 id=\"开发\" tabindex=\"-1\"> 开发</h3>\n<p>在实际的大型公司发开产品的过程中，开发直接就可以拿到页面的设计图以及完善的交互流程文档，开发的工作就是去实现相应的页面与动画。</p>\n<p>在这一过程中，前端和后端约定接口和参数，前端负责 App 或网站，后端负责服务器上的数据存储与服务。</p>\n<h3 id=\"测试\" tabindex=\"-1\"> 测试</h3>\n<p>通常情况下，测试和开发会完全分开，测试人员在未参与开发的情况下模拟用户，在不同情况下进行测试，以确保产品不会出现问题。</p>\n<p>这里常见的测试有风险测试、压力测试与异常行为测试等。测试软件是否有安全漏洞，是否可承担大量的访问以及是否在一些非常规交互下可以正常工作。</p>\n<h3 id=\"运营\" tabindex=\"-1\"> 运营</h3>\n<p>一般一款产品需要宣发和后续的持续运营，一般就通过偏市场方向的策划和运营进行相关设计，并指导开发进行相关活动的编写与上线。</p>\n<h3 id=\"运维\" tabindex=\"-1\"> 运维</h3>\n<p>一款产品的后端存储可能需要定期的备份与维护，同时软件后端部署的服务器可能要定期的修复漏洞与升级，就需要有专门的人员来进行这一工作，</p>\n",
      "date_published": "2019-12-27T00:00:00.000Z",
      "date_modified": "2022-08-20T08:54:00.000Z",
      "authors": [],
      "tags": [
        "基础"
      ]
    },
    {
      "title": "计算机编码介绍",
      "url": "https://github.com/MisterChen9527/code/basic/encoding.html",
      "id": "https://github.com/MisterChen9527/code/basic/encoding.html",
      "summary": "计算机，不能直接存储文字，存储的是编码。\n计算机只能处理二进制的数据，也就是说计算机只能处理数字。如果要处理文本，比如: 0-9、a-z、A-Z，就必须先把文本转换为数字才能处理。对于这些字符，可以定义一套规则来显示，比如: A 用 110 表示，B 用 111 表示等。\n",
      "content_html": "<p>计算机，不能直接存储文字，存储的是编码。</p>\n<p>计算机只能处理二进制的数据，也就是说计算机只能处理数字。如果要处理文本，比如: <code>0-9</code>、<code>a-z</code>、<code>A-Z</code>，就必须先把文本转换为数字才能处理。对于这些字符，可以定义一套规则来显示，比如: <code>A</code> 用 <code>110</code> 表示，<code>B</code> 用 <code>111</code> 表示等。</p>\n\n<h2 id=\"字符编码\" tabindex=\"-1\"> 字符编码</h2>\n<p>最早的计算机在设计时采用 8 个比特(bit)作为一个字节(byte)，所以，一个字节能表示的最大的整数就是 255(二进制 11111111=十进制 255)，如果要表示更大的整数，就必须用更多的字节。比如两个字节可以表示的最大整数是 <code>65535</code>，4 个字节可以表示的最大整数是 <code>4294967295</code>。</p>\n<p>由于计算机是美国人发明的，因此，最早只有 127 个字符被编码到计算机里，也就是大小写英文字母、数字和一些符号，这个编码表被称为 ASCII 编码，比如大写字母 A 的编码是 65，小写字母 z 的编码是 122。</p>\n<p>但是要处理中文显然一个字节是不够的，至少需要两个字节，而且还不能和 ASCII 编码冲突，所以，中国制定了 GB2312 编码，用来把中文编进去。</p>\n<p>您可以想得到的是，全世界有上百种语言，日本把日文编到 Shift_JIS 里，韩国把韩文编到 Euc-kr 里，各国有各国的标准，就会不可避免地出现冲突，结果就是，在多语言混合的文本中，显示出来会有乱码。</p>\n<p>因此，Unicode 应运而生。Unicode 把所有语言都统一到一套编码里，这样就不会再有乱码问题了。</p>\n<p>Unicode 标准也在不断发展，但最常用的是用两个字节表示一个字符(如果要用到非常偏僻的字符，就需要 4 个字节)。现代操作系统和大多数编程语言都直接支持 Unicode。</p>\n<p>现在，捋一捋 ASCII 编码和 Unicode 编码的区别: ASCII 编码是 1 个字节，而 Unicode 编码通常是 2 个字节。</p>\n<p>字母 A 用 ASCII 编码是十进制的 65，二进制的 01000001；</p>\n<p>字符 0 用 ASCII 编码是十进制的 48，二进制的 00110000，注意字符 <code>'0'</code> 和整数 <code>0</code> 是不同的；</p>\n<p>汉字中已经超出了 ASCII 编码的范围，用 Unicode 编码是十进制的 20013，二进制的 01001110 00101101。</p>\n<p>您可以猜测，如果把 ASCII 编码的 A 用 Unicode 编码，只需要在前面补 0 就可以，因此，A 的 Unicode 编码是 00000000 01000001。</p>\n<p>新的问题又出现了: 如果统一成 Unicode 编码，乱码问题从此消失了。但是，如果您写的文本基本上全部是英文的话，用 Unicode 编码比 ASCII 编码需要多一倍的存储空间，在存储和传输上就十分不划算。</p>\n<p>所以，本着节约的精神，又出现了把 Unicode 编码转化为“可变长编码”的 UTF-8 编码。UTF-8 编码把一个 Unicode 字符根据不同的数字大小编码成 1-6 个字节，常用的英文字母被编码成 1 个字节，汉字通常是 3 个字节，只有很生僻的字符才会被编码成 4-6 个字节。如果您要传输的文本包含大量英文字符，用 UTF-8 编码就能节省空间:</p>\n<table>\n<thead>\n<tr>\n<th>字符</th>\n<th>ASCII</th>\n<th>Unicode</th>\n<th>UTF-8</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>A</td>\n<td>01000001</td>\n<td>00000000 01000001</td>\n<td>01000001</td>\n</tr>\n<tr>\n<td>中</td>\n<td>x</td>\n<td>01001110 00101101</td>\n<td>11100100 10111000 10101101</td>\n</tr>\n</tbody>\n</table>\n<p>从上面的表格还可以发现，UTF-8 编码有一个额外的好处，就是 ASCII 编码实际上可以被看成是 UTF-8 编码的一部分，所以，大量只支持 ASCII 编码的历史遗留软件可以在 UTF-8 编码下继续工作。</p>\n<p>搞清楚 ASCII、Unicode 和 UTF-8 的关系，现在可以总结计算机系统通用的字符编码工作方式:</p>\n<p>在计算机内存中，统一使用 Unicode 编码，当需要保存到硬盘或者需要传输的时候，就转换为 UTF-8 编码。</p>\n<p>用编辑器编辑的时候，从文件读取的 UTF-8 字符被转换为 Unicode 字符到内存里，编辑完成后，保存的时候再把 Unicode 转换为 UTF-8 保存到文件:</p>\n\n<p>浏览网页的时候，服务器会把动态生成的 Unicode 内容转换为 UTF-8 再传输到浏览器:</p>\n<p>所以您看到很多网页的源码上会有类似 <code>&lt;meta charset=&quot;UTF-8&quot; /&gt;</code> 的信息，表示该网页正是用的 UTF-8 编码。</p>\n<h2 id=\"ascii-码\" tabindex=\"-1\"> ASCII 码</h2>\n<p>美国发布的，用 1 个字节 (8 位二进制) 来表示一个字符，共可以表示 2<sup>8</sup>=256 个字符。</p>\n<p>美国的国家语言是英语，只要能表示 0-9、a-z、A-Z、特殊符号。</p>\n<h2 id=\"ansi-编码\" tabindex=\"-1\"> ANSI 编码</h2>\n<p><strong>每个国家为了显示本国的语言，都对 ASCII 码进行了扩展</strong>。用 2 个字节 (16 位二进制) 来表示一个汉字，共可以表示 <span><span><i>Content not supported</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.8141em;\"></span><span><span>2</span><span><span><span><span style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span><span>16</span></span></span></span></span></span></span></span></span><span style=\"margin-right:0.2778em;\"></span><span>=</span><span style=\"margin-right:0.2778em;\"></span></span><span><span style=\"height:0.6444em;\"></span><span>65536</span></span></span></span> 个汉字。例如:</p>\n<ul>\n<li>中国的 ANSI 编码是 GB2312 编码(简体)，对 6763 汉字进行编码，含 600 多特殊字符。另外还有 GBK(简体)。</li>\n<li>日本的 ANSI 编码是 JIS 编码。</li>\n<li>台湾的 ANSI 编码是 BIG5 编码(繁体)。</li>\n</ul>\n<h3 id=\"gbk\" tabindex=\"-1\"> GBK</h3>\n<p>对 GB2312 进行了扩展，用来显示罕见的、古汉语的汉字。现在已经收录了 2.1 万左右。并提供了 1890 个汉字码位。<code>K</code> 的含义就是“扩展”。</p>\n<h2 id=\"unicode-编码-统一编码\" tabindex=\"-1\"> Unicode 编码(统一编码)</h2>\n<p>用 4 个字节 (32 位二进制) 来表示一个字符，想法不错，但效率太低。例如，字母 A 用 ASCII 表示的话一个字节就够，可用 Unicode 编码的话，得用 4 个字节表示，造成了空间的极大浪费。A 的 Unicode 编码是 <code>0000 0000 0000 0000 0000 0000 0100 0000</code></p>\n<h2 id=\"utf-8-unicode-transform-format-编码\" tabindex=\"-1\"> UTF-8 (Unicode Transform Format)编码</h2>\n<p>根据字符的不同，选择其编码的长度。比如:一个字符 A 用 1 个字节表示，一个汉字用 2 个字节表示。</p>\n<p>毫无疑问，开发中，都用 <strong>UTF-8</strong> 编码吧，准没错。</p>\n<div><p>提示</p>\n<p><strong>中文能够使用的字符集两种:</strong></p>\n<ul>\n<li>\n<p>第一种:UTF-8。UTF-8 是国际通用字库，里面涵盖了所有地球上所有人类的语言文字，比如阿拉伯文、汉语、老挝语……</p>\n</li>\n<li>\n<p>第二种:GBK (对 GB2312 进行了扩展)。gb2312 是国标，是中国的字库，里面<strong>仅</strong>涵盖了汉字和一些常用外文，比如日文片假名，和常见的符号。</p>\n</li>\n</ul>\n<p>字库规模: UTF-8 (字全) &gt; gb2312 (只有汉字)</p>\n<p>保存大小: UTF-8 (更臃肿、加载更慢) &gt; gb2312 (更小巧，加载更快)</p>\n</div>\n",
      "date_published": "2019-12-27T00:00:00.000Z",
      "date_modified": "2022-08-20T08:54:00.000Z",
      "authors": [],
      "tags": [
        "基础"
      ]
    },
    {
      "title": "文件名与文件扩展名",
      "url": "https://github.com/MisterChen9527/code/basic/file-extension.html",
      "id": "https://github.com/MisterChen9527/code/basic/file-extension.html",
      "content_html": "<h2 id=\"文件名\" tabindex=\"-1\"> 文件名</h2>\n<p>文件名就是文件的名称，是为了方便人们区分计算机中的不同文件，而给每个文件设定一个指定的名称。</p>\n<p>文件名不能包含控制字符: <code>&lt;</code> <code>&gt;</code> <code>/</code> <code>\\</code> <code>|</code> <code>:</code> <code>&quot;</code> <code>*</code> <code>?</code></p>\n<h2 id=\"文件扩展名\" tabindex=\"-1\"> 文件扩展名</h2>\n<p>文件扩展名 (filename extension) 也称为文件的延伸文件名、后缀名，是操作系统用来标记文件类型的一种机制。通常来说，一个扩展名是跟在主文件名后面的，由一个分隔符分隔。</p>\n<p>文件扩展名是早期操作系统 (如 VMS / CP / M / DOS 等) 用来标志文件格式的一种机制，其更重要的作用是让系统决定当用户想打开这个文件的时候用哪种软件运行，如 Windows 系统中 exe 文件是可执行文件，doc 文件默认用 Microsoft Word 打开的 Word 文件。</p>\n<div><p>误区</p>\n<ol>\n<li>\n<p>文件扩展名是一个文件的必要构成部分。❌</p>\n<p>任何一个文件可以有或没有扩展名。对于打开文件操作，没有扩展名的文件需要选择程序去打开它，有扩展名的文件会自动用设置好的程序(如有)去尝试打开，文件扩展名是一个常规文件的构成部分，但一个文件并不一定需要一个扩展名。</p>\n</li>\n<li>\n<p>文件扩展名表明了该文件是何种类型。❌</p>\n<p>文件扩展名可以人为设定，扩展名为 TXT 的文件有可能是一张图片，同样，扩展名为 MP3 的文件，依然可能是一个视频。</p>\n</li>\n</ol>\n</div>\n",
      "date_published": "2019-12-26T00:00:00.000Z",
      "date_modified": "2022-08-20T08:54:00.000Z",
      "authors": [],
      "tags": [
        "基础"
      ]
    },
    {
      "title": "开源与免费",
      "url": "https://github.com/MisterChen9527/code/basic/open-source-and-free.html",
      "id": "https://github.com/MisterChen9527/code/basic/open-source-and-free.html",
      "summary": "开源软件和免费软件是两个概念:\n\n\n开源软件是指公开源代码的软件。开源软件在发行的时候会附上软件的源代码，并授权允许用户更改、传播或者二次开发。\n\n\n免费软件就是免费提供给用户使用的软件，但是在免费的同时，通常也会有一些限制，比如源代码不公开，用户不能随意修改、不能二次发布等。\n\n\n",
      "content_html": "<p>开源软件和免费软件是两个概念:</p>\n<ul>\n<li>\n<p>开源软件是指公开源代码的软件。开源软件在发行的时候会附上软件的源代码，并授权允许用户更改、传播或者二次开发。</p>\n</li>\n<li>\n<p>免费软件就是免费提供给用户使用的软件，但是在免费的同时，通常也会有一些限制，比如源代码不公开，用户不能随意修改、不能二次发布等。</p>\n</li>\n</ul>\n\n<h2 id=\"免费软件\" tabindex=\"-1\"> 免费软件</h2>\n<p>免费软件的例子比比皆是，QQ、微信、迅雷、酷狗、360 等都是免费软件，您可以随意使用，尽情蹂躏；但是，如果您嫌弃它们复杂，自己删除了一些无用的功能，然后在网上发布了一个精简版本供大家下载，那么您就离法院的传票不远了。</p>\n<h2 id=\"开源软件\" tabindex=\"-1\"> 开源软件</h2>\n<p>开源软件是不抵触商业的，开源的目的也不是做慈善事业，而是通过更多人的参与，减少软件的缺陷，丰富软件的功能，同时也避免了少数人在软件里留一些不正当的后门。开源软件最终还会反哺商业，让商业公司为用户提供更好的产品。</p>\n<p>Android 就是大众最熟知的一款开源操作系统，它除了用在手机上，还用在汽车、平板电脑、电视、智能手表等其它硬件平台，小米、华为、OPPO、三星等都是 Android 的受益者，他们都赚得盆满钵满。</p>\n<p>很多著名的开源项目背后都有商业公司支撑，它们的开发者也都有正式的工作，享受和我们一样的社会福利；如果一个成功的开源项目背后没有商业公司，这反而是不健康的，社会需要开源和商业之间的互补来促进技术的革新。</p>\n<p>开源软件和商业公司的裙带关系:</p>\n<ul>\n<li>\n<p>Android 由全球最大的互联网公司 Google 支持；</p>\n</li>\n<li>\n<p>市场占有率最高的关系型数据库 mysql 已经被上市公司 Oracle 收购；</p>\n</li>\n<li>\n<p>linux 不但被 Microsoft、IBM、Intel、SAMSUNG 等巨头免费赞助，还接收它们贡献的源代码；</p>\n</li>\n<li>\n<p>Python 目前属于 python.org 开源组织，它收到了 Facebook、Google、Amazon、Redhat、Microsoft 等商业公司的赞助。</p>\n</li>\n</ul>\n<h2 id=\"开源软件的盈利模式\" tabindex=\"-1\"> 开源软件的盈利模式</h2>\n<p>伟大的开源软件的背后都有巨量的资金流入，没有资金支撑的开源软件是无法长久的。那么，开源软件究竟是如何盈利的呢?</p>\n<ol>\n<li>\n<p>双重许可</p>\n<p>有些开源软件不但有一个免费的基础版本，还有一个收费的商业版本。免费版本能够促进传播，让用户爱上该软件；收费版本功能更加丰富，还提供技术支持。这种情况在开源界非常普遍。</p>\n<p>例如 MySQL 就同时推出面向个人和企业的两种版本，即开源版本和专业版本，分别采用不同的授权方式: 开源版本完全免费以便更好的推广，而从专业版的许可销售和支持服务获得收入。</p>\n</li>\n<li>\n<p>技术支持</p>\n<p>很多软件在使用上不收取费用，但当用户在使用产品遇到困难，需要技术支持的时候，就需要付费了。技术支持收费的这项服务，也是一些开源公司的生计之路。</p>\n<p>例如，最大的开源软件公司 Redhat 被 IBM 收购，卖了 340 亿美元。Redhat 虽然提供免费的 Linux 发行版(当然也有收费的版本)，但是当使用者遇到技术障碍，或者想升级硬件的时候，Redhat 可以提供付费支持。</p>\n<p>举个例子，纽交所在用免费的红帽 Linux 系统交易股票。英特尔最近升级了处理器，纽交所想用新处理器提高效率，但这需要有人为新硬件部署新的系统和应用程序。同样的事每隔几年会发生一次。纽交所可以养一个团队自己完成所有系统维护、开发工作，也可以花钱请红帽的工程师来做。相当数量的企业用户都选择了后者。</p>\n</li>\n<li>\n<p>附加服务</p>\n<p>JBoss 就是这种模式的典型代表。JBoss 应用服务器完全免费，而通过提供技术文档、培训、二次开发支持等技术服务而获得收入。</p>\n<p>开源软件出版商 O’Reilly 公司也是这种模式，它不遗余力地联系开源软件的权威人士，组织各种开源软件的会议，虽然知识是免费的，但承载知识的书籍却是收费的。</p>\n</li>\n<li>\n<p>应用服务托管(ASP)</p>\n<p>例如 PHP Live ! 就是一种构架于 PHP、MySQL 之上的开源软件，它可为企业用户提供实时交谈服务。目前已经有数十家公开提供 PHP Live! 托管服务的应用服务提供商。</p>\n</li>\n<li>\n<p>软硬件一体化</p>\n<p>比如 IBM、HP 等服务器供应商巨头，通过捆绑免费的 Linux 操作系统销售硬件服务器。SUN 公司近期将其 Solaris 操作系统开放源码，以确保服务器硬件的销售收入，也是这种模式的体现。</p>\n<p>这些巨头每年在开源软件领域的投入巨大，但这一切并非是做善事，它们可以从配置了开源软件的硬件中获得巨额回报。</p>\n</li>\n<li>\n<p>部分组件收费</p>\n<p>开源免费的软件可以满足大部分用户的需求，但是也有很多用户需要一些特殊的定制服务，这个时候软件公司就会收取一定的费用。</p>\n</li>\n<li>\n<p>版权收费</p>\n<p>虽然代码是开源的，但很多作者会采用一些开源协议来限制自己版权问题，如果用户想要去版权，是需要另外付费的。</p>\n</li>\n<li>\n<p>捐款/赞助</p>\n<p>很多开源软件都有一些捐款渠道，喜爱该软件的用户，或者该软件的受益者都可以进行资金支持。</p>\n<p>例如，Python 就有一个软件基金协会，它收到了来自 Facebook、Amazon、Google、Redhat、Microsoft 等巨头的赞助。</p>\n<p>这些公司也不傻，他们为什么会赞助 Python 呢? 因为这些公司大量使用了 Python 语言，他们希望 Python 能够持续发展，如果 Python 倒了，他们也会跟着倒霉。</p>\n</li>\n</ol>\n",
      "date_published": "2020-06-05T00:00:00.000Z",
      "date_modified": "2022-08-20T08:54:00.000Z",
      "authors": [],
      "tags": [
        "基础"
      ]
    },
    {
      "title": "路径",
      "url": "https://github.com/MisterChen9527/code/basic/path.html",
      "id": "https://github.com/MisterChen9527/code/basic/path.html",
      "summary": "无论是我们想直接访问一个文件，还是在一个文件中希望访问另一个文件，都涉及到一个获取文件的操作。而无论是在 Windows 中还是在 Linux 中，文件的具体位置都用文档的路径标注。\n路径常常涉及到物理路径，相对路径，绝对路径，根目录的概念，现加以说明。\n",
      "content_html": "<p>无论是我们想直接访问一个文件，还是在一个文件中希望访问另一个文件，都涉及到一个获取文件的操作。而无论是在 Windows 中还是在 Linux 中，文件的具体位置都用文档的路径标注。</p>\n<p>路径常常涉及到物理路径，相对路径，绝对路径，根目录的概念，现加以说明。</p>\n\n<h2 id=\"物理路径\" tabindex=\"-1\"> 物理路径</h2>\n<p>物理路径的英文全称是: Physical path，它就是指硬盘上文件的路径，比如下面的文件位置表示方法:</p>\n<div><pre><code>d:\\wwwroot\\html\\a.html\nd:\\wwwroot\\html\\photo\\b.html\nd:\\wwwroot\\html\\photo\\c.html\nd:\\wwwroot\\html\\photo\\ours\\d.html\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div></div></div><blockquote>\n<p><code>D:</code> 与 <code>d:</code> 均可。盘符不分大小写。</p>\n</blockquote>\n<p>一般来说物理路径可用于访问本地文件，即不通过 WEB 服务器(如: 本地调试)等的情况下。</p>\n<h2 id=\"相对路径\" tabindex=\"-1\"> 相对路径</h2>\n<p>相对路径的英文全称是 Relative Path，我们可以从以下三个方面来了解它的用法 (以“物理路径”中的位置情况为例):</p>\n<ul>\n<li>\n<p>如何表示同级目录的文件</p>\n<p>b.html 和 c.html 在同一个文件夹下，如果 b.html 需要链接到 c.html，可以在 b.html 中这样写:</p>\n<div><pre><code><span><span><span>&lt;</span>a</span> <span>href</span><span><span>=</span><span>\"</span>./c.html<span>\"</span></span><span>></span></span>同目录下文件间互相链接<span><span><span>&lt;/</span>a</span><span>></span></span>\n</code></pre><div aria-hidden=\"true\"><div></div></div></div><p>代码中的 <code>./</code> 代表同级目录。</p>\n<p><code>./</code>是相对路径，也可以省略不写，省略不写，即直接以文件夹或文件名称开头的路径也是相对路径。</p>\n<div><pre><code><span><span><span>&lt;</span>a</span> <span>href</span><span><span>=</span><span>\"</span>./c.html<span>\"</span></span><span>></span></span>同目录下文件间互相链接<span><span><span>&lt;/</span>a</span><span>></span></span>\n</code></pre><div aria-hidden=\"true\"><div></div></div></div></li>\n<li>\n<p>如何表示上级目录的文件</p>\n<p>a.html 是 b.html 和 c.html 的上级目录中的文件，如果 b.html 或 c.html 链接到 a.html，可以在 b.html 或 c.html 中这样写:</p>\n<div><pre><code><span><span><span>&lt;</span>a</span> <span>href</span><span><span>=</span><span>\"</span>../a.html<span>\"</span></span><span>></span></span>链接到上级目录中的文件<span><span><span>&lt;/</span>a</span><span>></span></span>\n</code></pre><div aria-hidden=\"true\"><div></div></div></div><p>代码中的 <code>../</code> 代表一级上级目录(间隔一个目录)。</p>\n<p>需要注意的是: “<code>../../</code>”代表二级上级目录(间隔两个目录)，比如 a.html 是 d.html 的前两级目录，同时 d.html 需要链接到 a.html，可以在 d.html 中这样写:</p>\n<div><pre><code><span><span><span>&lt;</span>a</span> <span>href</span><span><span>=</span><span>\"</span>../../a.html<span>\"</span></span><span>></span></span>链接到上级目录的上级目录中的文件<span><span><span>&lt;/</span>a</span><span>></span></span>\n</code></pre><div aria-hidden=\"true\"><div></div></div></div></li>\n<li>\n<p>如何表示子目录的文件</p>\n<p>b.html 和 c.html 是 a.html 的子目录中的文件，如果需要在 a.html 中链接到 b.html， 可以在 a.html 中这样写:</p>\n<div><pre><code><span><span><span>&lt;</span>a</span> <span>href</span><span><span>=</span><span>\"</span>photo/b.html<span>\"</span></span><span>></span></span>链接到子目录(photo)中的文件<span><span><span>&lt;/</span>a</span><span>></span></span>\n如果需要在a.html中链接到d.html，可以在a.html中这样写\n<span><span><span>&lt;</span>a</span> <span>href</span><span><span>=</span><span>\"</span>photo/ours/d.html<span>\"</span></span><span>></span></span>链接到子目录(photo/ourd/)中的文件<span><span><span>&lt;/</span>a</span><span>></span></span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div></div></div></li>\n</ul>\n<h2 id=\"绝对路径\" tabindex=\"-1\"> 绝对路径</h2>\n<p>绝对路径的英文全称是 Absolute Path，它就是带有网址的路径。比如您有一个域名 www.deerol.com，其域名指向 d:\\wwwroot，那么上面的四个文件就可以这么表示:</p>\n<div><pre><code><span><span><span>&lt;</span>a</span> <span>href</span><span><span>=</span><span>\"</span>http://www.deerol.com/html/a.html<span>\"</span></span><span>></span></span>链接到a.html<span><span><span>&lt;/</span>a</span><span>></span></span>\n<span><span><span>&lt;</span>a</span> <span>href</span><span><span>=</span><span>\"</span>http://www.deerol.com/html/photo/b.html<span>\"</span></span><span>></span></span>链接到b.html<span><span><span>&lt;/</span>a</span><span>></span></span>\n<span><span><span>&lt;</span>a</span> <span>href</span><span><span>=</span><span>\"</span>http://www.deerol.com/html/photo/c.html<span>\"</span></span><span>></span></span>链接到c.html<span><span><span>&lt;/</span>a</span><span>></span></span>\n<span><span><span>&lt;</span>a</span> <span>href</span><span><span>=</span><span>\"</span>http://www.deerol.com/html/photo/ours/d.html<span>\"</span></span><span>></span></span>链接到d.html<span><span><span>&lt;/</span>a</span><span>></span></span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div></div></div><h2 id=\"根目录\" tabindex=\"-1\"> 根目录</h2>\n<p>根目录的英文全称是 Root directory，去掉绝对路径前面的域名就是根目录，所以它可以理解为是网站的最上层目录。它的表示方法如下:</p>\n<div><pre><code><span><span><span>&lt;</span>a</span> <span>href</span><span><span>=</span><span>\"</span>/html/a.html<span>\"</span></span><span>></span></span>链接到a.html<span><span><span>&lt;/</span>a</span><span>></span></span>\n<span><span><span>&lt;</span>a</span> <span>href</span><span><span>=</span><span>\"</span>/html/photo/b.html<span>\"</span></span><span>></span></span>链接到b.html<span><span><span>&lt;/</span>a</span><span>></span></span>\n<span><span><span>&lt;</span>a</span> <span>href</span><span><span>=</span><span>\"</span>/html/photo/c.html<span>\"</span></span><span>></span></span>链接到c.html<span><span><span>&lt;/</span>a</span><span>></span></span>\n<span><span><span>&lt;</span>a</span> <span>href</span><span><span>=</span><span>\"</span>/html/photo/ours/d.html<span>\"</span></span><span>></span></span>链接到d.html<span><span><span>&lt;/</span>a</span><span>></span></span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div></div></div><p>在服务器上，根目录即代表网站主页所在的目录。网站服务器一般只能访问网站主页所在文件夹内的文件与文件夹。</p>\n",
      "date_published": "2019-09-20T00:00:00.000Z",
      "date_modified": "2022-08-20T08:54:00.000Z",
      "authors": [],
      "tags": [
        "基础"
      ]
    },
    {
      "title": "GitHub",
      "url": "https://github.com/MisterChen9527/code/github/",
      "id": "https://github.com/MisterChen9527/code/github/",
      "content_html": "<h2 id=\"快速上手\" tabindex=\"-1\"> 快速上手</h2>\n<ul>\n<li>\n<p><a href=\"/code/github/intro.html\">GitHub 介绍</a></p>\n</li>\n<li>\n<p><a href=\"/code/github/semantic.html\">语义化提交</a></p>\n</li>\n<li>\n<p><a href=\"/code/github/pages.html\">GitHub Pages</a></p>\n</li>\n<li>\n<p><a href=\"/code/github/speedup.html\">利用 Gitee 加速 GitHub 克隆</a></p>\n</li>\n</ul>\n<h2 id=\"官方文档\" tabindex=\"-1\"> 官方文档</h2>\n<ul>\n<li><a href=\"https://docs.github.com/cn/free-pro-team@latest/github\" target=\"_blank\" rel=\"noopener noreferrer\">全部文档</a></li>\n</ul>\n<h3 id=\"入门指南\" tabindex=\"-1\"> 入门指南</h3>\n<ul>\n<li><a href=\"https://docs.github.com/cn/free-pro-team@latest/github/getting-started-with-github\" target=\"_blank\" rel=\"noopener noreferrer\">查看详情</a></li>\n</ul>\n<h3 id=\"快速入门\" tabindex=\"-1\"> 快速入门</h3>\n<ul>\n<li><a href=\"https://docs.github.com/cn/free-pro-team@latest/github/getting-started-with-github/set-up-git\" target=\"_blank\" rel=\"noopener noreferrer\">设置 Git</a></li>\n<li><a href=\"https://docs.github.com/cn/free-pro-team@latest/github/getting-started-with-github/create-a-repo\" target=\"_blank\" rel=\"noopener noreferrer\">创建仓库</a></li>\n<li><a href=\"https://docs.github.com/cn/free-pro-team@latest/github/getting-started-with-github/fork-a-repo\" target=\"_blank\" rel=\"noopener noreferrer\">复刻仓库</a></li>\n<li><a href=\"https://docs.github.com/cn/free-pro-team@latest/github/getting-started-with-github/be-social\" target=\"_blank\" rel=\"noopener noreferrer\">社交化</a></li>\n</ul>\n<h3 id=\"了解-github\" tabindex=\"-1\"> 了解 GitHub</h3>\n<ul>\n<li><a href=\"https://docs.github.com/cn/free-pro-team@latest/github/getting-started-with-github/types-of-github-accounts\" target=\"_blank\" rel=\"noopener noreferrer\">账户类型</a></li>\n<li><a href=\"https://docs.github.com/cn/free-pro-team@latest/github/getting-started-with-github/access-permissions-on-github#%E4%B8%AA%E4%BA%BA%E7%94%A8%E6%88%B7%E5%B8%90%E6%88%B7\" target=\"_blank\" rel=\"noopener noreferrer\">GitHub 上的访问权限</a></li>\n<li><a href=\"https://docs.github.com/cn/free-pro-team@latest/github/getting-started-with-github/github-glossary\" target=\"_blank\" rel=\"noopener noreferrer\">GitHub 词汇表</a></li>\n</ul>\n<h2 id=\"生态系统\" tabindex=\"-1\"> 生态系统</h2>\n<h3 id=\"github-cli\" tabindex=\"-1\"> GitHub Cli</h3>\n<p>GitHub CLI 是用于在计算机上使用 GitHub 功能的命令行工具。</p>\n<p>GitHub CLI 是用于从计算机的命令行使用 GitHub 的开源工具。从命令行操作时，您可以使用 GitHub CLI 来节省时间并避免切换上下文。</p>\n<p>您可以将以下 GitHub 功能与 GitHub CLI 结合使用。</p>\n<ul>\n<li>查看、创建、克隆和复刻仓库</li>\n<li>创建、关闭和列出议题和拉取请求</li>\n<li>审查、差异和合并拉取请求</li>\n<li>创建、编辑、列出和查看 Gist</li>\n</ul>\n<p>有关 GitHub CLI 用途的更多信息，请参阅 <a href=\"https://cli.github.com/manual\" target=\"_blank\" rel=\"noopener noreferrer\">GitHub CLI 手册</a>。</p>\n<h3 id=\"github-desktop\" tabindex=\"-1\"> GitHub Desktop</h3>\n<p>GitHub Desktop 使用可视界面扩展并简化您的 Git 和 GitHub 工作流程。</p>\n<p>GitHub Desktop 是一种开源工具，可帮助您提高工作效率。GitHub Desktop 鼓励您和您的团队使用最佳实践协作处理 Git 和 GitHub。</p>\n<p>您可以使用 GitHub Desktop 执行许多任务，包括:</p>\n<ul>\n<li>以交互方式将更改添加到提交中</li>\n<li>快速将合作作者提交到提交中</li>\n<li>检出具有拉取请求的分支并查看 CI 状态</li>\n<li>比较更改的图像</li>\n</ul>\n<p>有关 GitHub Desktop 的更多信息，请参阅 GitHub Desktop 文档中的 <a href=\"https://docs.github.com/cn/free-pro-team@latest/desktop/installing-and-configuring-github-desktop\" target=\"_blank\" rel=\"noopener noreferrer\">安装和配置 GitHub Desktop</a>。</p>\n<h3 id=\"手机版-github\" tabindex=\"-1\"> 手机版 GitHub</h3>\n<p>从移动设备对 GitHub 上的工作进行分类、协作和管理。</p>\n<p>手机版 GitHub 目前作为 Android 和 iOS app 提供给 GitHub.com 用户。</p>\n<p>手机版 GitHub 为您提供随时随地快速高效使用 GitHub 的方式。手机版 GitHub 是通过可信的第一方客户端应用程序访问 GitHub 数据的安全可靠方式。</p>\n<p>通过 手机版 GitHub，您可以:</p>\n<ul>\n<li>管理、分类和清除通知</li>\n<li>阅读、审查及协作处理问题和拉取请求</li>\n<li>搜索、浏览用户、仓库和组织以及与之交互</li>\n<li>当有人提及您的用户名时收到推送通知</li>\n</ul>\n<h4 id=\"安装-手机版-github\" tabindex=\"-1\"> 安装 手机版 GitHub</h4>\n<p>要安装 Android 或 iOS 版 手机版 GitHub，请参阅 <a href=\"https://github.com/mobile\" target=\"_blank\" rel=\"noopener noreferrer\">手机版 GitHub</a>。</p>\n",
      "date_published": "2019-11-20T00:00:00.000Z",
      "date_modified": "2022-08-20T08:54:00.000Z",
      "authors": [],
      "tags": [
        "GitHub"
      ]
    },
    {
      "title": "自动部署",
      "url": "https://github.com/MisterChen9527/code/github/deploy.html",
      "id": "https://github.com/MisterChen9527/code/github/deploy.html",
      "summary": "本文介绍如何利用 Git 和 GitHub Action，自动部署代码到服务器。\n",
      "content_html": "<p>本文介绍如何利用 Git 和 GitHub Action，自动部署代码到服务器。</p>\n\n<div><p>提示</p>\n<p>由于 Centos 仍然是用 GitV1，本教程使用 Ubuntu 20.04 进行教学。</p>\n</div>\n<h2 id=\"服务器\" tabindex=\"-1\"> 服务器</h2>\n<p>为了能供自动部署到服务器，我们需要让服务器的网站目录成为一个 Git 仓库，这样我们可以在 GitHub Actions 中，通过向服务器对应 GitHub 仓库推送网站内容，使服务器网站获得自动更新。下面是服务器侧的部署配置</p>\n<h3 id=\"添加账户\" tabindex=\"-1\"> 添加账户</h3>\n<p>为了安全，首先需要使用命令创建 Git 用户，为了安全请务必设置密码。</p>\n<div><pre><code><span>sudo</span> adduser <span>git</span>\n</code></pre><div aria-hidden=\"true\"><div></div></div></div><p>之后，查看部署目录所在组，git 用户添加到组中。</p>\n<div><pre><code><span>usermod</span> -a -G <span>&lt;</span>目录所在组<span>></span> <span>git</span>\n</code></pre><div aria-hidden=\"true\"><div></div></div></div><p>然后将部署目录的权限设置为 <code>775</code>，即允许同组访问。这样 git 就有权限访问部署目录。</p>\n<h3 id=\"添加权限\" tabindex=\"-1\"> 添加权限</h3>\n<p>创建 <code>~/.ssh/</code> 文件夹，生成 <code>authorized_keys</code> 文件，并设置其权限为 <code>600</code>。</p>\n<div><pre><code><span>mkdir</span> -p ~/.ssh/\n\n<span>touch</span> ~/.ssh/authorized_keys\n\n<span>chmod</span> <span>600</span> ~/.ssh/authorized_keys\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div></div></div><p>之后将需要赋予权限的用户公钥依次粘贴至该文件，这样相关用户即可以使用对应私钥，向服务器相关仓库推送代码。</p>\n<h3 id=\"创建仓库\" tabindex=\"-1\"> 创建仓库</h3>\n<p>回到 <code>/home/git/</code>，创建所需的文件夹:</p>\n<div><pre><code><span>cd</span> ~\n<span>mkdir</span> <span>&lt;</span>仓库名<span>></span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div></div></div><p>进入文件夹，使用</p>\n<div><pre><code><span>git</span> init --separate-git-dir<span>=</span>. <span>&lt;</span>部署位置<span>></span>\n</code></pre><div aria-hidden=\"true\"><div></div></div></div><p>这会将 git 库保持在 <code>/home/git/&lt;仓库名&gt;</code> 下，同时将工作区设置到部署文件夹中。</p>\n<p>接下来执行:</p>\n<div><pre><code><span>git</span> config receive.denyCurrentBranch ignore\n<span>git</span> config --global --add safe.directory <span>&lt;</span>部署文件夹<span>></span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div></div></div><div><p>注</p>\n<p>Git 默认拒绝外部对当前分支的推送操作，因为这可能会覆盖或变更工作区文件。所以我们需要显式通知 Git 不要拒绝当前分支的推送操作。</p>\n<p>另外在新版本 Git 中，考虑到安全因素，Git 会在检出时检测项目文件夹是否属于其他组成员，如果检测到会默认拒绝相关操作以防止其他用于获取到本不应该获取到的代码信息。因为部署文件夹的所有者通常不会是 git，所以我们需要标记对应的部署文件夹“安全”。</p>\n</div>\n<h2 id=\"github-actions\" tabindex=\"-1\"> GitHub Actions</h2>\n<p>在 GitHub 一侧，我们需要通过 GitHub Action，在新代码推送时自动构建网站，并部署到 GitHub 的 gh-pages 分支。之后，GitHub Action 将该分支的变动推送服务器的对应仓库，完成网站的自动部署。</p>\n<p>之后只需要使用 GitHub Action 通过 Git 推送到 <code>git@&lt;domain&gt;:&lt;部署目录&gt; gh-pages</code> 即可。</p>\n<div><pre><code><span># 自动部署的名称</span>\n<span>name</span><span>:</span> GitHub pages deploy\n\n<span># 自动部署的条件</span>\n<span>on</span><span>:</span>\n  <span>push</span><span>:</span>\n    <span>branches</span><span>:</span>\n      <span>-</span> master\n\n<span>jobs</span><span>:</span>\n  <span># 构建网站并部署到 GitHub Pages</span>\n  <span>deploy-gh-pages</span><span>:</span>\n    <span># 运行环境</span>\n    <span>runs-on</span><span>:</span> ubuntu<span>-</span>latest\n\n    <span># 步骤</span>\n    <span>steps</span><span>:</span>\n      <span># 第一步: 下载源码</span>\n      <span>-</span> <span>name</span><span>:</span> Checkout\n        <span># action 配置详见 https://github.com/actions/checkout</span>\n        <span>uses</span><span>:</span> actions/checkout@v3\n        <span>with</span><span>:</span>\n          <span># 如果本项目包含了子模块 (git submodules)，需要将此项设置为 true</span>\n          <span># submodules: true</span>\n\n          <span># 这是获取历史 commit 的深度，默认为 1，即只拉取最后一个 commit</span>\n          <span># 这样可以加快拉取速度</span>\n          <span>#</span>\n          <span># 如果项目使用 VuePress，为了正确通过 Git 历史提交记录生成页面的最后更新时间</span>\n          <span># 需要设置为 0 以拉取完整的 git 历史提交</span>\n          <span># fetch-depth: 0</span>\n\n          <span># 如果子模块包含私有仓库，需要设置 ssh key 或 token 以保证拥有拉取相应仓库的权限</span>\n          <span># 您可以将 ssh-key 设置为 github 绑定公钥对应的私钥</span>\n          <span># 也可以新建一个具有相关仓库访问权限的 github token</span>\n          <span># token:</span>\n\n      <span># 缓存 node_modules 以避免重复安装</span>\n      <span>-</span> <span>uses</span><span>:</span> actions/cache@v3\n        <span>id</span><span>:</span> node<span>-</span>modules\n        <span>with</span><span>:</span>\n          <span># 需要缓存的路径</span>\n          <span>path</span><span>:</span> node_modules/\n          <span># 缓存的 key</span>\n          <span>key</span><span>:</span> $<span>{</span><span>{</span> runner.os <span>}</span><span>}</span><span>-</span>node<span>-</span>modules<span>-</span>$<span>{</span><span>{</span> hashFiles('yarn.lock') <span>}</span><span>}</span>\n          <span># 恢复 key</span>\n          <span>restore-keys</span><span>:</span> <span>|</span><span>\n            ${{ runner.os }}-node-modules-</span>\n\n      <span># 安装依赖</span>\n      <span>-</span> <span>name</span><span>:</span> Install Deps\n        <span># 只有没有命中缓存才会执行</span>\n        <span>if</span><span>:</span> steps.node<span>-</span>modules.outputs.cache<span>-</span>hit <span>!=</span> 'true'\n        <span># 严格按照 yarn.lock 安装依赖</span>\n        <span>run</span><span>:</span> yarn install <span>-</span><span>-</span>frozen<span>-</span>lockfile\n\n      <span># 构建项目</span>\n      <span>-</span> <span>name</span><span>:</span> Build\n        <span># 项目的构建命令</span>\n        <span>run</span><span>:</span> yarn run build\n\n      <span># 第四步，部署</span>\n      <span>-</span> <span>name</span><span>:</span> Deploy\n        <span># action 配置详见 https://github.com/JamesIves/github-pages-deploy-action</span>\n        <span>uses</span><span>:</span> JamesIves/github<span>-</span>pages<span>-</span>deploy<span>-</span>action@v4\n        <span>with</span><span>:</span>\n          <span># 部署到的分支</span>\n          <span>branch</span><span>:</span> gh<span>-</span>pages\n          <span># 需要部署的文件夹</span>\n          <span>folder</span><span>:</span> dist\n\n  <span># 部署到服务器</span>\n  <span>deploy-server</span><span>:</span>\n    <span>runs-on</span><span>:</span> ubuntu<span>-</span>latest\n    <span># 确保在部署到 GitHub Pages 之后执行</span>\n    <span>needs</span><span>:</span> deploy<span>-</span>gh<span>-</span>pages\n    <span>steps</span><span>:</span>\n      <span># 检出网站代码</span>\n      <span>-</span> <span>name</span><span>:</span> Checkout\n        <span>uses</span><span>:</span> actions/checkout@v3\n        <span>with</span><span>:</span>\n          <span># 检出 gh-pages 分支</span>\n          <span>ref</span><span>:</span> gh<span>-</span>pages\n          <span># 获取全部的历史提交</span>\n          <span>fetch-depth</span><span>:</span> <span>0</span>\n\n      <span># 配置环境</span>\n      <span>-</span> <span>name</span><span>:</span> Configuration environment\n        <span># 写入私钥、配置 Git 用户名，写入服务器地址</span>\n        <span># 您需要自行将服务器的私钥写入 secrets 的 SSH_PRIVATE_KEY</span>\n        <span>run</span><span>:</span> <span>|</span><span>\n          mkdir -p ~/.ssh/\n          echo \"${{ secrets.SSH_PRIVATE_KEY }}\" > ~/.ssh/id_rsa\n          chmod 600 ~/.ssh/id_rsa\n          ssh-keyscan &lt;your domain> >> ~/.ssh/known_hosts\n          git config --global user.name 'Your Name'\n          git config --global user.email 'You email'</span>\n\n      <span># 部署到服务器</span>\n      <span>-</span> <span>name</span><span>:</span> Deploy\n        <span># 使用 Git 将网站代码强制推送到远程的网站目录</span>\n        <span># 并使用 SSH 连接服务器进入网站目录手动切换到最新提交</span>\n        <span>run</span><span>:</span> <span>|</span><span>\n          git push -f git@&lt;your domain>:&lt;deploy dir> gh-pages\n          ssh git@&lt;your domain> \"cd &lt;deploy dir> &amp;&amp; git reset --hard HEAD\"</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div>",
      "date_published": "2022-08-20T08:54:00.000Z",
      "date_modified": "2022-08-20T08:54:00.000Z",
      "authors": [],
      "tags": [
        "GitHub"
      ]
    },
    {
      "title": "GitHub 简介",
      "url": "https://github.com/MisterChen9527/code/github/intro.html",
      "id": "https://github.com/MisterChen9527/code/github/intro.html",
      "content_html": "<h2 id=\"gayhub-github-是世界上最大的-同性交友-代码托管网站\" tabindex=\"-1\"> <s>Gayhub</s> GitHub 是世界上最大的 <s>同性交友</s> 代码托管网站</h2>\n<p>😋当然在上面交友也是极好的(这是重点，圈起来要考的😎)。</p>\n<h2 id=\"基本概念\" tabindex=\"-1\"> 基本概念</h2>\n<h3 id=\"repository\" tabindex=\"-1\"> Repository</h3>\n<p>仓库。一个仓库即是一个项目。仓库是 GitHub 上的主要内容。每当您新建一个项目并想要在 GitHub。</p>\n<h3 id=\"star\" tabindex=\"-1\"> Star</h3>\n<p>收藏。在每一个仓库主页的上方可以看到 star 按钮。其上的数值为收藏该项目的人数。点击星星即可将当前仓库收藏到您的账号上。您可以收藏一些您比较喜欢，或者项目对您来说有很大价值的项目。同时，点击数字可以看到哪些人收藏了这个项目。</p>\n<h3 id=\"fork\" tabindex=\"-1\"> Fork</h3>\n<p>复刻。在每一个仓库主页的上方可以看到 Fork 按钮。点击该按钮的作用是将当前项目复刻一份到自己的仓库中，这样，您就可以在此仓库仓库上查看当前、历史的版本，切换分支、或者是随心所欲的进行修改。原项目的新的推送、对历史版本的修改、甚至原作者删除了他的 repo，都不会对您 fork 的项目产生任何影响。</p>\n<h3 id=\"issue\" tabindex=\"-1\"> Issue</h3>\n<p>议题。你可将这里理解为 Bug 汇报区与新功能提交区。</p>\n<p>如果您在使用该项目的过程中遇到了问题，可以在相应项目的 Issue 板块按照项目的要求提出 Issue。在 Issue 中可以汇报一个 bug，或者是提出一个 Feature Request (功能请求)。项目的拥有者可以针对您汇报的情况对您做出回复。</p>\n<p>同时，项目拥有者还可以:</p>\n<ul>\n<li>为此 issue 增加 label (标签)，以帮助项目成员或是项目的其他使用者更好的理解这个 issue 的分类</li>\n<li>将此 issue assign (分派) 给特定的项目成员解决。</li>\n<li>将此 issue 加入特定的 project (项目) 以安排处理日期与进度。</li>\n</ul>\n<div><p>提示</p>\n<p>为了 GitHub 的友好交流环境，请在汇报 bug 时永远带上 bug 的一个简易的复现流程，可以直接建立一个简单的 reproduction repo 并把链接放置在您提出的 issue 中。</p>\n</div>\n<h3 id=\"dicussion\" tabindex=\"-1\"> Dicussion</h3>\n<p>GitHub 的讨论区，和 Issue 区主要用于 Bug 和 Feature Request 的追踪不同，通常情况下，你可以在讨论区开帖子询问使用中遇到的问题，以便其他人进行答复。你也可以在 Dicussion 区提供项目的看法与建议，比如对某个功能进行改进的方式以及相关理由。你也可以展示你自己使用项目的一些新的或是与项目相关的一些内容。</p>\n<h3 id=\"watch\" tabindex=\"-1\"> Watch</h3>\n<p>关注，在每一个仓库主页的上方可以看到 Watch 按钮。如果您关注了某个项目,那么这个项目有了变化的时候,您就会得到通知.在您点击关注后，您还可以点击下拉列表进一步设置关注级别。您可以选择接受 Release (新发布) 通知，也可以选择 Watching 来监听所有的通知。当您选择 Ignore 的话，即使有人在这个仓库中 metion (提到) 了您，您也不会得到通知。</p>\n<h3 id=\"review\" tabindex=\"-1\"> Review</h3>\n<p>审查。当项目收到 PR 时，项目的拥有成员可以对这份 PR 的代码改动进行审查，在 Review 的过程中，可以对代码的特定行或特定几行通过 comment(评论) 的方式来提出自己对代码改动的意见。</p>\n<h2 id=\"主页\" tabindex=\"-1\"> 主页</h2>\n<p><img src=\"@source/code/github/assets/mainPage.png\" alt=\"个人主页\"></p>\n<p><a href=\"https://github.com\" target=\"_blank\" rel=\"noopener noreferrer\">https://github.com</a></p>\n<p>主页，在您登陆后，屏幕的左侧会展示您和您加入团队的项目，以及您的团队详情。中部会显示您关注的项目、人的动态，右侧会根据算法展示一些您可能会感兴趣的 repo。</p>\n<h2 id=\"个人主页\" tabindex=\"-1\"> 个人主页</h2>\n<p><img src=\"@source/code/github/assets/profile.png\" alt=\"个人主页\"></p>\n<p><strong>地址:</strong> <code>https://github.com/&lt;您的用户名&gt;</code></p>\n<p>个人主页会有几个主要面板:</p>\n<h3 id=\"overview\" tabindex=\"-1\"> Overview</h3>\n<p>个人概览，您可以在上方 pin(固定) 最多六个您想要展示给他人的仓库。</p>\n<p>下方就是您过去一年里向 GitHub 的提交数量分布图，以及您在 GitHub 上的活动比例。</p>\n<p>最下方是近几年您在 GitHub 上的活动记录。</p>\n<h3 id=\"repositories\" tabindex=\"-1\"> Repositories</h3>\n<p><img src=\"@source/code/github/assets/personalRepo.png\" alt=\"个人仓库\"></p>\n<p>仓库列表，该面板会按照最后更新时间的倒序，展示该用户拥有的所有 reo，同时也会在面板上展示项目的 Descript(描述)、Star 数、Fork 数、语言、协议、标签，以及过去一年内项目的 commit 分布数量。这些都能够帮助浏览者在不进入具体仓库页面的情况下大致了解每一个仓库的内容、欢迎程度与维护情况。</p>\n<h3 id=\"projects\" tabindex=\"-1\"> Projects</h3>\n<p>个人拥有的项目，在管理自己与团队跨仓库的活动日程时很有用。可以设置涉及到的仓库，提出任务、代办、时间表等。</p>\n<h3 id=\"packages\" tabindex=\"-1\"> Packages</h3>\n<p>个人在 GitHub 上拥有的包。目前较少人在 GitHub 上发布相关的包。</p>\n<h3 id=\"stars\" tabindex=\"-1\"> Stars</h3>\n<p>和仓库列表完全相同，只不过展示该用户收藏的 repo。</p>\n<h3 id=\"followers-following\" tabindex=\"-1\"> Followers / Following</h3>\n<p>关注您的人 / 关注的人。在个人主页的左侧就有 follow 按钮，follow 一个人意味着这个人在 GitHub 的的活动会出现在 GitHub 主页的 Activity List 上。</p>\n<h2 id=\"仓库主页\" tabindex=\"-1\"> 仓库主页</h2>\n<p><img src=\"@source/code/github/assets/repo.png\" alt=\"仓库主页\"></p>\n<p>仓库主页主要显示项目的信息。从左到右的面板依次是: Code(代码)，Issues (问题)、Pull Requests (提交请求)、Actions (自动流程)、 Projects (项目)、 Wiki (项目介绍)、 Security (项目安全)、 Insights (项目数据统计) 与 Settings (项目设置)。</p>\n<p>在下方会展示代码文件以及项目说明 README.md 文件。</p>\n",
      "date_published": "2019-11-20T00:00:00.000Z",
      "date_modified": "2022-08-20T08:54:00.000Z",
      "authors": [],
      "tags": [
        "GitHub"
      ]
    },
    {
      "title": "GitHub Pages",
      "url": "https://github.com/MisterChen9527/code/github/pages.html",
      "id": "https://github.com/MisterChen9527/code/github/pages.html",
      "summary": "GitHub Pages 是静态站点托管服务，可直接从 GitHub 上的存储库中获取 HTML，CSS 和 JavaScript 文件，还可以选择在构建过程中运行这些文件并发布网站。\n您可以将站点托管在 GitHub 的 github.io 域名或您自己的自定义域名上。\n",
      "content_html": "<p>GitHub Pages 是静态站点托管服务，可直接从 GitHub 上的存储库中获取 HTML，CSS 和 JavaScript 文件，还可以选择在构建过程中运行这些文件并发布网站。</p>\n<p>您可以将站点托管在 GitHub 的 <code>github.io</code> 域名或您自己的自定义域名上。</p>\n\n<h2 id=\"简介\" tabindex=\"-1\"> 简介</h2>\n<p>GitHub Pages 站点共有三种类型: 项目，用户和组织。</p>\n<p>项目站点连接到 GitHub 上托管的特定项目，而用户和组织站点已连接到特定的 GitHub 帐户。</p>\n<ul>\n<li>要发布用户站点，您必须创建一个名为的用户帐户拥有的存储库 <code>&lt;username&gt;.github.io</code>。</li>\n<li>要发布组织站点，您必须创建一个名为的组织所拥有的存储库 <code>&lt;organization&gt;.github.io</code>。</li>\n</ul>\n<p>除非您使用自定义域名，否则用户站点和组织站点均位于 <code>http(s)://&lt;username&gt;.github.io</code> 或 <code>http(s)://&lt;organization&gt;.github.io</code>。</p>\n<p>项目站点的源文件与其项目存储在同一存储库中。除非您使用自定义域，否则项目站点可在 <code>http(s)://&lt;username&gt;.github.io/&lt;repository&gt;</code> 或 <code>http(s)://&lt;organization&gt;.github.io/&lt;repository&gt;</code> 访问。</p>\n<p>虽然您只能在 GitHub 上为每个帐户创建一个用户或组织站点。但无论是组织还是用户帐户拥有的项目站点都是无限的。</p>\n<h2 id=\"发布源文件到-github-pages\" tabindex=\"-1\"> 发布源文件到 GitHub Pages</h2>\n<div><p>警告</p>\n<p>GitHub Pages 站点 默认在互联网上公开，即使站点的仓库是私有的。</p>\n</div>\n<p>如果您的存储库中存在默认发布源，则 GitHub Pages 将自动从该源发布网站。用户和组织站点的默认发布源是存储库的默认分支的根目录。项目站点的默认发布源是 gh-pages 分支的根目录。</p>\n<p>您需要跳转到 Settings (设置) 选项卡，下来找到 GitHub Pages 的配置部分。</p>\n<div><p>提示</p>\n<p>您只能在根目录 (<code>/</code>) 和 文档目录 (<code>/docs</code>) 之间进行选择，而不能将仓库内的任意文件夹作为发布源。</p>\n</div>\n<h3 id=\"静态站点\" tabindex=\"-1\"> 静态站点</h3>\n<p>GitHub Pages 发布您推送到存储库的所有静态文件，这意味它不支持服务器端语言，例如 PHP，Ruby 或 Python。也就是您只能通过 GitHub Pages 发布 “无后端” 的纯静态站点。</p>\n<h3 id=\"限制\" tabindex=\"-1\"> 限制</h3>\n<ul>\n<li>\n<p>GitHub Pages 网站不得超过 1 GB。</p>\n</li>\n<li>\n<p>GitHub Pages 站点的带宽限制为每月 100GB。</p>\n</li>\n<li>\n<p>GitHub Pages 站点限制为每小时最多构建 10 次。</p>\n</li>\n</ul>\n<h3 id=\"子模块\" tabindex=\"-1\"> 子模块</h3>\n<p>如果 GitHub Pages 站点的仓库包含子模块，则在构建站点时会自动拉取其内容。</p>\n<p>只能使用指向公共仓库的子模块，因为 GitHub Pages 服务器无法访问私有仓库。</p>\n<p>对子模块 (包括嵌套子模块) 使用 <code>https://</code> 只读 URL。 您可以在 .gitmodules 文件中进行此更改。</p>\n<h2 id=\"取消发布\" tabindex=\"-1\"> 取消发布</h2>\n<h3 id=\"取消发布项目站点\" tabindex=\"-1\"> 取消发布项目站点</h3>\n<ol>\n<li>在 GitHub 上，导航到仓库的主页面。</li>\n<li>如果仓库中存在 gh-pages 分支，请删除 gh-pages 分支。</li>\n<li>在仓库名称下，单击 Settings (设置) 。</li>\n<li>在“ GitHub Pages”下，使用 Source (源) 下拉菜单并选择 None (无) 。</li>\n</ol>\n<h3 id=\"取消发布用户或组织站点\" tabindex=\"-1\"> 取消发布用户或组织站点</h3>\n<ol>\n<li>在 GitHub 上，导航到仓库的主页面。</li>\n<li>删除用作发布源的分支，或删除整个仓库。</li>\n</ol>\n<h2 id=\"自定义域名\" tabindex=\"-1\"> 自定义域名</h2>\n<p>您可以在对应仓库的 Settings (设置) 选项卡设置自定义域名，同时您需要将自定义域名的 CNAME 记录指向 <code>&lt;用户名&gt;.github.io</code>。</p>\n<div><p>提示</p>\n<p>自定义域名的控制是由发布源文件夹下的 CNAME 文件控制的，您可以直接创建这个文件写入链接。</p>\n<p>同时，GitHub Pages 要求这个文件一直存在，否则自定义域名会失效。</p>\n</div>\n",
      "date_published": "2021-02-20T00:00:00.000Z",
      "date_modified": "2022-08-20T08:54:00.000Z",
      "authors": [],
      "tags": [
        "GitHub"
      ]
    },
    {
      "title": "语义化提交",
      "url": "https://github.com/MisterChen9527/code/github/semantic.html",
      "id": "https://github.com/MisterChen9527/code/github/semantic.html",
      "content_html": "<h2 id=\"semantic\" tabindex=\"-1\"> Semantic</h2>\n<p>对于一个大型项目，几千个 commit 是很常见的，这些 commit 部分是项目维护者提交的 commit，部分是一些热心的开发者通过 PR 贡献的。</p>\n<p>无论是对于项目维护者，还是想要贡献代码的热心开发者来说，一个简洁明了的 commit 描述都是必不可少的。也就是说我们需要用尽可能简短的备注信息，备注每一个 commit 的作用，以便大家查看。所以我们需要一种规范的，语义化的备注格式，很快由知名项目牵头，全球接收并统一了一种语义化的备注格式，这就是 semantic 规范的来源。</p>\n<h2 id=\"优势\" tabindex=\"-1\"> 优势</h2>\n<p>当一个仓库所有的 commit 信息都是用标准的 semantic 格式时，用户可以很方便的理解每一个 commit 的作用。</p>\n<p>同时，senmantic 支持直接将某个提交或 PR 与特定 issue 链接，并自动关闭或引用这些 issue。</p>\n<p>通过一些第三方工具，大家可以基于这些备注信息进行过滤查找，更新日志生成等操作。</p>\n<h2 id=\"格式\" tabindex=\"-1\"> 格式</h2>\n<div><pre><code>&lt;type>(&lt;scope>): &lt;subject>\n&lt;body>\n\n&lt;footer>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div></div></div><h3 id=\"header\" tabindex=\"-1\"> header</h3>\n<p>第一行被称为 <code>header</code>，它必须只有一行，包括三个字段: <code>&lt;type&gt;</code>(必需)、<code>&lt;scope&gt;</code>(可选)和 <code>&lt;subject&gt;</code>(必需)</p>\n<h3 id=\"type\" tabindex=\"-1\"> type</h3>\n<p>commit 的类型。</p>\n<p>规范中规定了如下类型:</p>\n<ul>\n<li><code>feat</code>: feature, 新增功能</li>\n<li><code>fix</code> : bug fix, 修复 bug</li>\n<li><code>docs</code>: documentation, 仅仅修改了文档，如 <code>README.md</code></li>\n<li><code>style</code>: style, 仅仅是对格式进行修改，如逗号、缩进、空格等，不改变代码逻辑</li>\n<li><code>refactor</code>: refactor, 代码重构，一般更改了源文件或测试文件，但没有新增功能或修复 bug</li>\n<li><code>perf</code>: preformance, 优化相关，如提升性能、用户体验等</li>\n<li><code>test</code>: test, 测试用例，包括单元测试，集成测试</li>\n<li><code>chore</code>: chore, 对于库的其他内容的改变，一般不涉及到源文件或测试文件，比如更改 CI 设置，提升仓库以来等</li>\n<li><code>revert</code>: 版本回滚</li>\n</ul>\n<h3 id=\"scope\" tabindex=\"-1\"> scope</h3>\n<p>用于说明 commit 影响的范围，比如: <code>views</code> , <code>component</code>, <code>utils</code>, <code>test</code>。这个是由项目的内容与结构决定的。</p>\n<h3 id=\"subject\" tabindex=\"-1\"> subject</h3>\n<p>commit 目的的简短描述，最好小于 50 字符，一般不超过 65 个字符，最长不超过 80 字符。</p>\n<p>当 subject 限制的字符数无法详细说明此 commit 的变动时，将 commit 的具体变动放置在 body 中</p>\n<h3 id=\"body\" tabindex=\"-1\"> body</h3>\n<p>对本次 commit 修改内容的具体描述，可以分为多行。<code>body</code> 是可选的，而且 <code>body</code> 可以有多行。</p>\n<h3 id=\"footer\" tabindex=\"-1\"> footer</h3>\n<p>可选的，前面有一空行。可以添加一些备注，一般放置 <code>BREAKING CHANGE</code>(一些破坏性的变动) 或修复的 bug(涉及的 issue)的链接。</p>\n<h2 id=\"semantic-commit-与-changelog-生成\" tabindex=\"-1\"> Semantic commit 与 Changelog 生成</h2>\n<p>不同语言环境都有很多种工具来帮助您创建一个 semantic commit 或者自动生成 changelog。</p>\n<div><p>案例</p>\n<p>Node.js 环境下可以使用:</p>\n<ul>\n<li>\n<p><a href=\"https://github.com/commitizen/cz-conventional-changelog\" target=\"_blank\" rel=\"noopener noreferrer\"><code>cz-conventional-changelog</code></a> 提供 <code>git cz</code> 命令辅助创建 semantic commit。</p>\n</li>\n<li>\n<p><a href=\"https://github.com/conventional-changelog/conventional-changelog\" target=\"_blank\" rel=\"noopener noreferrer\"><code>conventional-changelog-cli</code></a> 来快速生成更新日志</p>\n</li>\n</ul>\n</div>\n",
      "date_published": "2022-08-20T08:54:00.000Z",
      "date_modified": "2022-08-20T08:54:00.000Z",
      "authors": [],
      "tags": [
        "GitHub"
      ]
    },
    {
      "title": "加速 GitHub 克隆",
      "url": "https://github.com/MisterChen9527/code/github/speedup.html",
      "id": "https://github.com/MisterChen9527/code/github/speedup.html",
      "content_html": "<p>由于天朝墙的存在，GitHub 的访问速度在大部分国内地区都很慢。如果需要克隆体积比较大的项目，可能需要很长时间，也很大概率会在中途因为网络波动、终端问题导致克隆失败。</p>\n<p>本文介绍如何使用 Gitee 加快 GitHub 项目克隆。</p>\n<h2 id=\"gitee\" tabindex=\"-1\"> Gitee</h2>\n<p>Gitee 又称码云，是一个国内的代码托管商，国内访问 Gitee 的速度是十分 Amazing 的。</p>\n<h3 id=\"注册\" tabindex=\"-1\"> 注册</h3>\n<p>Gitee 账户可以很方便的通过 GitHub 账户 + 绑定手机号注册。</p>\n<h3 id=\"添加公钥\" tabindex=\"-1\"> 添加公钥</h3>\n<p>完成注册后，您需要上传本地公钥，以保证可以从 Gitee 上拉取或克隆，其步骤与 GitHub 大致相同。</p>\n<h3 id=\"导入-github-仓库\" tabindex=\"-1\"> 导入 GitHub 仓库</h3>\n<p>码云的企业专线访问 GitHub 的速度很快，而码云在新建仓库的时候提供了导入选项，这就给我们的加速提供了方式。</p>\n<p>我们只需要在码云上新建仓库，选择导入，然后输入自己想要克隆的 GitHub 仓库地址，交给码云完成导入即可。</p>\n<p>稍等片刻后，码云即会将 GitHub 的仓库同步到自己的服务器上，此时我们只需要克隆码云上的这个仓库地址，就可以高速克隆这个项目。</p>\n<h3 id=\"远程库地址修改\" tabindex=\"-1\"> 远程库地址修改</h3>\n<p>在克隆完毕后，本地的 origin 远程库会默认为 Gitee 的仓库，此时我们需要使用 <code>git remote rename origin gitee</code> 命令，将码云的远程仓库重命名为 <code>gitee</code>，并使用 <code>git remote add origin &lt;github url&gt;</code> 命令重新添加 GitHub 的远程仓库为 origin。</p>\n<p>这样我们稍后在做出本地提交后，即可直接推送到 GitHub 仓库。</p>\n<h3 id=\"同步仓库\" tabindex=\"-1\"> 同步仓库</h3>\n<p>如果以导入的形式创建码云仓库。则可以随时点击仓库页面上的同步图标，让码云随时拉取最新的 gitee 代码，以便在本地通过 <code>git fetch gitee</code>，通过码云服务器高速拉取最新代码。</p>\n",
      "date_published": "2021-02-18T00:00:00.000Z",
      "date_modified": "2022-08-20T08:54:00.000Z",
      "authors": [],
      "tags": [
        "GitHub"
      ]
    },
    {
      "title": "GitHub Token",
      "url": "https://github.com/MisterChen9527/code/github/token.html",
      "id": "https://github.com/MisterChen9527/code/github/token.html",
      "summary": "Personal Access Token (PAT)，又称个人访问令牌，是一种代替密码进行 GitHub 身份认证的方式。\n",
      "content_html": "<p>Personal Access Token (PAT)，又称个人访问令牌，是一种代替密码进行 GitHub 身份认证的方式。</p>\n\n<h2 id=\"创建个人访问令牌\" tabindex=\"-1\"> 创建个人访问令牌</h2>\n<ol>\n<li>\n<p>访问 <a href=\"https://github.com/settings/tokens/new\" target=\"_blank\" rel=\"noopener noreferrer\">新建 Token 页面</a> (当然您需要先登陆 GitHub)</p>\n<blockquote>\n<p>或者可以点击头像 → Settings → Developer settings → Personal access tokens → Generate new Token</p>\n</blockquote>\n</li>\n<li>\n<p>输入一个备注，选择您需要授权 Token 访问的内容，之后点击页面底部的 &quot;Generate Token&quot;</p>\n</li>\n<li>\n<p>妥善保存该 Token (因为您无法再次查看它)</p>\n</li>\n</ol>\n<p>详见 <a href=\"https://docs.github.com/cn/github/authenticating-to-github/creating-a-personal-access-token\" target=\"_blank\" rel=\"noopener noreferrer\">创建个人访问令牌</a></p>\n",
      "date_published": "2022-08-20T08:54:00.000Z",
      "date_modified": "2022-08-20T08:54:00.000Z",
      "authors": [],
      "tags": [
        "GitHub"
      ]
    },
    {
      "title": "代码学习教程",
      "url": "https://github.com/MisterChen9527/code/language/",
      "id": "https://github.com/MisterChen9527/code/language/",
      "content_html": "<ul>\n<li><a href=\"/code/language/learning.html\">如何学习一门语言</a></li>\n</ul>\n<h2 id=\"教程目录\" tabindex=\"-1\"> 教程目录</h2>\n<ul>\n<li>\n<p><a href=\"/code/language/js/\">JavaScript 教程</a></p>\n</li>\n<li>\n<p><a href=\"/code/language/typescript/\">TypeScript 教程</a></p>\n</li>\n<li>\n<p><a href=\"/code/language/python/\">Python 教程</a> (编写中...)</p>\n</li>\n<li>\n<p><a href=\"https://www.liaoxuefeng.com/wiki/1252599548343744\" target=\"_blank\" rel=\"noopener noreferrer\">Java 教程</a>(廖雪峰的博客)</p>\n</li>\n<li>\n<p><a href=\"/code/language/markdown/\">Markdown 教程</a></p>\n</li>\n<li>\n<p><a href=\"/code/language/yaml/\">YAML 教程</a></p>\n</li>\n<li>\n<p><a href=\"/code/language/json/\">JSON 教程</a></p>\n</li>\n</ul>\n<h2 id=\"linter\" tabindex=\"-1\"> Linter</h2>\n<ul>\n<li><a href=\"/code/language/linter/\">Linter 介绍</a></li>\n</ul>\n<div><p>提示</p>\n<p>C 、C++、Java、PHP 正在编写中...</p>\n</div>\n",
      "date_published": "2022-08-20T08:54:00.000Z",
      "date_modified": "2022-08-20T08:54:00.000Z",
      "authors": [],
      "tags": [
        "教程"
      ]
    },
    {
      "title": "如何学习一门计算机语言",
      "url": "https://github.com/MisterChen9527/code/language/learning.html",
      "id": "https://github.com/MisterChen9527/code/language/learning.html",
      "content_html": "<h1 id=\"如何学习一门计算机语言\" tabindex=\"-1\"> 如何学习一门计算机语言</h1>\n<div><p>提示</p>\n<p>学习一门语言的基本顺序是:</p>\n<ul>\n<li>了解数据结构</li>\n<li>了解变量声明与赋值</li>\n<li>了解判断和循环体结构</li>\n<li>了解函数声明</li>\n<li>了解输入输出</li>\n</ul>\n<p>本部分将以 JS 作为示例，展示什么是一门计算机语言，应该如何学习它们。</p>\n</div>\n<h2 id=\"基础\" tabindex=\"-1\"> 基础</h2>\n<p>首先，任何语言都是由一些基本结构组成的，下面介绍几乎所有语言共有的一些概念:</p>\n<h3 id=\"语句\" tabindex=\"-1\"> 语句</h3>\n<p>语句可以简单理解为一个操作，它可以是赋值，也可以是执行，还可以是介于或者是可以归类到两者上的判断、声明、标记等。</p>\n<p>请注意一条语句通常是一个计算机语言描述的最小操作。</p>\n<p>比如:</p>\n<div><pre><code><span>let</span> a <span>=</span> <span>1</span><span>;</span> <span>// 赋值</span>\n<span>alert</span><span>(</span><span>\"Hello word\"</span><span>)</span><span>;</span> <span>// 调用函数 执行操作</span>\n<span>if</span> <span>(</span>a <span>></span> <span>2</span><span>)</span> <span>{</span>\n  <span>// 判断</span>\n<span>}</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div></div></div><h3 id=\"代码块\" tabindex=\"-1\"> 代码块</h3>\n<p>通常情况下，在有了语句概念后，我们就要使用不同的语句顺序，完成不同的操作，但是某些操作总是固定的。</p>\n<p>比如回家，总是 “掏出钥匙”-“插入钥匙”-“转动钥匙”-“开启房门”-“拔出钥匙”-“进入”-“关闭房门” 。</p>\n<p>这些步骤每一步都可以理解为一个语句，但是由于其顺序基本是固定的，我们就可以设计一个代码块，来约束它们。</p>\n<div><pre><code>{\n  “掏出钥匙”;\n  “插入钥匙”;\n  “转动钥匙”;\n  “开启房门”;\n  “拔出钥匙”;\n  “进入”;\n  “关闭房门”;\n}\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>大多数语言会使用 <code>{ }</code> 的形式，少数语言会使用统一的缩进进行表达。</p>\n<h2 id=\"数据结构\" tabindex=\"-1\"> 数据结构</h2>\n<p>计算机顾名思义就是可以做数学计算的机器，因此，计算机程序理所当然地可以处理各种数值。</p>\n<p>任何语言都是操作、计算(处理)、生成数据的。数据结构是一门语言存放数据的方式。不同的数据，需要定义不同的数据类型。了解了数据结构就了解了一门语言可以存储或处理何种数据。</p>\n<p>大多数语言都包含了以下的一种或多种内容:</p>\n<ul>\n<li>\n<p>数字:</p>\n<p>不同语言对数字有不同的处理方式，少数语言可能只有数字这一种类型，一些语言可能会拆分成整数与浮点数。一些底层语言(涉及到内存)可能会魔鬼的将数字拆分为: 整型、浮点数、无符号整型、长整型、无符号长整形、长浮点数。(说的就是您，C 语言)</p>\n</li>\n<li>\n<p>字符串:</p>\n<p>一些语言只有字符串这个概念，一些语言分为字符和字符串这个概念。</p>\n</li>\n<li>\n<p>布尔值:</p>\n<p>几乎所有语言都有布尔值，布尔值只有真和假两种类型。大多数会表示为 <code>true</code> 和 <code>false</code>，少数会表示为 <code>True</code> 和 <code>False</code>。</p>\n</li>\n<li>\n<p>数组:</p>\n<p>大部分语言都有数组 (Array) 这个概念，它是一个有序的元素集合。很多底层语言就是靠数组实现的字符串 (因为字符串长度不固定)。在数组中，每个元素具有标号，从 0 开始依次递增。</p>\n<p>一些语言还有 Set 这个概念，Set 表示的是无序元素集合，所有元素没有先后与标号的概念，自然 Set 也无法存入相同的元素。</p>\n</li>\n<li>\n<p>对象:</p>\n<p>大部分语言的对象 (Object) 都是由键值对组成的，它是一个由键标记的元素集合，可以使用特定的键名写入或读取其对应的值。</p>\n<p>一些产生较晚的语言，将对象改为 Map，Map 表达一个映射，将对应的键映射到对应的值上。</p>\n</li>\n<li>\n<p>类:</p>\n<p>类 (Class) 是一个内容集合，它包含了自己的构造器、变量与方法。类在声明后，可以很轻松的使用构造器创建一个新的实例。每个实例可以用其内部的变量维护或表达一个状态，并可以使用它自身的方法来读取或是改变自己的状态。不同的类之间还可以进行继承。</p>\n</li>\n</ul>\n<h2 id=\"变量\" tabindex=\"-1\"> 变量</h2>\n<p>一个<strong>变量</strong>是数据的“命名存储”。我们可以使用变量来保存商品、访客和其他信息。</p>\n<p>下面的语句创建(换句话说，<strong>声明</strong>或者<strong>定义</strong>)了一个名称为“message”的变量:</p>\n<div><pre><code><span>let</span> message<span>;</span>\n</code></pre><div aria-hidden=\"true\"><div></div></div></div><p>在有了变量之后，我们就可以将刚了解的数据结构赋值给变量，以变量来代替这些数据。</p>\n<div><pre><code><span>let</span> user <span>=</span> <span>\"John\"</span><span>;</span>\n<span>let</span> age <span>=</span> <span>25</span><span>;</span>\n<span>let</span> message <span>=</span> <span>\"Hello\"</span><span>;</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div></div></div><h2 id=\"条件\" tabindex=\"-1\"> 条件</h2>\n<p>条件运算符用于判断，通过判断一个条件的真假，来执行不同的逻辑。这是每一门语言逻辑结构的基础。</p>\n<div><pre><code><span>let</span> year <span>=</span> <span>2015</span><span>;</span>\n<span>if</span> <span>(</span>year <span>&lt;</span> <span>2015</span><span>)</span> <span>{</span>\n  <span>alert</span><span>(</span><span>\"Too early...\"</span><span>)</span><span>;</span>\n<span>}</span> <span>else</span> <span>if</span> <span>(</span>year <span>></span> <span>2015</span><span>)</span> <span>{</span>\n  <span>alert</span><span>(</span><span>\"Too late\"</span><span>)</span><span>;</span>\n<span>}</span> <span>else</span> <span>{</span>\n  <span>alert</span><span>(</span><span>\"Exactly!\"</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id=\"循环\" tabindex=\"-1\"> 循环</h2>\n<p>循环运算符的作用，是在条件控制下，零次或多次执行特定代码块。它使得重复执行成为了可能。</p>\n<div><pre><code><span>let</span> result <span>=</span> <span>0</span><span>;</span>\n<span>let</span> i <span>=</span> <span>1</span><span>;</span>\n\n<span>while</span> <span>(</span>i <span>&lt;=</span> <span>100</span><span>)</span> <span>{</span>\n  <span>// 计算1+2+3+...+100的结果</span>\n  i <span>=</span> i <span>+</span> <span>1</span><span>;</span>\n  result <span>=</span> result <span>+</span> i<span>;</span>\n<span>}</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><div><pre><code><span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>3</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>\n  <span>// 结果为 0、1、2</span>\n  <span>alert</span><span>(</span>i<span>)</span><span>;</span>\n<span>}</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div></div></div><h2 id=\"函数\" tabindex=\"-1\"> 函数</h2>\n<p>函数是程序的主要“构建模块”，</p>\n<p>创建函数时，需要声明函数内容，函数内容由一系列语句(代码块) 构成。在声明函数后，使用函数即可多次调用一段代码。</p>\n<p>例如:</p>\n<div><pre><code><span>function</span> <span>showMessage</span><span>(</span><span>)</span> <span>{</span>\n  <span>alert</span><span>(</span><span>\"Hello everyone!\"</span><span>)</span><span>;</span>\n<span>}</span> <span>// 声明一个函数</span>\n\n<span>showMessage</span><span>(</span><span>)</span><span>;</span> <span>// 调用它</span>\n<span>showMessage</span><span>(</span><span>)</span><span>;</span> <span>// 可以在任意时刻调用它</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>同时函数可以通过接受参数的形式来根据情况返回不同的结果，比如这是一个简单的求和函数。</p>\n<div><pre><code><span>function</span> <span>sum</span><span>(</span><span>sum1<span>,</span> sum2</span><span>)</span> <span>{</span>\n  <span>return</span> sum1 <span>+</span> sum2<span>;</span>\n<span>}</span>\n\n<span>sum</span><span>(</span><span>1</span><span>,</span> <span>2</span><span>)</span><span>;</span> <span>// return 3</span>\n<span>sum</span><span>(</span><span>5</span><span>,</span> <span>6</span><span>)</span><span>;</span> <span>// return 11</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div></div></div>",
      "date_published": "2022-08-20T08:54:00.000Z",
      "date_modified": "2022-08-20T08:54:00.000Z",
      "authors": [],
      "tags": [
        "教程"
      ]
    },
    {
      "title": "小程序",
      "url": "https://github.com/MisterChen9527/code/mini-app/",
      "id": "https://github.com/MisterChen9527/code/mini-app/",
      "summary": "提示\n在开发小程序之前。应当掌握 HTML、CSS、JavaScript 基础 以及 ES6。\n\n",
      "content_html": "<div><p>提示</p>\n<p>在开发小程序之前。应当掌握 <a href=\"/code/website/html/\">HTML</a>、<a href=\"/code/website/css/\">CSS</a>、<a href=\"/code/language/js/guide/\">JavaScript 基础</a> 以及 <a href=\"/code/language/js/es6/\">ES6</a>。</p>\n</div>\n\n<h2 id=\"小程序基础简介\" tabindex=\"-1\"> 小程序基础简介</h2>\n<p>在微信小程序中主要有四种文件结构: <code>wxml</code>、<code>wxss</code>、<code>js</code> 和 <code>json</code>。其中 <code>wxml</code> 对应带有 vue.js 特征的 html5，<code>wxss</code> 对应 css3，<code>js</code> 对应 ES6 标准的的 javaScript。</p>\n<p>对于 QQ 小程序，其文件结构为 <code>QML</code>、<code>qss</code>、<code>js</code> 和 <code>json</code>。</p>\n<div><p>提示</p>\n<p>QQ 小程序本质还是换汤不换药的，且 QQ 开发者工具兼容 <code>wxml</code> 与 <code>wss</code>)</p>\n</div>\n<p>小程序开发与网页开发极其相似。所以必须有适当的网页开发基础。零基础的人可能很难直接上手小程序开发。</p>\n<h2 id=\"教程目录\" tabindex=\"-1\"> 教程目录</h2>\n<ul>\n<li>\n<p><a href=\"/code/mini-app/guide/file-structure.html\">文件结构</a></p>\n</li>\n<li>\n<p><a href=\"/code/mini-app/guide/env.html\">运行环境</a></p>\n</li>\n<li>\n<p><a href=\"/code/mini-app/guide/config/\">小程序配置</a></p>\n<ul>\n<li>\n<p><a href=\"/code/mini-app/guide/config/app-config.html\">全局配置</a></p>\n</li>\n<li>\n<p><a href=\"/code/mini-app/guide/config/page-config.html\">页面配置</a></p>\n</li>\n<li>\n<p><a href=\"/code/mini-app/guide/config/sitemap-config.html\">sitemap 配置</a></p>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"/code/mini-app/guide/frame/\">小程序框架</a></p>\n<ul>\n<li>\n<p><a href=\"/code/mini-app/guide/frame/intro.html\">框架介绍</a></p>\n</li>\n<li>\n<p><a href=\"/code/mini-app/guide/frame/scene.html\">场景值</a> <i>Content not supported</i></p>\n</li>\n<li>\n<p><a href=\"/code/mini-app/guide/frame/env.html\">运行环境</a> <i>Content not supported</i></p>\n</li>\n<li>\n<p><a href=\"/code/mini-app/guide/frame/mechanism.html\">运行机制</a> <i>Content not supported</i></p>\n</li>\n<li>\n<p><a href=\"/code/mini-app/guide/frame/update.html\">更新机制</a> <i>Content not supported</i></p>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"/code/mini-app/guide/service/\">逻辑层</a></p>\n<ul>\n<li>\n<p><a href=\"/code/mini-app/guide/service/lifetime.html\">生命周期</a></p>\n</li>\n<li>\n<p><a href=\"/code/mini-app/guide/service/route.html\">路由</a></p>\n</li>\n<li>\n<p><a href=\"/code/mini-app/guide/service/register.html\">注册</a></p>\n</li>\n<li>\n<p><a href=\"/code/mini-app/guide/service/app.html\">App()</a></p>\n</li>\n<li>\n<p><a href=\"/code/mini-app/guide/service/page.html\">Page()</a></p>\n</li>\n<li>\n<p><a href=\"/code/mini-app/guide/service/run.html\">运行</a></p>\n</li>\n<li>\n<p><a href=\"/code/mini-app/guide/service/module.html\">模块化</a></p>\n</li>\n<li>\n<p><a href=\"/code/mini-app/guide/service/api/\">API</a></p>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"/code/mini-app/guide/view/\">视图层</a></p>\n<ul>\n<li>\n<p><a href=\"/code/mini-app/guide/view/wxml.html\">WXML</a></p>\n</li>\n<li>\n<p><a href=\"/code/mini-app/guide/view/wxss.html\">WXSS</a></p>\n</li>\n<li>\n<p><a href=\"/code/mini-app/guide/view/wxs.html\">WXS</a></p>\n</li>\n<li>\n<p><a href=\"/code/mini-app/guide/view/event.html\">事件</a></p>\n</li>\n<li>\n<p><a href=\"/code/mini-app/guide/view/component.html\">基础组件</a></p>\n</li>\n<li>\n<p><a href=\"/code/mini-app/guide/view/animation.html\">动画</a> <i>Content not supported</i></p>\n</li>\n<li>\n<p><a href=\"/code/mini-app/guide/view/wxs.html\">WXS</a> <i>Content not supported</i></p>\n</li>\n<li>\n<p><a href=\"/code/mini-app/guide/view/wxs-event.html\">WXS 事件</a> <i>Content not supported</i></p>\n</li>\n<li>\n<p><a href=\"/code/mini-app/guide/view/model.html\">建议双向绑定</a> <i>Content not supported</i></p>\n</li>\n<li>\n<p><a href=\"/code/mini-app/guide/view/selector.html\">获取界面上的节点信息</a> <i>Content not supported</i></p>\n</li>\n<li>\n<p><a href=\"/code/mini-app/guide/view/selector.html\">相应显示区域变化</a> <i>Content not supported</i></p>\n</li>\n<li>\n<p><a href=\"/code/mini-app/guide/view/rendering-cache.html\">初始渲染缓存</a> <i>Content not supported</i></p>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"/code/mini-app/guide/ability/\">小程序能力</a></p>\n<ul>\n<li>\n<p><a href=\"/code/mini-app/guide/ability/network.html\">网络请求</a></p>\n</li>\n<li>\n<p><a href=\"/code/mini-app/guide/ability/storage.html\">存储</a></p>\n</li>\n<li>\n<p><a href=\"/code/mini-app/guide/ability/file-system.html\">文件系统</a></p>\n</li>\n<li>\n<p><a href=\"/code/mini-app/guide/ability/debug.html\">调试</a></p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"开发者工具\" tabindex=\"-1\"> 开发者工具</h2>\n<ul>\n<li>\n<p><a href=\"/code/mini-app/tools/interface.html\">工具界面简介</a></p>\n</li>\n<li>\n<p><a href=\"/code/mini-app/tools/debug.html\">调试</a></p>\n</li>\n<li>\n<p><a href=\"/code/mini-app/tools/npm.html\">npm</a></p>\n</li>\n<li>\n<p><a href=\"/code/mini-app/tools/audit.html\">体验评分</a></p>\n</li>\n</ul>\n<h2 id=\"官方教程\" tabindex=\"-1\"> 官方教程</h2>\n<ul>\n<li><a href=\"https://developers.weixin.qq.com/ebook?action=get_post_info&amp;docid=0008aeea9a8978ab0086a685851c0a\" target=\"_blank\" rel=\"noopener noreferrer\">点击前往</a></li>\n</ul>\n<h2 id=\"案例\" tabindex=\"-1\"> 案例</h2>\n<ul>\n<li><a href=\"https://github.com/Hope-Studio/wxminiappdemo\" target=\"_blank\" rel=\"noopener noreferrer\">GitHub repository</a></li>\n</ul>\n<h2 id=\"mr-chen-框架说明\" tabindex=\"-1\"> Mr.Chen 框架说明</h2>\n<ul>\n<li>\n<p><a href=\"/code/mini-app/framework/\">小程序框架使用说明</a></p>\n</li>\n<li>\n<p><a href=\"/code/mini-app/framework/tag-list.html\">tag 值参数表</a></p>\n</li>\n<li>\n<p><a href=\"/code/mini-app/framework/page.html\">setPage 库使用说明</a></p>\n</li>\n<li>\n<p><a href=\"/code/mini-app/framework/simple-debug.html\">界面简单开发学习指南</a></p>\n</li>\n<li>\n<p><a href=\"/code/mini-app/qr-code.html\">分享相关</a></p>\n</li>\n</ul>\n<h2 id=\"学习视频\" tabindex=\"-1\"> 学习视频</h2>\n<ul>\n<li>\n<p><a href=\"https://www.bilibili.com/video/av22790583/\" target=\"_blank\" rel=\"noopener noreferrer\">零基础开发小程序</a>(比较新的视频，强调总体思想)</p>\n</li>\n<li>\n<p><a href=\"https://www.bilibili.com/video/av11938917\" target=\"_blank\" rel=\"noopener noreferrer\">小程序-从入门到入土</a>(比较老的视频，针对每个组件或者 API 进行了针对的讲解与示范，但部分内容已经与最新官方文档不符)</p>\n</li>\n</ul>\n<h2 id=\"示例代码\" tabindex=\"-1\"> 示例代码</h2>\n<ul>\n<li>\n<p><a href=\"https://github.com/wechat-miniprogram/miniprogram-demo\" target=\"_blank\" rel=\"noopener noreferrer\">小程序实例源码</a></p>\n<p><img src=\"https://res.wx.qq.com/wxdoc/dist/assets/img/demo.ef5c5bef.jpg\" alt=\"小程序示例二维码\"></p>\n</li>\n</ul>\n<h2 id=\"官方文档\" tabindex=\"-1\"> 官方文档</h2>\n<ul>\n<li><a href=\"https://q.qq.com/wiki/\" target=\"_blank\" rel=\"noopener noreferrer\">QQ 小程序</a></li>\n<li><a href=\"https://developers.weixin.qq.com/miniprogram/dev/framework/\" target=\"_blank\" rel=\"noopener noreferrer\">微信小程序</a></li>\n<li><a href=\"https://developers.weixin.qq.com/community/develop/question\" target=\"_blank\" rel=\"noopener noreferrer\">微信小程序社区</a>\n<ul>\n<li><a href=\"https://developers.weixin.qq.com/community/develop/list/2?id=\" target=\"_blank\" rel=\"noopener noreferrer\">官方公告</a></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"qq-开发者工具\" tabindex=\"-1\"> QQ 开发者工具</h3>\n<p>现在很多功能还处于缺失状态，bug 到没之前那么多了。</p>\n<ul>\n<li>\n<p><a href=\"https://q.qq.com/wiki/\" target=\"_blank\" rel=\"noopener noreferrer\">查看详情</a></p>\n</li>\n<li>\n<p><a href=\"https://q.qq.com/wiki/tools/devtool/\" target=\"_blank\" rel=\"noopener noreferrer\">下载地址</a></p>\n</li>\n</ul>\n<h2 id=\"微信开发者工具\" tabindex=\"-1\"> 微信开发者工具</h2>\n<p>微信开发者工具用来开发与调试微信小程序和微信相关网页的官方工具。小程序使用该开发工具进行开发。</p>\n<ul>\n<li>\n<p><a href=\"https://developers.weixin.qq.com/miniprogram/dev/devtools/download.html\" target=\"_blank\" rel=\"noopener noreferrer\">下载地址</a></p>\n</li>\n<li>\n<p><a href=\"/code/mini-app/tools/\">开发者工具教程</a></p>\n</li>\n<li>\n<p><a href=\"https://developers.weixin.qq.com/miniprogram/dev/devtools/devtools.html\" target=\"_blank\" rel=\"noopener noreferrer\">官方使用指南</a></p>\n</li>\n</ul>\n",
      "image": "https://res.wx.qq.com/wxdoc/dist/assets/img/demo.ef5c5bef.jpg",
      "date_published": "2019-11-25T00:00:00.000Z",
      "date_modified": "2022-08-20T08:54:00.000Z",
      "authors": [],
      "tags": [
        "小程序"
      ]
    },
    {
      "title": "小程序分享",
      "url": "https://github.com/MisterChen9527/code/mini-app/qr-code.html",
      "id": "https://github.com/MisterChen9527/code/mini-app/qr-code.html",
      "content_html": "<h2 id=\"二维码生成\" tabindex=\"-1\"> 二维码生成</h2>\n<p>目前小程序二维码生成选用的是<a href=\"https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/qr-code/wxacode.getUnlimited.html\" target=\"_blank\" rel=\"noopener noreferrer\">无限制生成二维码</a>。</p>\n<p>我们使用 Postman 软件进行二维码的获取。</p>\n<h3 id=\"调用凭据获取\" tabindex=\"-1\"> 调用凭据获取</h3>\n<p>获取任何二维码都需要先获取 <code>access_token</code>，这是小程序全局唯一后台接口调用凭据。<a href=\"https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/access-token/auth.getAccessToken.html\" target=\"_blank\" rel=\"noopener noreferrer\">文档地址</a></p>\n<p>请求方式为:</p>\n<div><pre><code>GET https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;appid=APPID&amp;secret=APPSECRET\n</code></pre><div aria-hidden=\"true\"><div></div></div></div><p>更多详情可以见文档。<code>AppSecret</code> 由于权限很大不在此文档中直接放置。</p>\n<h3 id=\"无限制二维码生成\" tabindex=\"-1\"> 无限制二维码生成</h3>\n<ul>\n<li><a href=\"https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/qr-code/wxacode.getUnlimited.html\" target=\"_blank\" rel=\"noopener noreferrer\">文档地址</a></li>\n</ul>\n<p>在获取 <code>access_token</code> 之后就可以获取小程序二维码了。</p>\n<div><pre><code>POST https://api.weixin.qq.com/wxa/getwxacodeunlimit?access_token=ACCESS_TOKEN\n</code></pre><div aria-hidden=\"true\"><div></div></div></div><p>请注意，在 Postman 软件中，首先要注意使用 <code>post</code> 方法。Body 使用 <code>raw</code>，格式选择 <code>Text</code>，需要将 <code>pretty</code> 化的 JSON 输入即可正常获取二维码。获取完二维码之后，需要在 <code>response</code> 中点击返回图片右上角的 <code>save as</code>，保存为 <code>jpg</code> 格式的文件即可保存二维码。</p>\n<h2 id=\"小程序链接\" tabindex=\"-1\"> 小程序链接</h2>\n<ul>\n<li><a href=\"https://developers.weixin.qq.com/doc/offiaccount/Message_Management/Service_Center_messages.html\" target=\"_blank\" rel=\"noopener noreferrer\">文档地址</a></li>\n</ul>\n<p>具体格式如下:</p>\n<div><pre><code><span><span><span>&lt;</span>a</span>\n  <span>href</span><span><span>=</span><span>\"</span>不支持小程序时打开的网页<span>\"</span></span>\n  <span>data-miniprogram-appid</span><span><span>=</span><span>\"</span>小程序的appid<span>\"</span></span>\n  <span>data-miniprogram-path</span><span><span>=</span><span>\"</span>小程序路径<span>\"</span></span>\n  <span>></span></span>文本内容<span><span><span>&lt;/</span>a</span>\n<span>></span></span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div></div></div>",
      "date_published": "2022-08-20T08:54:00.000Z",
      "date_modified": "2022-08-20T08:54:00.000Z",
      "authors": [],
      "tags": [
        "小程序"
      ]
    },
    {
      "title": "Node.js",
      "url": "https://github.com/MisterChen9527/code/node-js/",
      "id": "https://github.com/MisterChen9527/code/node-js/",
      "summary": "Node.js 是一款全球使用广泛的框架，可以用在前端与后端上，拥有大量的模块。Node.js 主要以其丰富并及其容易导入的 Node.js package，以及其方便管理 npm (Node.js Package Manager)闻名。\n",
      "content_html": "<p>Node.js 是一款全球使用广泛的框架，可以用在前端与后端上，拥有大量的模块。Node.js 主要以其丰富并及其容易导入的 Node.js package，以及其方便管理 npm (Node.js Package Manager)闻名。</p>\n\n<h2 id=\"教程目录\" tabindex=\"-1\"> 教程目录</h2>\n<ul>\n<li>\n<p><a href=\"/code/node-js/intro.html\">Node.js 介绍</a></p>\n</li>\n<li>\n<p><a href=\"/code/node-js/install.html\">Node.js 与 npm 安装</a></p>\n</li>\n<li>\n<p><a href=\"/code/node-js/environment.html\">Node.js 环境</a></p>\n</li>\n<li>\n<p><a href=\"/code/node-js/program.html\">编程</a></p>\n</li>\n<li>\n<p><a href=\"/code/node-js/cjs.html\">Node.js CJS 模块</a></p>\n</li>\n</ul>\n<p>以上，就是 Node.js 的简易介绍，系统学习可以查看下方的详细教程。</p>\n<h2 id=\"初学者教程\" tabindex=\"-1\"> 初学者教程</h2>\n<ul>\n<li>\n<p><a href=\"https://www.nodebeginner.org/index-zh-cn.html\" target=\"_blank\" rel=\"noopener noreferrer\">Node.js 入门</a></p>\n</li>\n<li>\n<p><a href=\"https://www.w3cschool.cn/nodejs/\" target=\"_blank\" rel=\"noopener noreferrer\">W3CSchool</a></p>\n</li>\n</ul>\n<h2 id=\"官方文档\" tabindex=\"-1\"> 官方文档</h2>\n<ul>\n<li><a href=\"https://nodejs.org/dist/latest-v14.x/docs/api/\" target=\"_blank\" rel=\"noopener noreferrer\">地址</a></li>\n</ul>\n<h2 id=\"yarn\" tabindex=\"-1\"> Yarn</h2>\n<p>快速、可靠、安全的依赖管理工具。</p>\n<ul>\n<li>\n<p>Yarn 缓存了每个下载过的包，所以再次使用时无需重复下载。同时利用并行下载以最大化资源利用率，因此安装速度更快。</p>\n</li>\n<li>\n<p>在执行代码之前，Yarn 会通过算法校验每个安装包的完整性。</p>\n</li>\n<li>\n<p>使用详细、简洁的锁文件格式和明确的安装算法，Yarn 能够保证在不同系统上无差异的工作。</p>\n</li>\n<li>\n<p><a href=\"https://www.yarnpkg.com/zh-Hans/docs/install#windows-stable\" target=\"_blank\" rel=\"noopener noreferrer\">下载地址</a></p>\n</li>\n<li>\n<p><a href=\"https://www.yarnpkg.com/zh-Hans/docs\" target=\"_blank\" rel=\"noopener noreferrer\">官方文档</a></p>\n</li>\n</ul>\n<h3 id=\"命令\" tabindex=\"-1\"> 命令</h3>\n<ul>\n<li>\n<p><code>yarn install</code>: 执行安装</p>\n</li>\n<li>\n<p><code>yarn upgrade</code>: 执行升级</p>\n</li>\n<li>\n<p><code>yarn add &lt;package&gt;</code>: 添加一个包</p>\n</li>\n<li>\n<p><code>yarn config set cache-folder &lt;path&gt;</code>: 更改缓存文件夹</p>\n</li>\n<li>\n<p><code>yarn config set registry &lt;registry&gt;</code>: 更改源</p>\n<div><p>提示</p>\n<p>在国内，建议换成淘宝源 <a href=\"https://registry.npm.taobao.org\" target=\"_blank\" rel=\"noopener noreferrer\">https://registry.npm.taobao.org</a></p>\n<p>即执行</p>\n<div><pre><code><span>yarn</span> config <span>set</span> registry https://registry.npm.taobao.org\n</code></pre><div aria-hidden=\"true\"><div></div></div></div></div>\n</li>\n</ul>\n",
      "date_published": "2022-08-20T08:54:00.000Z",
      "date_modified": "2022-08-20T08:54:00.000Z",
      "authors": [],
      "tags": [
        "Node.js"
      ]
    },
    {
      "title": "模块",
      "url": "https://github.com/MisterChen9527/code/node-js/cjs.html",
      "id": "https://github.com/MisterChen9527/code/node-js/cjs.html",
      "summary": "在计算机程序的开发过程中，随着程序代码越写越多，在一个文件里代码就会越来越长，越来越不容易维护。\n为了编写可维护的代码，我们把很多函数分组，分别放到不同的文件里，这样，每个文件包含的代码就相对较少，很多编程语言都采用这种组织代码的方式。在 Node.js 环境中，一个 .js 文件就称之为一个模块(module)。\n使用模块有什么好处?\n最大的好处是大大提高了代码的可维护性。其次，编写代码不必从零开始。当一个模块编写完毕，就可以被其他地方引用。我们在编写程序的时候，也经常引用其他模块，包括 Node.js 内置的模块和来自第三方的模块。\n使用模块还可以避免函数名和变量名冲突。相同名字的函数和变量完全可以分别存在不同的模块中，因此，我们自己在编写模块时，不必考虑名字会与其他模块冲突。\n",
      "content_html": "<p>在计算机程序的开发过程中，随着程序代码越写越多，在一个文件里代码就会越来越长，越来越不容易维护。</p>\n<p>为了编写可维护的代码，我们把很多函数分组，分别放到不同的文件里，这样，每个文件包含的代码就相对较少，很多编程语言都采用这种组织代码的方式。在 Node.js 环境中，一个 <code>.js</code> 文件就称之为一个模块(module)。</p>\n<p>使用模块有什么好处?</p>\n<p>最大的好处是大大提高了代码的可维护性。其次，编写代码不必从零开始。当一个模块编写完毕，就可以被其他地方引用。我们在编写程序的时候，也经常引用其他模块，包括 Node.js 内置的模块和来自第三方的模块。</p>\n<p>使用模块还可以避免函数名和变量名冲突。相同名字的函数和变量完全可以分别存在不同的模块中，因此，我们自己在编写模块时，不必考虑名字会与其他模块冲突。</p>\n\n<p>在上一节，我们编写了一个 hello.js 文件，这个 hello.js 文件就是一个模块，模块的名字就是文件名(去掉.js 后缀)，所以 hello.js 文件就是名为 hello 的模块。</p>\n<p>我们把 hello.js 改造一下，创建一个函数，这样我们就可以在其他地方调用这个函数:</p>\n<div><pre><code><span>\"use strict\"</span><span>;</span>\n\n<span>const</span> s <span>=</span> <span>\"Hello\"</span><span>;</span>\n\n<span>function</span> <span>greet</span><span>(</span><span>name</span><span>)</span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span>s <span>+</span> <span>\", \"</span> <span>+</span> name <span>+</span> <span>\"!\"</span><span>)</span><span>;</span>\n<span>}</span>\n\nmodule<span>.</span>exports <span>=</span> greet<span>;</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>函数 <code>greet()</code> 是我们在 hello 模块中定义的，您可能注意到最后一行是一个奇怪的赋值语句，它的意思是，把函数 <code>greet</code> 作为模块的输出暴露出去，这样其他模块就可以使用 <code>greet</code> 函数了。</p>\n<p>问题是其他模块怎么使用 hello 模块的这个 <code>greet</code> 函数呢? 我们再编写一个 <code>main.js</code> 文件，调用 <code>hello</code> 模块的 <code>greet</code> 函数:</p>\n<div><pre><code><span>\"use strict\"</span><span>;</span>\n\n<span>// 引入hello模块:</span>\n<span>const</span> greet <span>=</span> <span>require</span><span>(</span><span>\"./hello\"</span><span>)</span><span>;</span>\n\n<span>const</span> s <span>=</span> <span>\"Michael\"</span><span>;</span>\n\n<span>greet</span><span>(</span>s<span>)</span><span>;</span> <span>// Hello, Michael!</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>注意到引入 <code>hello</code> 模块用 Node.js 提供的 <code>require</code> 函数:</p>\n<div><pre><code><span>const</span> greet <span>=</span> <span>require</span><span>(</span><span>\"./hello\"</span><span>)</span><span>;</span>\n</code></pre><div aria-hidden=\"true\"><div></div></div></div><p>引入的模块作为变量保存在 <code>greet</code> 变量中，那 greet 变量到底是什么东西? 其实变量 <code>greet</code> 就是在 <code>hello.js</code> 中我们用 <code>module.exports = greet;</code> 输出的 <code>greet</code> 函数。所以，<code>main.js</code> 就成功地引用了 <code>hello.js</code> 模块中定义的 <code>greet()</code> 函数，接下来就可以直接使用它了。</p>\n<p>在使用 <code>require()</code> 引入模块的时候，请注意模块的相对路径。因为 main.js 和 hello.js 位于同一个目录，所以我们用了当前目录.:</p>\n<div><pre><code><span>const</span> greet <span>=</span> <span>require</span><span>(</span><span>\"./hello\"</span><span>)</span><span>;</span> <span>// 不要忘了写相对目录!</span>\n</code></pre><div aria-hidden=\"true\"><div></div></div></div><p>如果只写模块名:</p>\n<div><pre><code><span>const</span> greet <span>=</span> <span>require</span><span>(</span><span>\"hello\"</span><span>)</span><span>;</span>\n</code></pre><div aria-hidden=\"true\"><div></div></div></div><p>则 Node.js 会依次在内置模块、全局模块和当前模块下查找 hello.js，您很可能会得到一个错误:</p>\n<div><pre><code>module<span>.</span>js\n    <span>throw</span> err<span>;</span>\n          <span>^</span>\n<span>Error</span><span>:</span> Cannot find module <span>'hello'</span>\n    at Function<span>.</span>Module<span>.</span>_resolveFilename\n    at Function<span>.</span>Module<span>.</span>_load\n    <span>...</span>\n    at Function<span>.</span>Module<span>.</span>_load\n    at Function<span>.</span>Module<span>.</span>runMain\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>遇到这个错误，您要检查:</p>\n<ul>\n<li>模块名是否写对了；</li>\n<li>模块文件是否存在；</li>\n<li>相对路径是否写对了。</li>\n</ul>\n<h2 id=\"commonjs-规范\" tabindex=\"-1\"> CommonJS 规范</h2>\n<p>这种模块加载机制被称为 <code>CommonJS</code> 规范。在这个规范下，每个 <code>.js</code> 文件都是一个模块，它们内部各自使用的变量名和函数名都互不冲突，例如，<code>hello.js</code> 和 <code>main.js</code> 都申明了全局变量 <code>const s = 'xxx'</code>，但互不影响。</p>\n<p>一个模块想要对外暴露变量(函数也是变量)，可以用 <code>module.exports = variable;</code>，一个模块要引用其他模块暴露的变量，用 <code>const ref = require('module_name');</code> 就拿到了引用模块的变量。</p>\n<h2 id=\"总结\" tabindex=\"-1\"> 总结</h2>\n<p>要在模块中对外输出变量，用:</p>\n<div><pre><code>module<span>.</span>exports <span>=</span> variable<span>;</span>\n</code></pre><div aria-hidden=\"true\"><div></div></div></div><p>输出的变量可以是任意对象、函数、数组等等。</p>\n<p>要引入其他模块输出的对象，用:</p>\n<div><pre><code><span>const</span> foo <span>=</span> <span>require</span><span>(</span><span>\"other_module\"</span><span>)</span><span>;</span>\n</code></pre><div aria-hidden=\"true\"><div></div></div></div><p>引入的对象具体是什么，取决于引入模块输出的对象。</p>\n<h2 id=\"深入了解模块原理\" tabindex=\"-1\"> 深入了解模块原理</h2>\n<p>如果您想详细地了解<strong>CommonJS</strong>的模块实现原理，请继续往下阅读。如果不想了解，请结束阅读。</p>\n<p>当我们编写 JavaScript 代码时，我们可以申明全局变量:</p>\n<div><pre><code><span>const</span> s <span>=</span> <span>\"global\"</span><span>;</span>\n</code></pre><div aria-hidden=\"true\"><div></div></div></div><p>在浏览器中，大量使用全局变量可不好。如果您在 <code>a.js</code> 中使用了全局变量 s，那么，在 <code>b.js</code> 中也使用全局变量 s，将造成冲突，<code>b.js</code> 中对 s 赋值会改变 <code>a.js</code> 的运行逻辑。</p>\n<p>也就是说，JavaScript 语言本身并没有一种模块机制来保证不同模块可以使用相同的变量名。</p>\n<p>那 Node.js 是如何实现这一点的?</p>\n<p>其实要实现“模块”这个功能，并不需要语法层面的支持。Node.js 也并不会增加任何 JavaScript 语法。实现“模块”功能的奥妙就在于 JavaScript 是一种函数式编程语言，它支持闭包。如果我们把一段 JavaScript 代码用一个函数包装起来，这段代码的所有“全局”变量就变成了函数内部的局部变量。</p>\n<p>请注意我们编写的 <code>hello.js</code> 代码是这样的:</p>\n<div><pre><code><span>const</span> s <span>=</span> <span>\"Hello\"</span><span>;</span>\n<span>const</span> name <span>=</span> <span>\"world\"</span><span>;</span>\n\nconsole<span>.</span><span>log</span><span>(</span>s <span>+</span> <span>\" \"</span> <span>+</span> name <span>+</span> <span>\"!\"</span><span>)</span><span>;</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div></div></div><p>Node.js 加载了 hello.js 后，它可以把代码包装一下，变成这样执行:</p>\n<div><pre><code><span>(</span><span>function</span> <span>(</span><span>)</span> <span>{</span>\n  <span>// 读取的hello.js代码:</span>\n  <span>const</span> s <span>=</span> <span>\"Hello\"</span><span>;</span>\n  <span>const</span> name <span>=</span> <span>\"world\"</span><span>;</span>\n\n  console<span>.</span><span>log</span><span>(</span>s <span>+</span> <span>\" \"</span> <span>+</span> name <span>+</span> <span>\"!\"</span><span>)</span><span>;</span>\n  <span>// hello.js代码结束</span>\n<span>}</span><span>)</span><span>(</span><span>)</span><span>;</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>这样一来，原来的全局变量 <code>s</code> 现在变成了匿名函数内部的局部变量。如果 Node.js 继续加载其他模块，这些模块中定义的“全局”变量 <code>s</code> 也互不干扰。</p>\n<p>所以，Node.js 利用 JavaScript 的函数式编程的特性，轻而易举地实现了模块的隔离。</p>\n<p>但是，模块的输出 <code>module.exports</code> 怎么实现?</p>\n<p>这个也很容易实现，Node.js 可以先准备一个对象 <code>module</code>:</p>\n<div><pre><code><span>// 准备module对象:</span>\n<span>const</span> module <span>=</span> <span>{</span>\n  <span>id</span><span>:</span> <span>\"hello\"</span><span>,</span>\n  <span>exports</span><span>:</span> <span>{</span><span>}</span><span>,</span>\n<span>}</span><span>;</span>\n<span>const</span> <span>load</span> <span>=</span> <span>function</span> <span>(</span><span>module</span><span>)</span> <span>{</span>\n  <span>// 读取的hello.js代码:</span>\n  <span>function</span> <span>greet</span><span>(</span><span>name</span><span>)</span> <span>{</span>\n    console<span>.</span><span>log</span><span>(</span><span>\"Hello, \"</span> <span>+</span> name <span>+</span> <span>\"!\"</span><span>)</span><span>;</span>\n  <span>}</span>\n\n  module<span>.</span>exports <span>=</span> greet<span>;</span>\n  <span>// hello.js代码结束</span>\n  <span>return</span> module<span>.</span>exports<span>;</span>\n<span>}</span><span>;</span>\n<span>const</span> exported <span>=</span> <span>load</span><span>(</span>module<span>)</span><span>;</span>\n<span>// 保存module:</span>\n<span>save</span><span>(</span>module<span>,</span> exported<span>)</span><span>;</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>可见，变量 module 是 Node.js 在加载 js 文件前准备的一个变量，并将其传入加载函数，我们在 <code>hello.js</code> 中可以直接使用变量 <code>module</code> 原因就在于它实际上是函数的一个参数:</p>\n<div><pre><code>module<span>.</span>exports <span>=</span> greet<span>;</span>\n</code></pre><div aria-hidden=\"true\"><div></div></div></div><p>通过把参数 <code>module</code> 传递给 <code>load()</code> 函数，<code>hello.js</code> 就顺利地把一个变量传递给了 Node.js 执行环境，Node.js 会把 module 变量保存到某个地方。</p>\n<p>由于 Node.js 保存了所有导入的 module，当我们用 <code>require()</code> 获取 module 时，Node.js 找到对应的 module，把这个 module 的 <code>exports</code> 变量返回，这样，另一个模块就顺利拿到了模块的输出:</p>\n<div><pre><code><span>const</span> greet <span>=</span> <span>require</span><span>(</span><span>\"./hello\"</span><span>)</span><span>;</span>\n</code></pre><div aria-hidden=\"true\"><div></div></div></div><p>以上是 Node.js 实现 JavaScript 模块的一个简单的原理介绍。</p>\n<h2 id=\"module-exports-vs-exports\" tabindex=\"-1\"> module.exports vs exports</h2>\n<p>很多时候，您会看到，在 Node.js 环境中，有两种方法可以在一个模块中输出变量:</p>\n<p>方法一: 对 module.exports 赋值:</p>\n<div><pre><code><span>// hello.js</span>\n\n<span>function</span> <span>hello</span><span>(</span><span>)</span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span><span>\"Hello, world!\"</span><span>)</span><span>;</span>\n<span>}</span>\n\n<span>function</span> <span>greet</span><span>(</span><span>name</span><span>)</span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span><span>\"Hello, \"</span> <span>+</span> name <span>+</span> <span>\"!\"</span><span>)</span><span>;</span>\n<span>}</span>\n\nmodule<span>.</span>exports <span>=</span> <span>{</span>\n  <span>hello</span><span>:</span> hello<span>,</span>\n  <span>greet</span><span>:</span> greet<span>,</span>\n<span>}</span><span>;</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>方法二: 直接使用 exports:</p>\n<div><pre><code><span>// hello.js</span>\n\n<span>function</span> <span>hello</span><span>(</span><span>)</span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span><span>\"Hello, world!\"</span><span>)</span><span>;</span>\n<span>}</span>\n\n<span>function</span> <span>greet</span><span>(</span><span>name</span><span>)</span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span><span>\"Hello, \"</span> <span>+</span> name <span>+</span> <span>\"!\"</span><span>)</span><span>;</span>\n<span>}</span>\n\n<span>function</span> <span>hello</span><span>(</span><span>)</span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span><span>\"Hello, world!\"</span><span>)</span><span>;</span>\n<span>}</span>\n\nexports<span>.</span>hello <span>=</span> hello<span>;</span>\nexports<span>.</span>greet <span>=</span> greet<span>;</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>但是您不可以直接对 exports 赋值:</p>\n<div><pre><code><span>// 代码可以执行，但是模块并没有输出任何变量:</span>\nexports <span>=</span> <span>{</span>\n  <span>hello</span><span>:</span> hello<span>,</span>\n  <span>greet</span><span>:</span> greet<span>,</span>\n<span>}</span><span>;</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div></div></div><p>如果您对上面的写法感到十分困惑，不要着急，我们来分析 Node.js 的加载机制:</p>\n<p>首先，Node.js 会把整个待加载的 hello.js 文件放入一个包装函数 load 中执行。在执行这个 load()函数前，Node.js 准备好了 module 变量:</p>\n<div><pre><code><span>const</span> module <span>=</span> <span>{</span>\n  <span>id</span><span>:</span> <span>\"hello\"</span><span>,</span>\n  <span>exports</span><span>:</span> <span>{</span><span>}</span><span>,</span>\n<span>}</span><span>;</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div></div></div><p><code>load()</code> 函数最终返回 <code>module.exports</code>:</p>\n<div><pre><code><span>const</span> <span>load</span> <span>=</span> <span>function</span> <span>(</span><span>exports<span>,</span> module</span><span>)</span> <span>{</span>\n    <span>// hello.js的文件内容</span>\n    <span>...</span>\n    <span>// load函数返回:</span>\n    <span>return</span> module<span>.</span>exports<span>;</span>\n<span>}</span><span>;</span>\n\n<span>const</span> exported <span>=</span> <span>load</span><span>(</span>module<span>.</span>exports<span>,</span> module<span>)</span><span>;</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>也就是说，默认情况下，Node.js 准备的 <code>exports</code> 变量和 <code>module.exports</code> 变量实际上是同一个变量，并且初始化为空对象 <code>{}</code>，于是，我们可以写:</p>\n<div><pre><code>exports<span>.</span><span>foo</span> <span>=</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>\n  <span>return</span> <span>\"foo\"</span><span>;</span>\n<span>}</span><span>;</span>\nexports<span>.</span><span>bar</span> <span>=</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>\n  <span>return</span> <span>\"bar\"</span><span>;</span>\n<span>}</span><span>;</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>也可以写:</p>\n<div><pre><code>module<span>.</span>exports<span>.</span><span>foo</span> <span>=</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>\n  <span>return</span> <span>\"foo\"</span><span>;</span>\n<span>}</span><span>;</span>\nmodule<span>.</span>exports<span>.</span><span>bar</span> <span>=</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>\n  <span>return</span> <span>\"bar\"</span><span>;</span>\n<span>}</span><span>;</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>换句话说，Node.js 默认给您准备了一个空对象 <code>{}</code>，这样您可以直接往里面加东西。</p>\n<p>但是，如果我们要输出的是一个函数或数组，那么，只能给 <code>module.exports</code> 赋值:</p>\n<div><pre><code>module<span>.</span><span>exports</span> <span>=</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>\n  <span>return</span> <span>\"foo\"</span><span>;</span>\n<span>}</span><span>;</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div></div></div><p>给 <code>exports</code> 赋值是无效的，因为赋值后，<code>module.exports</code> 仍然是空对象 <code>{}</code>。</p>\n<h2 id=\"结论\" tabindex=\"-1\"> 结论</h2>\n<p>如果要输出一个键值对象 <code>{}</code>，可以利用 <code>exports</code> 这个已存在的空对象 <code>{}</code>，并继续在上面添加新的键值；</p>\n<p>如果要输出一个函数或数组，必须直接对 <code>module.exports</code> 对象赋值。</p>\n<p>所以我们可以得出结论: 直接对 <code>module.export</code>s 赋值，可以应对任何情况:</p>\n<div><pre><code>module<span>.</span>exports <span>=</span> <span>{</span>\n  <span>foo</span><span>:</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>\n    <span>return</span> <span>\"foo\"</span><span>;</span>\n  <span>}</span><span>,</span>\n<span>}</span><span>;</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div></div></div><p>或者:</p>\n<div><pre><code>module<span>.</span><span>exports</span> <span>=</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>\n  <span>return</span> <span>\"foo\"</span><span>;</span>\n<span>}</span><span>;</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div></div></div><p>最终，我们强烈建议使用 <code>module.exports = xxx</code> 的方式来输出模块变量，这样，您只需要记忆一种方法。</p>\n",
      "date_published": "2022-08-20T08:54:00.000Z",
      "date_modified": "2022-08-20T08:54:00.000Z",
      "authors": [],
      "tags": [
        "Node.js"
      ]
    },
    {
      "title": "搭建 Node 开发环境",
      "url": "https://github.com/MisterChen9527/code/node-js/environment.html",
      "id": "https://github.com/MisterChen9527/code/node-js/environment.html",
      "summary": "由于 Node.js 需要编码、运行、调试，我们需要一个 IDE 集成开发环境，这样就可以大大提升开发效率。综合考察后，Mr.Chen 隆重向大家推荐 Node.js 集成开发环境: Visual Studio Code。它启动速度快，执行简单，调试方便这三点上。当然，免费使用是一个加分项。\n",
      "content_html": "<p>由于 Node.js 需要编码、运行、调试，我们需要一个 IDE 集成开发环境，这样就可以大大提升开发效率。综合考察后，Mr.Chen 隆重向大家推荐 Node.js 集成开发环境: <strong>Visual Studio Code</strong>。它启动速度快，执行简单，调试方便这三点上。当然，免费使用是一个加分项。</p>\n\n<div><p>相关信息</p>\n<p>有关 VS Code 使用教程请<a href=\"/software/vscode/\">访问这里</a></p>\n</div>\n<h2 id=\"运行和调试-javascript\" tabindex=\"-1\"> 运行和调试 JavaScript</h2>\n<p>在 VS Code 中，我们可以非常方便地运行 JavaScript 文件。</p>\n<p>VS Code 以文件夹作为工程目录 (Workspace Dir)，所有的 JavaScript 文件都存放在该目录下。此外，VS Code 在工程目录下还需要一个 <code>.vscode</code> 的配置目录，里面存放里 VS Code 需要的配置文件。</p>\n<p>假设我们在 <code>C:\\Work\\</code> 目录下创建了一个 hello 目录作为工程目录，并编写了一个 <code>hello.js</code> 文件，则该工程目录的结构如下:</p>\n<div><pre><code>hello/ &lt;-- workspace dir\n|\n├─ hello.js &lt;-- JavaScript file\n|\n└─ .vscode/ &lt;-- VS Code config\n      |\n      └ launch.json &lt;-- VS Code config file for JavaScript\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>可以用 VS Code 快速创建 <code>launch.json</code>，然后修改如下:</p>\n<div><pre><code><span>{</span>\n  <span>\"version\"</span><span>:</span> <span>\"0.2.0\"</span><span>,</span>\n  <span>\"configurations\"</span><span>:</span> <span>[</span>\n    <span>{</span>\n      <span>\"name\"</span><span>:</span> <span>\"Run hello.js\"</span><span>,</span>\n      <span>\"type\"</span><span>:</span> <span>\"node\"</span><span>,</span>\n      <span>\"request\"</span><span>:</span> <span>\"launch\"</span><span>,</span>\n      <span>\"program\"</span><span>:</span> <span>\"${workspaceRoot}/hello.js\"</span><span>,</span>\n      <span>\"stopOnEntry\"</span><span>:</span> <span>false</span><span>,</span>\n      <span>\"args\"</span><span>:</span> <span>[</span><span>]</span><span>,</span>\n      <span>\"cwd\"</span><span>:</span> <span>\"${workspaceRoot}\"</span><span>,</span>\n      <span>\"preLaunchTask\"</span><span>:</span> <span>null</span><span>,</span>\n      <span>\"runtimeExecutable\"</span><span>:</span> <span>null</span><span>,</span>\n      <span>\"runtimeArgs\"</span><span>:</span> <span>[</span><span>\"--nolazy\"</span><span>]</span><span>,</span>\n      <span>\"env\"</span><span>:</span> <span>{</span>\n        <span>\"NODE_ENV\"</span><span>:</span> <span>\"development\"</span>\n      <span>}</span><span>,</span>\n      <span>\"externalConsole\"</span><span>:</span> <span>false</span><span>,</span>\n      <span>\"sourceMaps\"</span><span>:</span> <span>false</span><span>,</span>\n      <span>\"outDir\"</span><span>:</span> <span>null</span>\n    <span>}</span>\n  <span>]</span>\n<span>}</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>有了配置文件，即可使用 VS Code 调试 JavaScript。</p>\n<h2 id=\"视频演示\" tabindex=\"-1\"> 视频演示</h2>\n<ul>\n<li><a href=\"https://www.bilibili.com/video/av5827351/\" target=\"_blank\" rel=\"noopener noreferrer\">视频演示</a></li>\n</ul>\n",
      "date_published": "2022-08-20T08:54:00.000Z",
      "date_modified": "2022-08-20T08:54:00.000Z",
      "authors": [],
      "tags": [
        "Node.js"
      ]
    },
    {
      "title": "安装 Node.js",
      "url": "https://github.com/MisterChen9527/code/node-js/install.html",
      "id": "https://github.com/MisterChen9527/code/node-js/install.html",
      "summary": "由于 Node.js 平台是在后端运行 JavaScript 代码，所以，必须首先在本机安装 Node.js 环境。\n",
      "content_html": "<p>由于 Node.js 平台是在后端运行 JavaScript 代码，所以，必须首先在本机安装 Node.js 环境。</p>\n\n<h2 id=\"安装-node-js\" tabindex=\"-1\"> 安装 Node.js</h2>\n<p>目前 Node.js 的 LTS 版本是 16.15.1。首先，从 Node.js 官网下载对应平台的安装程序。点击 LTS 版本的下载按钮。</p>\n<ul>\n<li><a href=\"https://nodejs.org/zh-cn/\" target=\"_blank\" rel=\"noopener noreferrer\">Node.js 官网</a></li>\n</ul>\n<h3 id=\"安装过程\" tabindex=\"-1\"> 安装过程</h3>\n<ul>\n<li>\n<p>在 Windows 上安装时务必选择全部组件，包括勾选 <code>Add to Path</code>。</p>\n<p>在安装过程中，无需勾选 &quot;Automatically install the necessary tools&quot;。选中此项会在电脑中安装 VS 等日常开发使用不到的软件。</p>\n<p>安装完成后，在 Windows 环境下，请打开命令提示符，然后输入 <code>node -v</code> ，如果安装正常，您应该看到 <code>v16.15.1</code> 这样的输出:</p>\n<div><pre><code>C:<span>\\</span>Users<span>\\</span>IEUser<span>></span>node -v\nv16.15.1\n</code></pre><div aria-hidden=\"true\"><div></div><div></div></div></div><p>继续在命令提示符输入 node，此刻您将进入 Node.js 的交互环境。在交互环境下，您可以输入任意 JavaScript 语句，例如 <code>100 + 200</code>，回车后将得到输出结果。</p>\n<p>要退出 Node.js 环境，连按两次 <code>Ctrl + C</code> 。</p>\n</li>\n<li>\n<p>在 Mac 或 Linux 环境下，请打开终端，然后输入 <code>node -v</code>，您应该看到如下输出:</p>\n<div><pre><code>$ <span>node</span> -v\nv16.15.1\n</code></pre><div aria-hidden=\"true\"><div></div><div></div></div></div></li>\n</ul>\n<h2 id=\"npm\" tabindex=\"-1\"> npm</h2>\n<p>npm 是 Node.js 的包管理工具(package manager)。</p>\n<p>我们在 Node.js 上开发时，会用到很多别人写的 JavaScript 代码。如果我们要使用别人写的某个包，每次都根据名称搜索一下官方网站，下载代码，解压，再使用，非常繁琐。于是一个集中管理的工具应运而生: 大家都把自己开发的模块打包后放到 npm 官网上，如果要使用，直接通过 npm 安装就可以直接用，不用管代码存在哪，应该从哪下载。</p>\n<p>更重要的是，如果我们要使用模块 A，而模块 A 又依赖于模块 B，模块 B 又依赖于模块 X 和模块 Y，npm 可以根据依赖关系，把所有依赖的包都下载下来并管理起来。否则，靠我们自己手动管理，肯定既麻烦又容易出错。</p>\n<p>讲了这么多，npm 究竟在哪?</p>\n<p>其实 npm 已经在 Node.js 安装的时候顺带装好了。我们在命令提示符或者终端输入 <code>npm -v</code>，应该看到类似的输出:</p>\n<div><pre><code>C:<span>\\</span><span>></span>npm -v\n<span>8.12</span>.1\n</code></pre><div aria-hidden=\"true\"><div></div><div></div></div></div><blockquote>\n<p>如果版本号太小，说明 npm 版本较低，请使用此命令升级到最新版本: <code>npm i -g npm</code>。</p>\n</blockquote>\n<p>如果直接输入 <code>npm</code>，您会看到类似下面的输出:</p>\n<div><pre><code>C:<span>\\</span><span>></span> <span>npm</span>\n<span>npm</span> <span>&lt;</span>command<span>></span>\n\nUsage:\n\n<span>npm</span> <span>install</span>        <span>install</span> all the dependencies <span>in</span> your project\n<span>npm</span> <span>install</span> <span>&lt;</span>foo<span>></span>  <span>add</span> the <span>&lt;</span>foo<span>></span> dependency to your project\n    <span>..</span>.\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面的一大堆文字告诉您，npm 需要附带命令。现在我们不用关心这些命令，后面会一一讲到。目前，您只需要确保 npm 正确安装了，能运行就行。</p>\n<h2 id=\"国内镜像站\" tabindex=\"-1\"> 国内镜像站</h2>\n<p>大家都知道天朝是有墙的，有的时候，访问国外的 Node.js 服务器可能会十分缓慢以至于您想把它砸了。</p>\n<p>所以贴心的马云爸爸提供了淘宝镜像源。你可以将 npm 的源配置为国内镜像源，以在每次安装依赖的时候从国内镜像站拉取镜像。这可以极大的提升安装速度。</p>\n<div><p>注</p>\n<p>如果官方源的速度还可以的话请尽可能使用官方源。</p>\n<p>国内源毕竟是镜像站点，同步官方源的包会出现延迟，所以有时候你可能会遇到 <code>version xxx not found</code> 之类的错误，这是因为所需要的版本还没来得及被镜像站点同步所导致。</p>\n<p>你可以通过访问 <code>npmmirror.com/sync/&lt;包名&gt;</code> 来手动同步一个包。</p>\n</div>\n<p>设置及国内源的命令如下:</p>\n<div><pre><code><span>npm</span> config <span>set</span> registry https://registry.npmmirror.com/\n</code></pre><div aria-hidden=\"true\"><div></div></div></div><div><p>注意</p>\n<p><code>https://registry.npm.taobao.org/</code> 是老的淘宝源地址，现已停止维护，请不要使用!!!</p>\n</div>\n<h2 id=\"启用-corepack\" tabindex=\"-1\"> 启用 Corepack</h2>\n<p>Node.js 自带的包管理工具 npm 并不是那么的强大，其安装速度也很慢，所以社区开发了一些其他的包管理工具如 <code>yarn</code> 和 <code>pnpm</code>，它们有自己的优势。</p>\n<p>Mr.Chen 推荐使用 pnpm 进行包管理，因为它使用硬链接索引包文件，安装速度更快而且节省磁盘空间。</p>\n<p>从 v16 开始，Node.js 引入了 Corepack 工具，并在 package.json 支持了 <code>packageManager</code> 选项以支持第三方管理工具。</p>\n<p>你需要通过下方命令启用 Corepack:</p>\n<div><pre><code>corepack <span>enable</span>\n</code></pre><div aria-hidden=\"true\"><div></div></div></div><p>这样每个项目会自动应用根目录 package.json 中的 <code>packageManager</code> 选项。比如设置 <code>&quot;packageManager&quot;: &quot;pnpm@7.2.1&quot;</code> 的时候，会自动下载并使用 <code>pnpm@7.2.1</code>。</p>\n<div><p>设置全局的 packageManager</p>\n<p>你可以使用 <code>corepack prepare packageManager@semver</code> 来全局准备一个 packageManager 版本，并使用 <code>--activate</code> 选新娘 全局激活。</p>\n<p>比如以下命令下载 <code>pnpm@7.2.1</code> 并将其作为默认的全局包管理器:</p>\n<div><pre><code>corepack prepare pnpm@7.2.1 --activate\n</code></pre><div aria-hidden=\"true\"><div></div></div></div></div>\n<h2 id=\"小结\" tabindex=\"-1\"> 小结</h2>\n<p>请在本机安装 Node.js 环境，并确保 Node.js 和 npm 能正常运行。</p>\n",
      "date_published": "2022-08-20T08:54:00.000Z",
      "date_modified": "2022-08-20T08:54:00.000Z",
      "authors": [],
      "tags": [
        "Node.js"
      ]
    },
    {
      "title": "Node.js",
      "url": "https://github.com/MisterChen9527/code/node-js/intro.html",
      "id": "https://github.com/MisterChen9527/code/node-js/intro.html",
      "summary": "从本章开始，我们就正式开启 JavaScript 的后端开发之旅。\nNode.js 是目前非常火热的技术，但是它的诞生经历却很奇特。\n",
      "content_html": "<p>从本章开始，我们就正式开启 JavaScript 的后端开发之旅。</p>\n<p>Node.js 是目前非常火热的技术，但是它的诞生经历却很奇特。</p>\n\n<p>众所周知，在 Netscape 设计出 JavaScript 后的短短几个月，JavaScript 事实上已经是前端开发的唯一标准。</p>\n<p>后来，微软通过 IE 击败了 Netscape 后一统桌面，结果几年时间，浏览器毫无进步。(2001 年推出的古老的 IE 6 到今天仍然有人在使用! )</p>\n<p>没有竞争就没有发展。微软认为 IE6 浏览器已经非常完善，几乎没有可改进之处，然后解散了 IE6 开发团队! 而 Google 却认为支持现代 Web 应用的新一代浏览器才刚刚起步，尤其是浏览器负责运行 JavaScript 的引擎性能还可提升 10 倍。</p>\n<p>先是 Mozilla 借助已壮烈牺牲的 Netscape 遗产在 2002 年推出了 Firefox 浏览器，紧接着 Apple 于 2003 年在开源的 KHTML 浏览器的基础上推出了 WebKit 内核的 Safari 浏览器，不过仅限于 Mac 平台。</p>\n<p>随后，Google 也开始创建自家的浏览器。他们也看中了 WebKit 内核，于是基于 WebKit 内核推出了 Chrome 浏览器。</p>\n<p>Chrome 浏览器是跨 Windows 和 Mac 平台的，并且，Google 认为要运行现代 Web 应用，浏览器必须有一个性能非常强劲的 JavaScript 引擎，于是 Google 自己开发了一个高性能 JavaScript 引擎，名字叫 V8，以 BSD 许可证开源。</p>\n<p>现代浏览器大战让微软的 IE 浏览器远远地落后了，因为他们解散了最有经验、战斗力最强的浏览器团队! 回过头再追赶却发现，支持 HTML5 的 WebKit 已经成为手机端的标准了，IE 浏览器从此与主流移动端设备绝缘。</p>\n<h2 id=\"浏览器大战和-node-js-的关系\" tabindex=\"-1\"> 浏览器大战和 Node.js 的关系</h2>\n<p>话说有个叫 Ryan Dahl 的歪果仁，他的工作是用 C/C++写高性能 Web 服务。对于高性能，异步 IO、事件驱动是基本原则，但是用 C/C++写就太痛苦了。于是这位仁兄开始设想用高级语言开发 Web 服务。他评估了很多种高级语言，发现很多语言虽然同时提供了同步 IO 和异步 IO，但是开发人员一旦用了同步 IO，他们就再也懒得写异步 IO 了，所以，最终，Ryan 瞄向了 JavaScript。</p>\n<p>因为 JavaScript 是单线程执行，根本不能进行同步 IO 操作，所以，JavaScript 的这一“缺陷”导致了它只能使用异步 IO。</p>\n<p>选定了开发语言，还要有运行时引擎。这位仁兄曾考虑过自己写一个，不过明智地放弃了，因为 V8 就是开源的 JavaScript 引擎。让 Google 投资去优化 V8，咱只负责改造一下拿来用，还不用付钱，这个买卖很划算。</p>\n<p>于是在 2009 年，Ryan 正式推出了基于 JavaScript 语言和 V8 引擎的开源 Web 服务器项目，命名为 Node.js。虽然名字很土，但是，Node.js 第一次把 JavaScript 带入到后端服务器开发，加上世界上已经有无数的 JavaScript 开发人员，所以 Node.js 一下子就火了起来。</p>\n<h2 id=\"在-node-js-上运行的-javascript-相比其他后端开发语言的优势\" tabindex=\"-1\"> 在 Node.js 上运行的 JavaScript 相比其他后端开发语言的优势</h2>\n<p>最大的优势是借助 JavaScript 天生的事件驱动机制加 V8 高性能引擎，使编写高性能 Web 服务轻而易举。</p>\n<p>其次，JavaScript 语言本身是完善的函数式语言，在前端开发时，开发人员往往写得比较随意，让人感觉 JavaScript 就是个“玩具语言”。但是，在 Node.js 环境下，通过模块化的 JavaScript 代码，加上函数式编程，并且无需考虑浏览器兼容性问题，直接使用最新的 ECMAScript 6 标准，可以完全满足工程上的需求。</p>\n<blockquote>\n<p>我还听说过 io.js，这又是什么鬼?</p>\n</blockquote>\n<p>因为 Node.js 是开源项目，虽然由社区推动，但幕后一直由 Joyent 公司资助。由于一群开发者对 Joyent 公司的策略不满，于 2014 年从 Node.js 项目 fork 出了 io.js 项目，决定单独发展，但两者实际上是兼容的。</p>\n<p>然而中国有句古话，叫做“分久必合，合久必分”。分家后没多久，Joyent 公司表示要和解，于是，io.js 项目又决定回归 Node.js。</p>\n<p>具体做法是将来 io.js 将首先添加新的特性，如果大家测试用得爽，就把新特性加入 Node.js。Io.js 是“尝鲜版”，而 Node.js 是线上稳定版，相当于 Fedora Linux 和 RHEL 的关系。</p>\n<p>本章教程的所有代码都在 Node.js 上调试通过。如果您要尝试 io.js 也是可以的，不过两者如果遇到一些区别请自行查看 io.js 的文档。</p>\n<h2 id=\"node-js-相关链接\" tabindex=\"-1\"> Node.js 相关链接</h2>\n<ul>\n<li>\n<p><a href=\"https://nodejs.org/zh-cn/\" target=\"_blank\" rel=\"noopener noreferrer\">Node.js 官网</a></p>\n</li>\n<li>\n<p><a href=\"https://nodejs.org/zh-cn/docs/\" target=\"_blank\" rel=\"noopener noreferrer\">Node.js 最新文档</a></p>\n</li>\n<li>\n<p><a href=\"https://nodejs.org/dist/latest-v16.x/docs/api/\" target=\"_blank\" rel=\"noopener noreferrer\">Node.js 最新 API 文档</a></p>\n</li>\n</ul>\n",
      "date_published": "2022-08-20T08:54:00.000Z",
      "date_modified": "2022-08-20T08:54:00.000Z",
      "authors": [],
      "tags": [
        "Node.js"
      ]
    },
    {
      "title": "第一个 Node 程序",
      "url": "https://github.com/MisterChen9527/code/node-js/program.html",
      "id": "https://github.com/MisterChen9527/code/node-js/program.html",
      "summary": "在前面的所有章节中，我们编写的 JavaScript 代码都是在浏览器中运行的，因此，我们可以直接在浏览器中敲代码，然后直接运行。\n从本章开始，我们编写的 JavaScript 代码将不能在浏览器环境中执行了，而是在 Node.js 环境中执行，因此，JavaScript 代码将直接在您的计算机上以命令行的方式运行，所以，我们要先选择一个文本编辑器来编写 JavaScript 代码，并且把它保存到本地硬盘的某个目录，才能够执行。\n",
      "content_html": "<p>在前面的所有章节中，我们编写的 JavaScript 代码都是在浏览器中运行的，因此，我们可以直接在浏览器中敲代码，然后直接运行。</p>\n<p>从本章开始，我们编写的 JavaScript 代码将不能在浏览器环境中执行了，而是在 Node.js 环境中执行，因此，JavaScript 代码将直接在您的计算机上以命令行的方式运行，所以，我们要先选择一个文本编辑器来编写 JavaScript 代码，并且把它保存到本地硬盘的某个目录，才能够执行。</p>\n\n<p>那么问题来了: 文本编辑器到底哪家强?</p>\n<div><p>注意</p>\n<p>千万不要使用 Windows 自带的记事本编辑任何文本文件。</p>\n<ul>\n<li>具体详情请见 <a href=\"/code/windows/notepad.html\">记事本遗留问题</a></li>\n</ul>\n</div>\n<p>如果您的电脑上已经安装了<strong>Sublime Text</strong>，或者<strong>Notepad++</strong>，也可以用来编写 JavaScript 代码，注意用 UTF-8 格式保存。</p>\n<p>最方便的，当然是 Mr.Chen 强力安利的 VS Code 了。</p>\n<p>输入以下代码:</p>\n<div><pre><code><span>\"use strict\"</span><span>;</span>\n\nconsole<span>.</span><span>log</span><span>(</span><span>\"Hello, world.\"</span><span>)</span><span>;</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div></div></div><p>第一行总是写上 <code>'use strict';</code> 是因为我们总是以严格模式运行 JavaScript 代码，避免各种潜在陷阱。</p>\n<p>然后，选择一个目录，例如 <code>C:\\Workspace</code>，把文件保存为 <code>hello.js</code>，就可以打开命令行窗口，把当前目录切换到 hello.js 所在目录，然后输入以下命令运行这个程序了:</p>\n<div><pre><code>C:<span>\\</span>Workspace<span>></span>node hello.js\nHello, world.\n</code></pre><div aria-hidden=\"true\"><div></div><div></div></div></div><p>也可以保存为别的名字，比如 <code>first.js</code>，但是必须要以 <code>.js</code> 结尾。此外，文件名只能是英文字母、数字和下划线的组合。</p>\n<p>如果当前目录下没有 <code>hello.js</code> 这个文件，运行 <code>node hello.js</code> 就会报错:</p>\n<div><pre><code>C:<span>\\</span>Workspace<span>></span>node hello.js\nmodule.js:338\n    throw err<span>;</span>\n          ^\nError: Cannot <span>find</span> module <span>'C:\\Workspace\\hello.js'</span>\n    at Function.Module._resolveFilename\n    at Function.Module._load\n    at Function.Module.runMain\n    at startup\n    at node.js\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>报错的意思就是，没有找到 <code>hello.js</code> 这个文件，因为文件不存在。这个时候，就要检查一下当前目录下是否有这个文件了。</p>\n<h2 id=\"命令行模式和-node-js-交互模式\" tabindex=\"-1\"> 命令行模式和 Node.js 交互模式</h2>\n<p>请注意区分命令行模式和 Node.js 交互模式。</p>\n<p>看到类似 <code>C:\\&gt;</code> 是在 Windows 提供的命令行模式:</p>\n<p><img src=\"@source/code/node-js/assets/run-node-hello.png\" alt=\"run-node-hello\"></p>\n<p>在命令行模式下，可以执行 Node.js 进入 Node.js 交互式环境，也可以执行 Node.js <code>hello.js</code> 运行一个 <code>.js</code> 文件。</p>\n<p>看到<code>&gt;</code> 是在 Node.js 交互式环境下:</p>\n<p><img src=\"@source/code/node-js/assets/node-interactive-env.png\" alt=\"node-interactive-env\"></p>\n<p>在 Node.js 交互式环境下，我们可以输入 JavaScript 代码并立刻执行。</p>\n<p>此外，在命令行模式运行.js 文件和在 Node.js 交互式环境下直接运行 JavaScript 代码有所不同。Node.js 交互式环境会把每一行 JavaScript 代码的结果自动打印出来，但是，直接运行 JavaScript 文件却不会。</p>\n<p>例如，在 Node.js 交互式环境下，输入:</p>\n<div><pre><code><span>></span> <span>100</span> + <span>200</span> + <span>300</span><span>;</span>\n<span>600</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div></div></div><p>直接可以看到结果 600。</p>\n<p>但是，写一个 <code>calc.js</code> 的文件，内容如下:</p>\n<div><pre><code><span>100</span> <span>+</span> <span>200</span> <span>+</span> <span>300</span><span>;</span>\n</code></pre><div aria-hidden=\"true\"><div></div></div></div><p>然后在命令行模式下执行:</p>\n<div><pre><code>C:<span>\\</span>Workspace<span>></span>node calc.js\n</code></pre><div aria-hidden=\"true\"><div></div></div></div><p>发现什么输出都没有。</p>\n<p>这是正常的。想要输出结果，必须自己用 <code>console.log()</code> 打印出来。把 <code>calc.js</code> 改造一下:</p>\n<div><pre><code>console<span>.</span><span>log</span><span>(</span><span>100</span> <span>+</span> <span>200</span> <span>+</span> <span>300</span><span>)</span><span>;</span>\n</code></pre><div aria-hidden=\"true\"><div></div></div></div><p>再执行，就可以看到结果:</p>\n<div><pre><code>C:<span>\\</span>Workspace<span>></span>node calc.js\n<span>600</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div></div></div><h2 id=\"使用严格模式\" tabindex=\"-1\"> 使用严格模式</h2>\n<p>如果在 JavaScript 文件开头写上 <code>'use strict';</code>，那么 Node.js 在执行该 JavaScript 时将使用严格模式。但是，在服务器环境下，如果有很多 JavaScript 文件，每个文件都写上 <code>'use strict';</code> 很麻烦。我们可以给 Node.js 传递一个参数，让 Node.js 直接为所有 js 文件开启严格模式:</p>\n<div><pre><code><span>node</span> --use_strict calc.js\n</code></pre><div aria-hidden=\"true\"><div></div></div></div><p>后续代码，如无特殊说明，我们都会直接给 Node.js 传递 <code>--use_strict</code> 参数来开启严格模式。</p>\n<h2 id=\"小结\" tabindex=\"-1\"> 小结</h2>\n<p>用文本编辑器写 JavaScript 程序，然后保存为后缀为 <code>.js</code> 的文件，就可以用 Node.js 直接运行这个程序了。</p>\n<p>Node.js 的交互模式和直接运行 <code>.js</code> 文件有什么区别呢?</p>\n<p>直接输入 Node.js 进入交互模式，相当于启动了 Node.js 解释器，但是等待您一行一行地输入源代码，每输入一行就执行一行。</p>\n<p>直接运行 <code>node hello.js</code> 文件相当于启动了 Node.js 解释器，然后一次性把 <code>hello.js</code> 文件的源代码给执行了，您是没有机会以交互的方式输入源代码的。</p>\n<p>在编写 JavaScript 代码的时候，完全可以一边在文本编辑器里写代码，一边开一个 Node.js 交互式命令窗口，在写代码的过程中，把部分代码粘到命令行去验证，事半功倍! 前提是得有个 27 寸的超大显示器!</p>\n",
      "date_published": "2022-08-20T08:54:00.000Z",
      "date_modified": "2022-08-20T08:54:00.000Z",
      "authors": [],
      "tags": [
        "Node.js"
      ]
    },
    {
      "title": "React",
      "url": "https://github.com/MisterChen9527/code/react/",
      "id": "https://github.com/MisterChen9527/code/react/",
      "content_html": "<h2 id=\"创建-react-项目\" tabindex=\"-1\"> 创建 React 项目</h2>\n<p>使用 <code>create-react-app</code> 工具。</p>\n<p>创建普通模板:</p>\n<div><pre><code>npx create-react-app xxx\n</code></pre><div aria-hidden=\"true\"><div></div></div></div><p>创建 TS 模板:</p>\n<div><pre><code>npx create-react-app xxx --template typescript\n</code></pre><div aria-hidden=\"true\"><div></div></div></div><h2 id=\"react-文档\" tabindex=\"-1\"> React 文档</h2>\n<ul>\n<li><a href=\"https://reactjs.org/docs/getting-started.html\" target=\"_blank\" rel=\"noopener noreferrer\">官方文档</a></li>\n<li><a href=\"https://react.docschina.org/docs/getting-started.html\" target=\"_blank\" rel=\"noopener noreferrer\">中文文档</a></li>\n</ul>\n",
      "date_published": "2020-05-08T00:00:00.000Z",
      "date_modified": "2022-08-20T08:54:00.000Z",
      "authors": [],
      "tags": [
        "前端"
      ]
    },
    {
      "title": "Vue.js",
      "url": "https://github.com/MisterChen9527/code/vue/",
      "id": "https://github.com/MisterChen9527/code/vue/",
      "content_html": "<p>Vue.js 是世界上主流的前端框架。</p>\n<p>官方介绍为：渐近式 JavaScript 框架。一款用于构建 Web 界面，易学易用，性能出色且功能丰富的框架。</p>\n<h2 id=\"vue-js-教程目录\" tabindex=\"-1\"> Vue.js 教程目录</h2>\n<ul>\n<li>\n<p><a href=\"/code/vue/install.html\">开发环境安装</a></p>\n</li>\n<li>\n<p><a href=\"/code/vue/get-started.html\">起步上手</a></p>\n</li>\n<li>\n<p><a href=\"/code/vue/vue.html\">Vue 单文件组件说明</a></p>\n</li>\n</ul>\n<h2 id=\"vue-生态\" tabindex=\"-1\"> Vue 生态</h2>\n<h3 id=\"vue-router\" tabindex=\"-1\"> Vue Router</h3>\n<ul>\n<li>\n<p><a href=\"/code/vue/router/\">Vue Router 讲解</a></p>\n</li>\n<li>\n<p><a href=\"/code/vue/router/demo.html\">Vue Router Demo</a></p>\n</li>\n</ul>\n<h3 id=\"vuex\" tabindex=\"-1\"> Vuex</h3>\n<ul>\n<li>\n<p><a href=\"/code/vue/vuex/\">Vuex 讲解</a></p>\n</li>\n<li>\n<p><a href=\"/code/vue/vuex/demo.html\">Vuex Demo</a></p>\n</li>\n</ul>\n<h3 id=\"vue-cli\" tabindex=\"-1\"> Vue Cli</h3>\n<ul>\n<li>\n<p><a href=\"/code/vue/cli/intro.html\">Vue Cli 介绍</a></p>\n</li>\n<li>\n<p><a href=\"/code/vue/cli/quick-dev.html\">使用 Vue Cli 进行快速开发</a></p>\n</li>\n<li>\n<p><a href=\"/code/vue/cli/file.html\">Vue Cli 文件处理</a></p>\n</li>\n</ul>\n<h3 id=\"其他-vue-生态\" tabindex=\"-1\"> 其他 Vue 生态</h3>\n<ul>\n<li><a href=\"https://vuepress-theme-hope.github.io/basic/vuepress/\" target=\"_blank\" rel=\"noopener noreferrer\">VuePress</a>: 静态站点生成器；</li>\n<li><a href=\"https://vue.ant.design/docs/vue/introduce-cn/\" target=\"_blank\" rel=\"noopener noreferrer\">Ant Design Vue</a>: 阿里的一套 UI 组件库；</li>\n<li><a href=\"https://bootstrap-vue.js.org/\" target=\"_blank\" rel=\"noopener noreferrer\">BootstrapVue</a></li>\n</ul>\n<h2 id=\"官方文档\" tabindex=\"-1\"> 官方文档</h2>\n<ul>\n<li>\n<p><a href=\"https://cn.vuejs.org/v2/guide/\" target=\"_blank\" rel=\"noopener noreferrer\">Vue.js 介绍</a></p>\n</li>\n<li>\n<p><a href=\"https://cn.vuejs.org/v2/api/\" target=\"_blank\" rel=\"noopener noreferrer\">Vue.js API</a></p>\n</li>\n</ul>\n<hr>\n<ul>\n<li>\n<p><a href=\"https://cli.vuejs.org/zh/guide/cli-service.html\" target=\"_blank\" rel=\"noopener noreferrer\">Vue CLI 3 介绍</a></p>\n</li>\n<li>\n<p><a href=\"https://cli.vuejs.org/zh/config/\" target=\"_blank\" rel=\"noopener noreferrer\">Vue CLI 3 配置</a></p>\n</li>\n</ul>\n<hr>\n<ul>\n<li>\n<p><a href=\"https://router.vuejs.org/zh/guide/#html\" target=\"_blank\" rel=\"noopener noreferrer\">Vue Router 介绍</a></p>\n</li>\n<li>\n<p><a href=\"https://cli.vuejs.org/zh/config/\" target=\"_blank\" rel=\"noopener noreferrer\">Vue Router 配置</a></p>\n</li>\n</ul>\n<hr>\n<ul>\n<li>\n<p><a href=\"https://vuex.vuejs.org/zh/\" target=\"_blank\" rel=\"noopener noreferrer\">Vuex 介绍</a></p>\n</li>\n<li>\n<p><a href=\"https://vuex.vuejs.org/zh/api/\" target=\"_blank\" rel=\"noopener noreferrer\">Vuex 配置</a></p>\n</li>\n</ul>\n<h2 id=\"其他文档\" tabindex=\"-1\"> 其他文档</h2>\n<ul>\n<li>\n<p><a href=\"/code/vue/component.html\">各组件使用说明</a></p>\n</li>\n<li>\n<p><a href=\"/code/vue/compare.html\">Vue 与小程序的异同</a></p>\n</li>\n<li>\n<p>VueConf 视频</p>\n<ul>\n<li>\n<p><a href=\"https://www.yuque.com/vueconf/2019/qg1yms\" target=\"_blank\" rel=\"noopener noreferrer\">Vue Beyond Vue Loader</a></p>\n</li>\n<li>\n<p><a href=\"https://www.yuque.com/vueconf/2019/gwn1z0\" target=\"_blank\" rel=\"noopener noreferrer\">尤雨溪演讲视频</a></p>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"https://mrhope.site/file/vue/VueConf2019SH_Evan.pdf\" target=\"_blank\" rel=\"noopener noreferrer\">尤雨溪演讲 PPT</a></p>\n</li>\n<li>\n<p><a href=\"https://mrhope.site/file/vue/intro-to-vuepres-1.x.pdf\" target=\"_blank\" rel=\"noopener noreferrer\">VuePress 介绍</a></p>\n</li>\n<li>\n<p><a href=\"https://mrhope.site/file/vue/Vue%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95.pdf\" target=\"_blank\" rel=\"noopener noreferrer\">Vue 单元测试</a></p>\n</li>\n<li>\n<p><a href=\"https://mrhope.site/file/vue/%E4%BD%BF%E7%94%A8Vue%E5%AE%9E%E7%8E%B00%E4%BB%A3%E7%A0%81%E4%BA%A4%E4%BA%92-winter.pdf\" target=\"_blank\" rel=\"noopener noreferrer\">使用 Vue 实现 0 代码交互</a></p>\n</li>\n<li>\n<p><a href=\"https://mrhope.site/file/vue/Vue%20%E5%BC%80%E5%8F%91%20ECharts%20%E8%B8%A9%E5%9D%91%E6%8C%87%E5%8D%97.pdf\" target=\"_blank\" rel=\"noopener noreferrer\">Echart 与 Vue</a></p>\n</li>\n<li>\n<p><a href=\"https://mrhope.site/file/vue/Vue%20Beyond%20Vue%20Loader.pdf\" target=\"_blank\" rel=\"noopener noreferrer\">Vue Loader</a></p>\n</li>\n<li>\n<p><a href=\"https://mrhope.site/file/vue/Mars%E6%A1%86%E6%9E%B6%E5%88%86%E4%BA%AB-vueconf.pdf\" target=\"_blank\" rel=\"noopener noreferrer\">基于 Vue 的多端框架</a></p>\n</li>\n</ul>\n",
      "date_published": "2022-08-20T08:54:00.000Z",
      "date_modified": "2022-08-20T08:54:00.000Z",
      "authors": [],
      "tags": [
        "基础"
      ]
    },
    {
      "title": "Vue 与小程序的异同",
      "url": "https://github.com/MisterChen9527/code/vue/compare.html",
      "id": "https://github.com/MisterChen9527/code/vue/compare.html",
      "summary": "Vue-cli 提供的 vue 单文件语法与小程序基本相似，甚至可以说小程序是改变自 Vue 与 React 框架的。\n",
      "content_html": "<p>Vue-cli 提供的 vue 单文件语法与小程序基本相似，甚至可以说小程序是改变自 Vue 与 React 框架的。</p>\n\n<h2 id=\"优缺点比较\" tabindex=\"-1\"> 优缺点比较</h2>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>优点</th>\n<th>缺点</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>小程序</td>\n<td>小程序底层由微信框架驱动，每个界面是单独的 JS 文件，页面切换以及全局生命周期丰富完善。小程序具有相当完备的 API。</td>\n<td>小程序是由 JSCore 驱动逻辑层，视图层采用 Webview，故没有 DOM 节点的概念，只有渲染出的虚拟节点，所以无法动态删除或添加节点，无法使用一切 DOM 相关 API。小程序组件生命周期不够强大。小程序的 Webview 渲染存在一定的性能问题。小程序视图层与逻辑层通过 Jsbridge 连接，数据传输及渲染有延时。</td>\n</tr>\n<tr>\n<td>vue</td>\n<td>Vue 的实质是动态监测并托管 DOM 节点。由于 Vue 是网页开发，拥有 DOM 树，可以使用 DOM 相关 API。Vue 组件拥有更全面的生命周期，同时可以动态渲染组件。Vue 的组件传递数据方式默认为单向绑定</td>\n<td>由于 Vue 的组件本质是监测 DOM 树，故其组件只能有一个根节点。同时 Vue 的界面路由依赖于 History API，其界面切换周期与逻辑不够强大。</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"代码区别\" tabindex=\"-1\"> 代码区别</h2>\n<p>小程序与 Vue 在代码写法上极其相似，但稍有不同。</p>\n<h3 id=\"数据绑定\" tabindex=\"-1\"> 数据绑定</h3>\n<h4 id=\"小程序数据绑定\" tabindex=\"-1\"> 小程序数据绑定</h4>\n<div><pre><code><span><span><span>&lt;</span>view</span> <span>class</span><span><span>=</span><span>\"</span>text1 {{a}} {{b?:<span>'</span>b为真<span>'</span>:<span>'</span>b为假<span>'</span>}}<span>\"</span></span><span>></span></span>{{text}}<span><span><span>&lt;/</span>view</span><span>></span></span>\n</code></pre><div aria-hidden=\"true\"><div></div></div></div><div>\n<p>小程序在所有内容上都使用 Muscle 语法 (<code>{{Javascript表达式}}</code>) 的写法。</p>\n</div>\n<h4 id=\"vue-数据绑定\" tabindex=\"-1\"> Vue 数据绑定</h4>\n<div><pre><code><span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>\"</span>text1<span>\"</span></span> <span>:class</span><span><span>=</span><span>\"</span>a+<span>'</span> <span>'</span>+ b?:<span>'</span>b为真<span>'</span>:<span>'</span>b为假<span>'</span><span>\"</span></span><span>></span></span>{{text}}<span><span><span>&lt;/</span>div</span><span>></span></span>\n</code></pre><div aria-hidden=\"true\"><div></div></div></div><div><p>提示</p>\n<p>Vue 在标签名属性用 <code>v-bind:prop=&quot;Javascript表达式&quot;</code> 的写法、其简写为 <code>:prop=&quot;&quot;</code>，在标签内容处使用 Muscle 语法。</p>\n</div>\n<h3 id=\"条件渲染\" tabindex=\"-1\"> 条件渲染</h3>\n<h4 id=\"小程序条件渲染\" tabindex=\"-1\"> 小程序条件渲染</h4>\n<div><pre><code><span><span><span>&lt;</span>view</span> <span><span>wx:</span>if</span><span><span>=</span><span>\"</span>{{condition1}}<span>\"</span></span><span>></span></span>板块只有 condition1 为 true 时才会渲染<span><span><span>&lt;/</span>view</span><span>></span></span>\n\n\n<span><span><span>&lt;</span>block</span> <span><span>wx:</span>if</span><span><span>=</span><span>\"</span>{{condition2}}<span>\"</span></span><span>></span></span>\n  <span><span><span>&lt;</span>view</span><span>></span></span>内容1<span><span><span>&lt;/</span>view</span><span>></span></span>\n  <span><span><span>&lt;</span>view</span><span>></span></span>内容2<span><span><span>&lt;/</span>view</span><span>></span></span>\n  <span><span><span>&lt;</span>view</span><span>></span></span>\n    <span><span><span>&lt;</span>view</span><span>></span></span>内容3<span><span><span>&lt;/</span>view</span><span>></span></span>\n    <span><span><span>&lt;</span>view</span><span>></span></span>内容4<span><span><span>&lt;/</span>view</span><span>></span></span>\n  <span><span><span>&lt;/</span>view</span><span>></span></span>\n  <span><span><span>&lt;</span>view</span><span>></span></span>\n    这是一个拥有很多兄弟标签的代码块.\n    虚拟标签 block 会把其当作一个整体用作条件渲染。\n  <span><span><span>&lt;/</span>view</span><span>></span></span>\n<span><span><span>&lt;/</span>block</span><span>></span></span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><div><p>相关信息</p>\n<p>更多详情请见 <a href=\"https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxml/conditional.html\" target=\"_blank\" rel=\"noopener noreferrer\">小程序条件渲染文档</a></p>\n</div>\n<h4 id=\"vue-条件渲染\" tabindex=\"-1\"> Vue 条件渲染</h4>\n<div><pre><code><span><span><span>&lt;</span>div</span> <span>v-if</span><span><span>=</span><span>\"</span>condition<span>\"</span></span><span>></span></span>板块只有 condition 为 true 时才会渲染<span><span><span>&lt;/</span>div</span><span>></span></span>\n\n<span><span><span>&lt;</span>div</span> <span>v-if</span><span><span>=</span><span>\"</span>{{condition2}}<span>\"</span></span><span>></span></span>\n  <span><span><span>&lt;</span>div</span><span>></span></span>内容1<span><span><span>&lt;/</span>div</span><span>></span></span>\n  <span><span><span>&lt;</span>div</span><span>></span></span>内容2<span><span><span>&lt;/</span>div</span><span>></span></span>\n  <span><span><span>&lt;</span>div</span><span>></span></span>\n    <span><span><span>&lt;</span>div</span><span>></span></span>内容3<span><span><span>&lt;/</span>div</span><span>></span></span>\n    <span><span><span>&lt;</span>div</span><span>></span></span>内容4<span><span><span>&lt;/</span>div</span><span>></span></span>\n  <span><span><span>&lt;/</span>div</span><span>></span></span>\n  <span><span><span>&lt;</span>div</span><span>></span></span>\n    Vue 没有相关虚拟标签，且只能监听一个标签。所以只能建立一个没有样式的 div\n    标签将多个并列标签抱起来。这样 Vue 就会因监听最外层 div\n    会把其当作一个整体用作条件渲染。\n  <span><span><span>&lt;/</span>div</span><span>></span></span>\n<span><span><span>&lt;/</span>div</span><span>></span></span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><div><p>相关信息</p>\n<p>更多相关请见 <a href=\"https://cn.vuejs.org/v2/guide/#%E6%9D%A1%E4%BB%B6%E4%B8%8E%E5%BE%AA%E7%8E%AF\" target=\"_blank\" rel=\"noopener noreferrer\">Vue 条件渲染文档</a></p>\n</div>\n<h3 id=\"循环渲染\" tabindex=\"-1\"> 循环渲染</h3>\n<h4 id=\"小程序循环渲染\" tabindex=\"-1\"> 小程序循环渲染</h4>\n<div><pre><code><span><span><span>&lt;</span>view</span> <span><span>wx:</span>for</span><span><span>=</span><span>\"</span>{{array}}<span>\"</span></span> <span><span>wx:</span>for-item</span><span><span>=</span><span>\"</span>element<span>\"</span></span> <span><span>wx:</span>for-index</span><span><span>=</span><span>\"</span>index<span>\"</span></span><span>></span></span>\n  {{index}} is {{element}}\n<span><span><span>&lt;/</span>view</span><span>></span></span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div></div></div><p>实际渲染结果为:</p>\n<div><pre><code><span><span><span>&lt;</span>view</span><span>></span></span>1<span><span><span>&lt;/</span>view</span><span>></span></span>\n<span><span><span>&lt;</span>view</span><span>></span></span>2<span><span><span>&lt;/</span>view</span><span>></span></span>\n<span><span><span>&lt;</span>view</span><span>></span></span>3<span><span><span>&lt;/</span>view</span><span>></span></span>\n<span><span><span>&lt;</span>view</span><span>></span></span>4<span><span><span>&lt;/</span>view</span><span>></span></span>\n<span><span><span>&lt;</span>view</span><span>></span></span>5<span><span><span>&lt;/</span>view</span><span>></span></span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div></div></div><div><p>相关信息</p>\n<p>更多详情请见 <a href=\"https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxml/list.html\" target=\"_blank\" rel=\"noopener noreferrer\">小程序循环渲染文档</a></p>\n</div>\n<h4 id=\"vue-循环渲染\" tabindex=\"-1\"> Vue 循环渲染</h4>\n<div><pre><code><span><span><span>&lt;</span>div</span><span>></span></span>\n    <span><span><span>&lt;</span>div</span> <span>v-for</span><span><span>=</span><span>\"</span>(element,index) in array<span>\"</span></span><span>></span></span>\n       {{index}} is {{ element }}\n    <span><span><span>&lt;/</span>div</span><span>></span></span>\n  <span><span><span>&lt;/</span>ol</span><span>></span></span>\n<span><span><span>&lt;/</span>div</span><span>></span></span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><div><p>相关信息</p>\n<p>更多相关请见 <a href=\"https://cn.vuejs.org/v2/guide/#%E6%9D%A1%E4%BB%B6%E4%B8%8E%E5%BE%AA%E7%8E%AF\" target=\"_blank\" rel=\"noopener noreferrer\">Vue 循环渲染文档</a></p>\n</div>\n<h2 id=\"生命周期\" tabindex=\"-1\"> 生命周期</h2>\n<h3 id=\"页面生命周期\" tabindex=\"-1\"> 页面生命周期</h3>\n<h4 id=\"小程序生命周期\" tabindex=\"-1\"> 小程序生命周期</h4>\n<p><img src=\"https://res.wx.qq.com/wxdoc/dist/assets/img/page-lifecycle.2e646c86.png\" alt=\"小程序页面生命周期\"></p>\n<h4 id=\"vue-页面生命周期\" tabindex=\"-1\"> Vue 页面生命周期</h4>\n<p><a href=\"https://router.vuejs.org/guide/advanced/navigation-guards.html\" target=\"_blank\" rel=\"noopener noreferrer\">Vue 页面生命周期</a></p>\n<h3 id=\"组件生命周期\" tabindex=\"-1\"> 组件生命周期</h3>\n<h4 id=\"小程序组件生命周期\" tabindex=\"-1\"> 小程序组件生命周期</h4>\n<p><a href=\"https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/lifetimes.html\" target=\"_blank\" rel=\"noopener noreferrer\">小程序组件生命周期</a></p>\n<h4 id=\"vue-组件生命周期\" tabindex=\"-1\"> Vue 组件生命周期</h4>\n<p><img src=\"https://cn.vuejs.org/images/lifecycle.png\" alt=\"Vue组件生命周期\"></p>\n",
      "image": "https://res.wx.qq.com/wxdoc/dist/assets/img/page-lifecycle.2e646c86.png",
      "date_published": "2022-08-20T08:54:00.000Z",
      "date_modified": "2022-08-20T08:54:00.000Z",
      "authors": [],
      "tags": [
        "Vue"
      ]
    },
    {
      "title": "组件使用说明",
      "url": "https://github.com/MisterChen9527/code/vue/component.html",
      "id": "https://github.com/MisterChen9527/code/vue/component.html",
      "summary": "Mr.Chen 已为 inNENU Website 开发了一些常规组件。本文介绍了这些组件的配置。\n",
      "content_html": "<p>Mr.Chen 已为 inNENU Website 开发了一些常规组件。本文介绍了这些组件的配置。</p>\n\n<h2 id=\"常规组件\" tabindex=\"-1\"> 常规组件</h2>\n<div><p>提示</p>\n<p>所有以 <code>Base</code> 开头的组件都包含如下属性:</p>\n<p>| 属性 | 必填 |       类型       | 内容      |\n| ---- | :--: | :--------------: | --------- | --- |\n| myId |  是  | Number 或 String | 组件的 ID |     |</p>\n</div>\n<p>以下是项目中中常用的组件。</p>\n<h3 id=\"basehead\" tabindex=\"-1\"> BaseHead</h3>\n<p>页面标题文字</p>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th style=\"text-align:center\">必填</th>\n<th style=\"text-align:center\">类型</th>\n<th>内容</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>title</td>\n<td style=\"text-align:center\">是</td>\n<td style=\"text-align:center\">String</td>\n<td>页面选项卡文字</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"basetitle\" tabindex=\"-1\"> BaseTitle</h3>\n<p>段落间大标题</p>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th style=\"text-align:center\">必填</th>\n<th style=\"text-align:center\">类型</th>\n<th>内容</th>\n<th>补充说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>text</td>\n<td style=\"text-align:center\">是</td>\n<td style=\"text-align:center\">String</td>\n<td>标题文字</td>\n<td></td>\n</tr>\n<tr>\n<td>myStyle</td>\n<td style=\"text-align:center\">否</td>\n<td style=\"text-align:center\">String 或 Style</td>\n<td>标题自定义样式</td>\n<td>填入任意 css 样式</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"basep\" tabindex=\"-1\"> BaseP</h3>\n<p>段落文字(可带图)</p>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th style=\"text-align:center\">必填</th>\n<th style=\"text-align:center\">类型</th>\n<th>内容</th>\n<th>补充说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>text</td>\n<td style=\"text-align:center\">是</td>\n<td style=\"text-align:center\">String</td>\n<td>段落的文字</td>\n<td>可以识别连续的空格，使用 <code>\\n</code> 表示回车，也可直接使用 <code>&lt;br /&gt;</code> 换行</td>\n</tr>\n<tr>\n<td>head</td>\n<td style=\"text-align:center\">否</td>\n<td style=\"text-align:center\">String</td>\n<td>段落的标题</td>\n<td></td>\n</tr>\n<tr>\n<td>headStyle</td>\n<td style=\"text-align:center\">否</td>\n<td style=\"text-align:center\">String 或 Style</td>\n<td>标题自定义样式</td>\n<td>填入任意 css 样式</td>\n</tr>\n<tr>\n<td>myStyle</td>\n<td style=\"text-align:center\">否</td>\n<td style=\"text-align:center\">String 或 Style</td>\n<td>标题自定义样式</td>\n<td>填入任意 css 样式</td>\n</tr>\n<tr>\n<td>src</td>\n<td style=\"text-align:center\">否</td>\n<td style=\"text-align:center\">String</td>\n<td>图片的路径</td>\n<td>会在段落后渲染一张图片</td>\n</tr>\n<tr>\n<td>desc</td>\n<td style=\"text-align:center\">否</td>\n<td style=\"text-align:center\">String</td>\n<td>图片的描述文字</td>\n<td>会自动在文字前加 <code>▲</code></td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"baseimg\" tabindex=\"-1\"> BaseImg</h3>\n<p>图片</p>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th style=\"text-align:center\">必填</th>\n<th style=\"text-align:center\">类型</th>\n<th>内容</th>\n<th>补充说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>src</td>\n<td style=\"text-align:center\">是</td>\n<td style=\"text-align:center\">String</td>\n<td>图片的路径</td>\n<td></td>\n</tr>\n<tr>\n<td>desc</td>\n<td style=\"text-align:center\">否</td>\n<td style=\"text-align:center\">String</td>\n<td>图片的描述文字</td>\n<td>会自动在文字前加 ▲</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"baselist\" tabindex=\"-1\"> BaseList</h3>\n<p>列表</p>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th style=\"text-align:center\">必填</th>\n<th style=\"text-align:center\">类型</th>\n<th>内容</th>\n<th>补充说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>content</td>\n<td style=\"text-align:center\">是</td>\n<td style=\"text-align:center\">String</td>\n<td>列表内容</td>\n<td></td>\n</tr>\n<tr>\n<td>head</td>\n<td style=\"text-align:center\">否</td>\n<td style=\"text-align:center\">String 或 Boolean</td>\n<td>列表的标题</td>\n<td>默认为 <code>''</code>，设置 <code>false</code> 取消显示列表标题，否则即使不设置也会显示一个空标题</td>\n</tr>\n<tr>\n<td>foot</td>\n<td style=\"text-align:center\">否</td>\n<td style=\"text-align:center\">String</td>\n<td>列表的页脚文字</td>\n<td>默认为 <code>''</code>,不显示页脚</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"basegrid\" tabindex=\"-1\"> BaseGrid</h3>\n<p>九宫格</p>\n<p>| 属性    | 必填 |       类型        | 内容             |\n| ------- | :--: | :---------------: | ---------------- | ------------------------------------------------------------------------------ |\n| content |  是  |    GirdItem[]     | 九宫格单元内容   |\n| head    |  否  | String 或 Boolean | 九宫格的标题     | 默认为 <code>''</code>，设置 <code>false</code> 取消显示九宫格标题，否则即使不设置也会显示一个空标题 |\n| foot    |  否  |      String       | 九宫格的页脚文字 | 默认为 <code>''</code>,不显示页脚                                                         |</p>\n<ul>\n<li><strong>GirdItem</strong></li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th style=\"text-align:center\">必填</th>\n<th style=\"text-align:center\">类型</th>\n<th>内容</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>icon</td>\n<td style=\"text-align:center\">是</td>\n<td style=\"text-align:center\">String</td>\n<td>图标地址</td>\n</tr>\n<tr>\n<td>text</td>\n<td style=\"text-align:center\">是</td>\n<td style=\"text-align:center\">String</td>\n<td>文字</td>\n</tr>\n<tr>\n<td>url</td>\n<td style=\"text-align:center\">是</td>\n<td style=\"text-align:center\">String</td>\n<td>跳转链接</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"basefoot\" tabindex=\"-1\"> BaseFoot</h3>\n<p>页脚</p>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th style=\"text-align:center\">必填</th>\n<th style=\"text-align:center\">类型</th>\n<th>内容</th>\n<th>补充说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>desc</td>\n<td style=\"text-align:center\">否</td>\n<td style=\"text-align:center\">String</td>\n<td>页脚额外描述文字</td>\n<td></td>\n</tr>\n<tr>\n<td>author</td>\n<td style=\"text-align:center\">否</td>\n<td style=\"text-align:center\">String</td>\n<td>作者</td>\n<td>默认为 <code>Mr.Chen</code>，如需取消请传入 <code>''</code></td>\n</tr>\n<tr>\n<td>time</td>\n<td style=\"text-align:center\">否</td>\n<td style=\"text-align:center\">String</td>\n<td>最后编辑时间</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"basecarousel\" tabindex=\"-1\"> BaseCarousel</h3>\n<p>轮播图</p>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th style=\"text-align:center\">必填</th>\n<th style=\"text-align:center\">类型</th>\n<th>内容</th>\n<th>补充说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>content</td>\n<td style=\"text-align:center\">是</td>\n<td style=\"text-align:center\">CarouselItem[]</td>\n<td>轮播图组件内容</td>\n<td></td>\n</tr>\n<tr>\n<td>vertical</td>\n<td style=\"text-align:center\">否</td>\n<td style=\"text-align:center\">Boolean</td>\n<td>是否竖直显示</td>\n<td>默认为 <code>false</code></td>\n</tr>\n<tr>\n<td>autoplay</td>\n<td style=\"text-align:center\">否</td>\n<td style=\"text-align:center\">Boolean</td>\n<td>是否支持自动播放</td>\n<td>默认为 <code>true</code></td>\n</tr>\n<tr>\n<td>autoplaySpeed</td>\n<td style=\"text-align:center\">否</td>\n<td style=\"text-align:center\">Number</td>\n<td>自动播放时间间隔</td>\n<td>默认为 <code>3000</code></td>\n</tr>\n<tr>\n<td>speed</td>\n<td style=\"text-align:center\">否</td>\n<td style=\"text-align:center\">Number</td>\n<td>切换速度</td>\n<td>默认为 <code>500</code></td>\n</tr>\n<tr>\n<td>dotDisplay</td>\n<td style=\"text-align:center\">否</td>\n<td style=\"text-align:center\">Boolean</td>\n<td>是否显示指示点</td>\n<td>默认为 <code>true</code></td>\n</tr>\n<tr>\n<td>arrowDisplay</td>\n<td style=\"text-align:center\">否</td>\n<td style=\"text-align:center\">Boolean</td>\n<td>是否显示切换箭头</td>\n<td>默认为 <code>true</code></td>\n</tr>\n<tr>\n<td>easing</td>\n<td style=\"text-align:center\">否</td>\n<td style=\"text-align:center\">String</td>\n<td>切换动画</td>\n<td>默认为 <code>easeInOutQuart</code></td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li><strong>CarouselItem</strong></li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th style=\"text-align:center\">必填</th>\n<th style=\"text-align:center\">类型</th>\n<th>内容</th>\n<th>补充说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>caption</td>\n<td style=\"text-align:center\">是</td>\n<td style=\"text-align:center\">String</td>\n<td>轮播图的主标题</td>\n<td>请填入核心内容</td>\n</tr>\n<tr>\n<td>subCaption</td>\n<td style=\"text-align:center\">是</td>\n<td style=\"text-align:center\">String</td>\n<td>轮播图的副标题</td>\n<td>主标题的进一步解释</td>\n</tr>\n<tr>\n<td>src</td>\n<td style=\"text-align:center\">是</td>\n<td style=\"text-align:center\">String</td>\n<td>图片的路径</td>\n<td>所有轮播图图片长宽比例应该相同，推荐值 <code>16: 9</code></td>\n</tr>\n<tr>\n<td>url</td>\n<td style=\"text-align:center\">否</td>\n<td style=\"text-align:center\">String</td>\n<td>轮播图点击时的跳转路径</td>\n<td>支持相对路径绝对路径以及 http、https 链接</td>\n</tr>\n<tr>\n<td>enSubhead</td>\n<td style=\"text-align:center\">否</td>\n<td style=\"text-align:center\">String</td>\n<td>轮播图的英文副标题</td>\n<td></td>\n</tr>\n<tr>\n<td>alt</td>\n<td style=\"text-align:center\">否</td>\n<td style=\"text-align:center\">String</td>\n<td>图片失效时的显示文字</td>\n<td>不填会默认初始化为文字 <code>轮播图背景</code></td>\n</tr>\n<tr>\n<td>desc</td>\n<td style=\"text-align:center\">否</td>\n<td style=\"text-align:center\">String</td>\n<td>页面右下角补充说明</td>\n<td>仅在 large 及以上屏幕上显示</td>\n</tr>\n<tr>\n<td>black</td>\n<td style=\"text-align:center\">否</td>\n<td style=\"text-align:center\">Boolean</td>\n<td>是否采用黑色文字</td>\n<td>默认文字色为白色</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"basephone\" tabindex=\"-1\"> BasePhone</h3>\n<p>生成拨打电话提示，该组件仅为兼容小程序。</p>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th style=\"text-align:center\">必填</th>\n<th style=\"text-align:center\">类型</th>\n<th>内容</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>number</td>\n<td style=\"text-align:center\">是</td>\n<td style=\"text-align:center\">String 或 Number</td>\n<td>电话号码</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"以下是以便复用的不常用组件\" tabindex=\"-1\"> 以下是以便复用的不常用组件</h2>\n<h3 id=\"nav-组件\" tabindex=\"-1\"> Nav 组件</h3>\n<p>网页导航栏</p>\n<h3 id=\"slide-组件\" tabindex=\"-1\"> Slide 组件</h3>\n<p>网页侧边栏</p>\n<h3 id=\"footer-组件\" tabindex=\"-1\"> Footer 组件</h3>\n<p>网页页脚</p>\n<h3 id=\"basemenu-组件\" tabindex=\"-1\"> BaseMenu 组件</h3>\n<p>生成竖直菜单</p>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th style=\"text-align:center\">必填</th>\n<th style=\"text-align:center\">类型</th>\n<th>内容</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>list</td>\n<td style=\"text-align:center\">是</td>\n<td style=\"text-align:center\">MenuItem[]</td>\n<td>菜单内容</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li><strong>MenuItem</strong></li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th style=\"text-align:center\">必填</th>\n<th style=\"text-align:center\">类型</th>\n<th>内容</th>\n<th>补充说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>key</td>\n<td style=\"text-align:center\">是</td>\n<td style=\"text-align:center\">String</td>\n<td>菜单项的标识符</td>\n<td>不可重复</td>\n</tr>\n<tr>\n<td>title</td>\n<td style=\"text-align:center\">是</td>\n<td style=\"text-align:center\">String</td>\n<td>菜单的文字</td>\n<td></td>\n</tr>\n<tr>\n<td>icon</td>\n<td style=\"text-align:center\">否</td>\n<td style=\"text-align:center\">String 或 Boolean</td>\n<td>菜单的图标</td>\n<td>填入 <code>true</code> 不显示图标但是图标区留空</td>\n</tr>\n<tr>\n<td>children</td>\n<td style=\"text-align:center\">否</td>\n<td style=\"text-align:center\">MenuItem[]</td>\n<td>子菜单</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"basepage-组件\" tabindex=\"-1\"> BasePage 组件</h3>\n<p>用于渲染小程序 json 生成页面</p>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th style=\"text-align:center\">必填</th>\n<th style=\"text-align:center\">类型</th>\n<th>内容</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>pagedata</td>\n<td style=\"text-align:center\">是</td>\n<td style=\"text-align:center\">String</td>\n<td>小程序页面 json 的字符串</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"docview-组件\" tabindex=\"-1\"> DocView 组件</h3>\n<p>用于自动渲染转码的 HTML</p>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th style=\"text-align:center\">必填</th>\n<th style=\"text-align:center\">类型</th>\n<th>内容</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>docContent</td>\n<td style=\"text-align:center\">是</td>\n<td style=\"text-align:center\">String</td>\n<td>Markdown 转 HTML 内容</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"basecard-组件\" tabindex=\"-1\"> BaseCard 组件</h3>\n<p>卡片样式。</p>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th style=\"text-align:center\">必填</th>\n<th style=\"text-align:center\">类型</th>\n<th>内容</th>\n<th>补充说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>title</td>\n<td style=\"text-align:center\">是</td>\n<td style=\"text-align:center\">String</td>\n<td>卡片的标题</td>\n<td></td>\n</tr>\n<tr>\n<td>price</td>\n<td style=\"text-align:center\">是</td>\n<td style=\"text-align:center\">Number</td>\n<td>价格</td>\n<td></td>\n</tr>\n<tr>\n<td>desc</td>\n<td style=\"text-align:center\">是</td>\n<td style=\"text-align:center\">Array</td>\n<td>卡片详情</td>\n<td>数组的每一项是卡片详情的每一项内容，支持 rawHtml</td>\n</tr>\n<tr>\n<td>url</td>\n<td style=\"text-align:center\">是</td>\n<td style=\"text-align:center\">String</td>\n<td>卡片跳转的地址</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"basetimeaxis-组件\" tabindex=\"-1\"> BaseTimeAxis 组件</h3>\n<p>生成时间轴</p>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th style=\"text-align:center\">必填</th>\n<th style=\"text-align:center\">类型</th>\n<th>内容</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>timeList</td>\n<td style=\"text-align:center\">是</td>\n<td style=\"text-align:center\">TimeListItem[]</td>\n<td>Markdown 转 HTML 内容</td>\n</tr>\n</tbody>\n</table>\n<div><p>注意</p>\n<p>※ 必须将该组件直接放置在 <code>div.container</code> 中! 否则会造成显示错乱。</p>\n</div>\n<ul>\n<li><strong>TimeListItem</strong>:</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th style=\"text-align:center\">必填</th>\n<th style=\"text-align:center\">类型</th>\n<th>内容</th>\n<th>补充说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>title</td>\n<td style=\"text-align:center\">是</td>\n<td style=\"text-align:center\">String</td>\n<td>时间线的标题</td>\n<td></td>\n</tr>\n<tr>\n<td>text</td>\n<td style=\"text-align:center\">是</td>\n<td style=\"text-align:center\">String</td>\n<td>时间线的段落文字</td>\n<td>可输入 rawhtml，支持 <code>\\n</code> 与连续空格</td>\n</tr>\n<tr>\n<td>icon</td>\n<td style=\"text-align:center\">否</td>\n<td style=\"text-align:center\">String</td>\n<td>时间线的图标</td>\n<td>可输入 rawhtml</td>\n</tr>\n<tr>\n<td>url</td>\n<td style=\"text-align:center\">否</td>\n<td style=\"text-align:center\">String</td>\n<td>点击当前选项卡跳转的地址</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"mydoc-组件\" tabindex=\"-1\"> MyDoc 组件</h3>\n<p>用于自动生成 HTML 页面</p>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th style=\"text-align:center\">必填</th>\n<th style=\"text-align:center\">类型</th>\n<th>内容</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>baselength</td>\n<td style=\"text-align:center\">是</td>\n<td style=\"text-align:center\">Number</td>\n<td>MarkDown 基准路径字符数</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"backtop-组件\" tabindex=\"-1\"> BackTop 组件</h3>\n<p>一个返回顶部按钮，当滚动距离超过 300px 时显示会显示在右下角</p>\n<h3 id=\"loadingicon\" tabindex=\"-1\"> LoadingIcon</h3>\n<p>一个自定义的齿轮加载图标</p>\n<h3 id=\"passwordmodal\" tabindex=\"-1\"> PasswordModal</h3>\n<p>密码弹出框</p>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th style=\"text-align:center\">必填</th>\n<th style=\"text-align:center\">类型</th>\n<th>内容</th>\n<th>补充说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>url</td>\n<td style=\"text-align:center\">是</td>\n<td style=\"text-align:center\">String</td>\n<td>验证地址</td>\n<td>填入绝对路径，不需要填写 php 文件后缀名</td>\n</tr>\n<tr>\n<td>userNameKey</td>\n<td style=\"text-align:center\">否</td>\n<td style=\"text-align:center\">String</td>\n<td>用户名的自动填充键值</td>\n<td>填写后会提示输入用户名，默认不输入</td>\n</tr>\n<tr>\n<td>passwordKey</td>\n<td style=\"text-align:center\">否</td>\n<td style=\"text-align:center\">String</td>\n<td>密码的自动填充键值</td>\n<td>默认为 <code>password</code></td>\n</tr>\n</tbody>\n</table>\n",
      "date_published": "2022-08-20T08:54:00.000Z",
      "date_modified": "2022-08-20T08:54:00.000Z",
      "authors": [],
      "tags": [
        "Vue"
      ]
    },
    {
      "title": "快速上手 Vue.js",
      "url": "https://github.com/MisterChen9527/code/vue/get-started.html",
      "id": "https://github.com/MisterChen9527/code/vue/get-started.html",
      "content_html": "<h2 id=\"vue-js-是什么\" tabindex=\"-1\"> Vue.js 是什么</h2>\n<p><a href=\"https://learning.dcloud.io/#/?vid=0\" target=\"_blank\" rel=\"noopener noreferrer\">观看本节视频讲解</a></p>\n<h2 id=\"起步\" tabindex=\"-1\"> 起步</h2>\n<p><a href=\"https://learning.dcloud.io/#/?vid=1\" target=\"_blank\" rel=\"noopener noreferrer\">观看本节视频讲解</a></p>\n<div><p>提示</p>\n<p>您应当已了解关于 HTML、CSS 和 JavaScript 的中级知识。</p>\n</div>\n<p><a href=\"https://cn.vuejs.org/v2/guide/installation.html\" target=\"_blank\" rel=\"noopener noreferrer\">安装</a></p>\n<p>尝试 Vue.js 最简单的方法是使用 <a href=\"https://jsfiddle.net/chrisvfritz/50wL7mdz/\" target=\"_blank\" rel=\"noopener noreferrer\">JSFiddle 上的 Hello World 例子</a>。您可以在浏览器新标签页中打开它，跟着例子学习一些基础用法。或者您也可以创建一个 <code>.html</code> 文件，然后通过如下方式引入 Vue:</p>\n<div><pre><code><span>&lt;!-- 开发环境版本，包含了有帮助的命令行警告 --></span>\n<span><span><span>&lt;</span>script</span> <span>src</span><span><span>=</span><span>\"</span>https://cdn.jsdelivr.net/npm/vue/dist/vue.js<span>\"</span></span><span>></span></span><span></span><span><span><span>&lt;/</span>script</span><span>></span></span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div></div></div><p>或者:</p>\n<div><pre><code><span>&lt;!-- 生产环境版本，优化了尺寸和速度 --></span>\n<span><span><span>&lt;</span>script</span> <span>src</span><span><span>=</span><span>\"</span>https://cdn.jsdelivr.net/npm/vue<span>\"</span></span><span>></span></span><span></span><span><span><span>&lt;/</span>script</span><span>></span></span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div></div></div><div><p>注意</p>\n<p>请注意 Mr.Chen <strong>不推荐</strong> 新手直接使用 <code>vue-cli</code>，尤其是在您还不熟悉基于 Node.js 的构建工具时。</p>\n</div>\n<h2 id=\"声明式渲染\" tabindex=\"-1\"> 声明式渲染</h2>\n<p><a href=\"https://learning.dcloud.io/#/?vid=3\" target=\"_blank\" rel=\"noopener noreferrer\">观看本节视频讲解</a></p>\n<p>Vue.js 的核心是一个允许采用简洁的模板语法来声明式地将数据渲染进 DOM 的系统:</p>\n<div><pre><code><span><span><span>&lt;</span>div</span> <span>id</span><span><span>=</span><span>\"</span>app<span>\"</span></span><span>></span></span>{{ message }}<span><span><span>&lt;/</span>div</span><span>></span></span>\n</code></pre><div aria-hidden=\"true\"><div></div></div></div><div><pre><code><span>const</span> app <span>=</span> <span>new</span> <span>Vue</span><span>(</span><span>{</span>\n  <span>el</span><span>:</span> <span>\"#app\"</span><span>,</span>\n  <span>data</span><span>:</span> <span>{</span>\n    <span>message</span><span>:</span> <span>\"Hello Vue!\"</span><span>,</span>\n  <span>}</span><span>,</span>\n<span>}</span><span>)</span><span>;</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>我们已经成功创建了第一个 Vue 应用! 现在数据和 DOM 已经被建立了关联，所有东西都是<strong>响应式的</strong>。也就是说如果 <code>data</code> 中的 <code>message</code> 值被改变，那么视图层中的 <code>message</code> 马上会更新。</p>\n<p>除了文本插值，我们还可以像这样来绑定元素特性:</p>\n<div><pre><code><span><span><span>&lt;</span>div</span> <span>id</span><span><span>=</span><span>\"</span>app-2<span>\"</span></span><span>></span></span>\n  <span><span><span>&lt;</span>span</span> <span><span>v-bind:</span>title</span><span><span>=</span><span>\"</span>message<span>\"</span></span><span>></span></span>\n    鼠标悬停几秒钟查看此处动态绑定的提示信息!\n  <span><span><span>&lt;/</span>span</span><span>></span></span>\n<span><span><span>&lt;/</span>div</span><span>></span></span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div></div></div><div><pre><code><span>const</span> app2 <span>=</span> <span>new</span> <span>Vue</span><span>(</span><span>{</span>\n  <span>el</span><span>:</span> <span>\"#app-2\"</span><span>,</span>\n  <span>data</span><span>:</span> <span>{</span>\n    <span>message</span><span>:</span> <span>\"页面加载于 \"</span> <span>+</span> <span>new</span> <span>Date</span><span>(</span><span>)</span><span>.</span><span>toLocaleString</span><span>(</span><span>)</span><span>,</span>\n  <span>}</span><span>,</span>\n<span>}</span><span>)</span><span>;</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>这里我们遇到了一点新东西。您看到的 <code>v-bind</code> 特性被称为<strong>指令</strong>。指令带有前缀 <code>v-</code>，以表示它们是 Vue 提供的特殊特性。可能您已经猜到了，它们会在渲染的 DOM 上应用特殊的响应式行为。在这里，该指令的意思是: “将这个元素节点的 <code>title</code> 特性和 Vue 实例的 <code>message</code> 属性保持一致”。</p>\n<h2 id=\"条件与循环\" tabindex=\"-1\"> 条件与循环</h2>\n<p><a href=\"https://learning.dcloud.io/#/?vid=8\" target=\"_blank\" rel=\"noopener noreferrer\">观看本节视频讲解</a></p>\n<p>控制切换一个元素是否显示也相当简单:</p>\n<div><pre><code><span><span><span>&lt;</span>div</span> <span>id</span><span><span>=</span><span>\"</span>app-3<span>\"</span></span><span>></span></span>\n  <span><span><span>&lt;</span>p</span> <span>v-if</span><span><span>=</span><span>\"</span>seen<span>\"</span></span><span>></span></span>现在您看到我了<span><span><span>&lt;/</span>p</span><span>></span></span>\n<span><span><span>&lt;/</span>div</span><span>></span></span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div></div></div><div><pre><code><span>const</span> app3 <span>=</span> <span>new</span> <span>Vue</span><span>(</span><span>{</span>\n  <span>el</span><span>:</span> <span>\"#app-3\"</span><span>,</span>\n  <span>data</span><span>:</span> <span>{</span>\n    <span>seen</span><span>:</span> <span>true</span><span>,</span>\n  <span>}</span><span>,</span>\n<span>}</span><span>)</span><span>;</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>如果您改变 <code>seen</code> 的值，文字的显示与否(也就是 <code>&lt;p&gt;</code> 标签的存在与否)也会进行切换。</p>\n<p>这个例子演示了我们不仅可以把数据绑定到 DOM 文本或特性，还可以绑定到 DOM <strong>结构</strong>。此外，Vue 也提供一个强大的过渡效果系统，可以在 Vue 插入/更新/移除元素时自动应用<a href=\"https://cn.vuejs.org/v2/guide/transitions.html\" target=\"_blank\" rel=\"noopener noreferrer\">过渡效果</a>。</p>\n<p>还有其它很多指令，每个都有特殊的功能。例如，<code>v-for</code> 指令可以绑定数组的数据来渲染一个项目列表:</p>\n<div><pre><code><span><span><span>&lt;</span>div</span> <span>id</span><span><span>=</span><span>\"</span>app-4<span>\"</span></span><span>></span></span>\n  <span><span><span>&lt;</span>ol</span><span>></span></span>\n    <span><span><span>&lt;</span>li</span> <span>v-for</span><span><span>=</span><span>\"</span>todo in todos<span>\"</span></span><span>></span></span>{{ todo.text }}<span><span><span>&lt;/</span>li</span><span>></span></span>\n  <span><span><span>&lt;/</span>ol</span><span>></span></span>\n<span><span><span>&lt;/</span>div</span><span>></span></span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div></div></div><div><pre><code><span>const</span> app4 <span>=</span> <span>new</span> <span>Vue</span><span>(</span><span>{</span>\n  <span>el</span><span>:</span> <span>\"#app-4\"</span><span>,</span>\n  <span>data</span><span>:</span> <span>{</span>\n    <span>todos</span><span>:</span> <span>[</span>\n      <span>{</span> <span>text</span><span>:</span> <span>\"学习 JavaScript\"</span> <span>}</span><span>,</span>\n      <span>{</span> <span>text</span><span>:</span> <span>\"学习 Vue\"</span> <span>}</span><span>,</span>\n      <span>{</span> <span>text</span><span>:</span> <span>\"整个牛项目\"</span> <span>}</span><span>,</span>\n    <span>]</span><span>,</span>\n  <span>}</span><span>,</span>\n<span>}</span><span>)</span><span>;</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id=\"处理用户输入\" tabindex=\"-1\"> 处理用户输入</h2>\n<p><a href=\"https://learning.dcloud.io/#/?vid=11\" target=\"_blank\" rel=\"noopener noreferrer\">观看本节视频讲解</a></p>\n<p>为了让用户和您的应用进行交互，我们可以用 <code>v-on</code> 指令添加一个事件监听器，通过它调用在 Vue 实例中定义的方法:</p>\n<div><pre><code><span><span><span>&lt;</span>div</span> <span>id</span><span><span>=</span><span>\"</span>app-5<span>\"</span></span><span>></span></span>\n  <span><span><span>&lt;</span>p</span><span>></span></span>{{ message }}<span><span><span>&lt;/</span>p</span><span>></span></span>\n  <span><span><span>&lt;</span>button</span> <span><span>v-on:</span>click</span><span><span>=</span><span>\"</span>reverseMessage<span>\"</span></span><span>></span></span>反转消息<span><span><span>&lt;/</span>button</span><span>></span></span>\n<span><span><span>&lt;/</span>div</span><span>></span></span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div></div></div><div><pre><code><span>const</span> app5 <span>=</span> <span>new</span> <span>Vue</span><span>(</span><span>{</span>\n  <span>el</span><span>:</span> <span>\"#app-5\"</span><span>,</span>\n  <span>data</span><span>:</span> <span>{</span>\n    <span>message</span><span>:</span> <span>\"Hello Vue.js!\"</span><span>,</span>\n  <span>}</span><span>,</span>\n  <span>methods</span><span>:</span> <span>{</span>\n    <span>reverseMessage</span><span>:</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>\n      <span>this</span><span>.</span>message <span>=</span> <span>this</span><span>.</span>message<span>.</span><span>split</span><span>(</span><span>\"\"</span><span>)</span><span>.</span><span>reverse</span><span>(</span><span>)</span><span>.</span><span>join</span><span>(</span><span>\"\"</span><span>)</span><span>;</span>\n    <span>}</span><span>,</span>\n  <span>}</span><span>,</span>\n<span>}</span><span>)</span><span>;</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>注意在 <code>reverseMessage</code> 方法中，每次点击按钮的时候，我们更新了应用的状态，但没有触碰 DOM——所有的 DOM 操作都由 Vue 来处理，您编写的代码只需要关注逻辑层面即可。</p>\n<p>Vue 还提供了 <code>v-model</code> 指令，它能轻松实现表单输入和应用状态之间的双向绑定。</p>\n<div><pre><code><span><span><span>&lt;</span>div</span> <span>id</span><span><span>=</span><span>\"</span>app-6<span>\"</span></span><span>></span></span>\n  <span><span><span>&lt;</span>p</span><span>></span></span>{{ message }}<span><span><span>&lt;/</span>p</span><span>></span></span>\n  <span><span><span>&lt;</span>input</span> <span>v-model</span><span><span>=</span><span>\"</span>message<span>\"</span></span> <span>/></span></span>\n<span><span><span>&lt;/</span>div</span><span>></span></span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div></div></div><div><pre><code><span>const</span> app6 <span>=</span> <span>new</span> <span>Vue</span><span>(</span><span>{</span>\n  <span>el</span><span>:</span> <span>\"#app-6\"</span><span>,</span>\n  <span>data</span><span>:</span> <span>{</span>\n    <span>message</span><span>:</span> <span>\"Hello Vue!\"</span><span>,</span>\n  <span>}</span><span>,</span>\n<span>}</span><span>)</span><span>;</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>也就是说，在输入框做出的更改会同步到 js 的数据中。</p>\n<h2 id=\"组件化应用构建\" tabindex=\"-1\"> 组件化应用构建</h2>\n<p><a href=\"https://learning.dcloud.io/#/?vid=12\" target=\"_blank\" rel=\"noopener noreferrer\">观看本节视频讲解</a></p>\n<p>组件系统是 Vue 的另一个重要概念，因为它是一种抽象，允许我们使用小型、独立和通常可复用的组件构建大型应用。仔细想想，几乎任意类型的应用界面都可以抽象为一个组件树:</p>\n<p><img src=\"@source/code/vue/assets/components.png\" alt=\"Component Tree\"></p>\n<p>在 Vue 里，一个组件本质上是一个拥有预定义选项的一个 Vue 实例。在 Vue 中注册组件很简单:</p>\n<div><pre><code><span>// 定义名为 todo-item 的新组件</span>\nVue<span>.</span><span>component</span><span>(</span><span>\"todo-item\"</span><span>,</span> <span>{</span>\n  <span>template</span><span>:</span> <span>\"&lt;li>这是个待办项&lt;/li>\"</span><span>,</span>\n<span>}</span><span>)</span><span>;</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div></div></div><p>现在您可以用它构建另一个组件模板:</p>\n<div><pre><code><span><span><span>&lt;</span>ol</span><span>></span></span>\n  <span>&lt;!-- 创建一个 todo-item 组件的实例 --></span>\n  <span><span><span>&lt;</span>todo-ite</span> <span>/></span></span>\n<span><span><span>&lt;/</span>ol</span><span>></span></span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div></div></div><p>但是这样会为每个待办项渲染同样的文本，这看起来并不炫酷。我们应该能从父作用域将数据传到子组件才对。让我们来修改一下组件的定义，使之能够接受一个 <a href=\"https://cn.vuejs.org/v2/guide/components.html#%E9%80%9A%E8%BF%87-Prop-%E5%90%91%E5%AD%90%E7%BB%84%E4%BB%B6%E4%BC%A0%E9%80%92%E6%95%B0%E6%8D%AE\" target=\"_blank\" rel=\"noopener noreferrer\">prop</a>:</p>\n<div><pre><code>Vue<span>.</span><span>component</span><span>(</span><span>\"todo-item\"</span><span>,</span> <span>{</span>\n  <span>// todo-item 组件现在接受一个</span>\n  <span>// \"prop\"，类似于一个自定义特性。</span>\n  <span>// 这个 prop 名为 todo。</span>\n  <span>props</span><span>:</span> <span>[</span><span>\"todo\"</span><span>]</span><span>,</span>\n  <span>template</span><span>:</span> <span>\"&lt;li>{{ todo.text }}&lt;/li>\"</span><span>,</span>\n<span>}</span><span>)</span><span>;</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>现在，我们可以使用 <code>v-bind</code> 指令将待办项传到循环输出的每个组件中:</p>\n<div><pre><code><span><span><span>&lt;</span>div</span> <span>id</span><span><span>=</span><span>\"</span>app-7<span>\"</span></span><span>></span></span>\n  <span><span><span>&lt;</span>ol</span><span>></span></span>\n    <span>&lt;!--\n      现在我们为每个 todo-item 提供 todo 对象\n      todo 对象是变量，即其内容可以是动态的。\n      我们也需要为每个组件提供一个“key”，稍后再\n      作详细解释。\n    --></span>\n    <span><span><span>&lt;</span>todo-item</span>\n      <span>v-for</span><span><span>=</span><span>\"</span>item in groceryList<span>\"</span></span>\n      <span><span>v-bind:</span>todo</span><span><span>=</span><span>\"</span>item<span>\"</span></span>\n      <span><span>v-bind:</span>key</span><span><span>=</span><span>\"</span>item.id<span>\"</span></span>\n    <span>/></span></span>\n  <span><span><span>&lt;/</span>ol</span><span>></span></span>\n<span><span><span>&lt;/</span>div</span><span>></span></span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><div><pre><code>Vue<span>.</span><span>component</span><span>(</span><span>\"todo-item\"</span><span>,</span> <span>{</span>\n  <span>props</span><span>:</span> <span>[</span><span>\"todo\"</span><span>]</span><span>,</span>\n  <span>template</span><span>:</span> <span>\"&lt;li>{{ todo.text }}&lt;/li>\"</span><span>,</span>\n<span>}</span><span>)</span><span>;</span>\n\n<span>const</span> app7 <span>=</span> <span>new</span> <span>Vue</span><span>(</span><span>{</span>\n  <span>el</span><span>:</span> <span>\"#app-7\"</span><span>,</span>\n  <span>data</span><span>:</span> <span>{</span>\n    <span>groceryList</span><span>:</span> <span>[</span>\n      <span>{</span> <span>id</span><span>:</span> <span>0</span><span>,</span> <span>text</span><span>:</span> <span>\"蔬菜\"</span> <span>}</span><span>,</span>\n      <span>{</span> <span>id</span><span>:</span> <span>1</span><span>,</span> <span>text</span><span>:</span> <span>\"奶酪\"</span> <span>}</span><span>,</span>\n      <span>{</span> <span>id</span><span>:</span> <span>2</span><span>,</span> <span>text</span><span>:</span> <span>\"随便其它什么人吃的东西\"</span> <span>}</span><span>,</span>\n    <span>]</span><span>,</span>\n  <span>}</span><span>,</span>\n<span>}</span><span>)</span><span>;</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>尽管这只是一个刻意设计的例子，但是我们已经设法将应用分割成了两个更小的单元。子单元通过 prop 接口与父单元进行了良好的解耦。我们现在可以进一步改进 <code>&lt;todo-item&gt;</code> 组件，提供更为复杂的模板和逻辑，而不会影响到父单元。</p>\n<p>在一个大型应用中，有必要将整个应用程序划分为组件，以使开发更易管理。在<a href=\"https://cn.vuejs.org/v2/guide/components.html\" target=\"_blank\" rel=\"noopener noreferrer\">后续教程</a>中我们将详述组件，不过这里有一个 (假想的) 例子，以展示使用了组件的应用模板是什么样的:</p>\n<div><pre><code><span><span><span>&lt;</span>div</span> <span>id</span><span><span>=</span><span>\"</span>app<span>\"</span></span><span>></span></span>\n  <span><span><span>&lt;</span>app-nav</span> <span>/></span></span>\n  <span><span><span>&lt;</span>app-view</span><span>></span></span>\n    <span><span><span>&lt;</span>app-sidebar</span> <span>/></span></span>\n    <span><span><span>&lt;</span>app-content</span> <span>/></span></span>\n  <span><span><span>&lt;/</span>app-view</span><span>></span></span>\n<span><span><span>&lt;/</span>div</span><span>></span></span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h3 id=\"与自定义元素的关系\" tabindex=\"-1\"> 与自定义元素的关系</h3>\n<p>您可能已经注意到 Vue 组件非常类似于<strong>自定义元素</strong>——它是 <a href=\"https://www.w3.org/wiki/WebComponents/\" target=\"_blank\" rel=\"noopener noreferrer\">Web 组件规范</a>的一部分，这是因为 Vue 的组件语法部分参考了该规范。例如 Vue 组件实现了 <a href=\"https://github.com/w3c/webcomponents/blob/gh-pages/proposals/Slots-Proposal.md\" target=\"_blank\" rel=\"noopener noreferrer\">Slot API</a> 与 <code>is</code> 特性。但是，还是有几个关键差别:</p>\n<ol>\n<li>\n<p>Web Components 规范已经完成并通过，但未被所有浏览器原生实现。目前 Safari 10.1+、Chrome 54+ 和 Firefox 63+ 原生支持 Web Components。相比之下，Vue 组件不需要任何 polyfill，并且在所有支持的浏览器 (IE9 及更高版本) 之下表现一致。必要时，Vue 组件也可以包装于原生自定义元素之内。</p>\n</li>\n<li>\n<p>Vue 组件提供了纯自定义元素所不具备的一些重要功能，最突出的是跨组件数据流、自定义事件通信以及构建工具集成。</p>\n</li>\n</ol>\n<p>虽然 Vue 内部没有使用自定义元素，不过在应用使用自定义元素、或以自定义元素形式发布时，<a href=\"https://custom-elements-everywhere.com/#vue\" target=\"_blank\" rel=\"noopener noreferrer\">依然有很好的互操作性</a>。Vue CLI 也支持将 Vue 组件构建成为原生的自定义元素。</p>\n<h2 id=\"创建一个-vue-实例\" tabindex=\"-1\"> 创建一个 Vue 实例</h2>\n<p><a href=\"https://learning.dcloud.io/#/?vid=2\" target=\"_blank\" rel=\"noopener noreferrer\">观看本节视频讲解</a></p>\n<p>每个 Vue 应用都是通过用 <code>Vue</code> 函数创建一个新的 <strong>Vue 实例</strong>开始的:</p>\n<div><pre><code><span>const</span> vm <span>=</span> <span>new</span> <span>Vue</span><span>(</span><span>{</span>\n  <span>// 选项</span>\n<span>}</span><span>)</span><span>;</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div></div></div><p>虽然没有完全遵循 <a href=\"https://zh.wikipedia.org/wiki/MVVM\" target=\"_blank\" rel=\"noopener noreferrer\">MVVM 模型</a>，但是 Vue 的设计也受到了它的启发。因此在文档中经常会使用 <code>vm</code> (ViewModel 的缩写) 这个变量名表示 Vue 实例。</p>\n<p>当创建一个 Vue 实例时，您可以传入一个<strong>选项对象</strong>。这篇教程主要描述的就是如何使用这些选项来创建您想要的行为。作为参考，您也可以在 <a href=\"https://cn.vuejs.org/v2/api/\" target=\"_blank\" rel=\"noopener noreferrer\">API 文档</a> 中浏览完整的选项列表。</p>\n<p>一个 Vue 应用由一个通过 <code>new Vue</code> 创建的<strong>根 Vue 实例</strong>，以及可选的嵌套的、可复用的组件树组成。举个例子，一个 todo 应用的组件树可以是这样的:</p>\n<div><pre><code>根实例\n└─ TodoList\n├─ TodoItem\n│ ├─ DeleteTodoButton\n│ └─ EditTodoButton\n└─ TodoListFooter\n├─ ClearTodosButton\n└─ TodoListStatistics\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>我们会在稍后的<a href=\"https://cn.vuejs.org/v2/guide/components.html\" target=\"_blank\" rel=\"noopener noreferrer\">组件系统</a>章节具体展开。不过现在，您只需要明白所有的 Vue 组件都是 Vue 实例，并且接受相同的选项对象 (一些根实例特有的选项除外)。</p>\n<h2 id=\"数据与方法\" tabindex=\"-1\"> 数据与方法</h2>\n<p><a href=\"https://learning.dcloud.io/#/?vid=3\" target=\"_blank\" rel=\"noopener noreferrer\">观看本节视频讲解</a></p>\n<p>当一个 Vue 实例被创建时，它将 <code>data</code> 对象中的所有的属性加入到 Vue 的<strong>响应式系统</strong>中。当这些属性的值发生改变时，视图将会产生“响应”，即匹配更新为新的值。</p>\n<div><pre><code><span>// 我们的数据对象</span>\n<span>const</span> data <span>=</span> <span>{</span> <span>a</span><span>:</span> <span>1</span> <span>}</span><span>;</span>\n\n<span>// 该对象被加入到一个 Vue 实例中</span>\n<span>const</span> vm <span>=</span> <span>new</span> <span>Vue</span><span>(</span><span>{</span>\n  <span>data</span><span>:</span> data<span>,</span>\n<span>}</span><span>)</span><span>;</span>\n\n<span>// 获得这个实例上的属性</span>\n<span>// 返回源数据中对应的字段</span>\nvm<span>.</span>a <span>==</span> data<span>.</span>a<span>;</span> <span>// => true</span>\n\n<span>// 设置属性也会影响到原始数据</span>\nvm<span>.</span>a <span>=</span> <span>2</span><span>;</span>\ndata<span>.</span>a<span>;</span> <span>// => 2</span>\n\n<span>// ……反之亦然</span>\ndata<span>.</span>a <span>=</span> <span>3</span><span>;</span>\nvm<span>.</span>a<span>;</span> <span>// => 3</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>当这些数据改变时，视图会进行重渲染。值得注意的是只有当实例被创建时就已经存在于 <code>data</code> 中的属性才是<strong>响应式</strong>的。也就是说如果您添加一个新的属性，比如:</p>\n<div><pre><code>vm<span>.</span>b <span>=</span> <span>\"hi\"</span><span>;</span>\n</code></pre><div aria-hidden=\"true\"><div></div></div></div><p>那么对 <code>b</code> 的改动将不会触发任何视图的更新。如果您知道您会在晚些时候需要一个属性，但是一开始它为空或不存在，那么您仅需要设置一些初始值。比如:</p>\n<div><pre><code><span>data</span><span>:</span> <span>{</span>\n  <span>newTodoText</span><span>:</span> <span>''</span><span>,</span>\n  <span>visitCount</span><span>:</span> <span>0</span><span>,</span>\n  <span>hideCompletedTodos</span><span>:</span> <span>false</span><span>,</span>\n  <span>todos</span><span>:</span> <span>[</span><span>]</span><span>,</span>\n  <span>error</span><span>:</span> <span>null</span>\n<span>}</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>这里唯一的例外是使用 <code>Object.freeze()</code>，这会阻止修改现有的属性，也意味着响应系统无法再<em>追踪</em>变化。</p>\n<div><pre><code><span>const</span> obj <span>=</span> <span>{</span>\n  <span>foo</span><span>:</span> <span>\"bar\"</span><span>,</span>\n<span>}</span><span>;</span>\n\nObject<span>.</span><span>freeze</span><span>(</span>obj<span>)</span><span>;</span>\n\n<span>new</span> <span>Vue</span><span>(</span><span>{</span>\n  <span>el</span><span>:</span> <span>\"#app\"</span><span>,</span>\n  <span>data</span><span>:</span> obj<span>,</span>\n<span>}</span><span>)</span><span>;</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><div><pre><code><span><span><span>&lt;</span>div</span> <span>id</span><span><span>=</span><span>\"</span>app<span>\"</span></span><span>></span></span>\n  <span><span><span>&lt;</span>p</span><span>></span></span>{{ foo }}<span><span><span>&lt;/</span>p</span><span>></span></span>\n  <span>&lt;!-- 这里的 `foo` 不会更新!  --></span>\n  <span><span><span>&lt;</span>button</span> <span><span>v-on:</span>click</span><span><span>=</span><span>\"</span>foo = <span>'</span>baz<span>'</span><span>\"</span></span><span>></span></span>Change it<span><span><span>&lt;/</span>button</span><span>></span></span>\n<span><span><span>&lt;/</span>div</span><span>></span></span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div></div></div><p>除了数据属性，Vue 实例还暴露了一些有用的实例属性与方法。它们都有前缀 <code>$</code>，以便与用户定义的属性区分开来。例如:</p>\n<div><pre><code><span>const</span> data <span>=</span> <span>{</span> <span>a</span><span>:</span> <span>1</span> <span>}</span><span>;</span>\n<span>const</span> vm <span>=</span> <span>new</span> <span>Vue</span><span>(</span><span>{</span>\n  <span>el</span><span>:</span> <span>\"#example\"</span><span>,</span>\n  <span>data</span><span>:</span> data<span>,</span>\n<span>}</span><span>)</span><span>;</span>\n\nvm<span>.</span>$data <span>===</span> data<span>;</span> <span>// => true</span>\nvm<span>.</span>$el <span>===</span> document<span>.</span><span>getElementById</span><span>(</span><span>\"example\"</span><span>)</span><span>;</span> <span>// => true</span>\n\n<span>// $watch 是一个实例方法</span>\nvm<span>.</span><span>$watch</span><span>(</span><span>\"a\"</span><span>,</span> <span>function</span> <span>(</span><span>newValue<span>,</span> oldValue</span><span>)</span> <span>{</span>\n  <span>// 这个回调将在 `vm.a` 改变后调用</span>\n<span>}</span><span>)</span><span>;</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>以后您可以在 <a href=\"https://cn.vuejs.org/v2/api/#%E5%AE%9E%E4%BE%8B%E5%B1%9E%E6%80%A7\" target=\"_blank\" rel=\"noopener noreferrer\">API 参考</a>中查阅到完整的实例属性和方法的列表。</p>\n<h2 id=\"实例生命周期钩子\" tabindex=\"-1\"> 实例生命周期钩子</h2>\n<p><a href=\"https://learning.dcloud.io/#/?vid=4\" target=\"_blank\" rel=\"noopener noreferrer\">观看本节视频讲解</a></p>\n<p>每个 Vue 实例在被创建时都要经过一系列的初始化过程——例如，需要设置数据监听、编译模板、将实例挂载到 DOM 并在数据变化时更新 DOM 等。同时在这个过程中也会运行一些叫做<strong>生命周期钩子</strong>的函数，这给了用户在不同阶段添加自己的代码的机会。</p>\n<p>比如 <a href=\"https://cn.vuejs.org/v2/api/#created\" target=\"_blank\" rel=\"noopener noreferrer\"><code>created</code></a> 钩子可以用来在一个实例被创建之后执行代码:</p>\n<div><pre><code><span>new</span> <span>Vue</span><span>(</span><span>{</span>\n  <span>data</span><span>:</span> <span>{</span>\n    <span>a</span><span>:</span> <span>1</span><span>,</span>\n  <span>}</span><span>,</span>\n  <span>created</span><span>:</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>\n    <span>// `this` 指向 vm 实例</span>\n    console<span>.</span><span>log</span><span>(</span><span>\"a is: \"</span> <span>+</span> <span>this</span><span>.</span>a<span>)</span><span>;</span>\n  <span>}</span><span>,</span>\n<span>}</span><span>)</span><span>;</span>\n<span>// => \"a is: 1\"</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>也有一些其它的钩子，在实例生命周期的不同阶段被调用，如 <a href=\"https://cn.vuejs.org/v2/api/#mounted\" target=\"_blank\" rel=\"noopener noreferrer\"><code>mounted</code></a>、<a href=\"https://cn.vuejs.org/v2/api/#updated\" target=\"_blank\" rel=\"noopener noreferrer\"><code>updated</code></a> 和 <a href=\"https://cn.vuejs.org/v2/api/#destroyed\" target=\"_blank\" rel=\"noopener noreferrer\"><code>destroyed</code></a>。生命周期钩子的 <code>this</code> 上下文指向调用它的 Vue 实例。</p>\n<div><p>提示</p>\n<p>不要在选项属性或回调上使用<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Arrow_functions\" target=\"_blank\" rel=\"noopener noreferrer\">箭头函数</a>，比如 <code>created: () =&gt; console.log(this.a)</code> 或 <code>vm.$watch('a', newValue =&gt; this.myMethod())</code>。因为箭头函数并没有 <code>this</code>，<code>this</code> 会作为变量一直向上级词法作用域查找，直至找到为止，经常导致 <code>Uncaught TypeError: Cannot read property of undefined</code> 或 <code>Uncaught TypeError: this.myMethod is not a function</code> 之类的错误。</p>\n</div>\n<h2 id=\"生命周期图示\" tabindex=\"-1\"> 生命周期图示</h2>\n<p>下图展示了实例的生命周期。您不需要立马弄明白所有的东西，不过随着您的不断学习和使用，它的参考价值会越来越高。</p>\n<p><img src=\"@source/code/vue/assets/lifecycle.png\" alt=\"Vue 实例生命周期\"></p>\n",
      "date_published": "2022-08-20T08:54:00.000Z",
      "date_modified": "2022-08-20T08:54:00.000Z",
      "authors": [],
      "tags": [
        "Vue"
      ]
    },
    {
      "title": "开发环境安装",
      "url": "https://github.com/MisterChen9527/code/vue/install.html",
      "id": "https://github.com/MisterChen9527/code/vue/install.html",
      "content_html": "<h2 id=\"环境准备\" tabindex=\"-1\"> 环境准备</h2>\n<h3 id=\"vs-code-安装\" tabindex=\"-1\"> VS Code 安装</h3>\n<ul>\n<li><a href=\"/software/vscode/install.html\">安装 VS Code</a></li>\n</ul>\n<h4 id=\"开发指南\" tabindex=\"-1\"> 开发指南</h4>\n<ol>\n<li>\n<p>使用 VS Code 打开项目文件夹。</p>\n<div><p>提示</p>\n<p>请打开 VS Code 选择菜单栏中的 “文件-打开文件夹”，或在文件夹上 “右键——使用 VS Code 打开” 或在文件夹内部空白处 “右键——使用 VS Code 打开”。</p>\n</div>\n</li>\n<li>\n<p>打开终端(快捷键 <code>Ctrl + `</code> )。</p>\n</li>\n<li>\n<p>在终端中输入相关指令即可执行相关功能。</p>\n</li>\n</ol>\n<h3 id=\"git-安装\" tabindex=\"-1\"> Git 安装</h3>\n<ul>\n<li><a href=\"/software/git/install.html\">安装 Git</a></li>\n</ul>\n<h3 id=\"node-js-环境安装\" tabindex=\"-1\"> Node.js 环境安装</h3>\n<p>请先安装 Node.js 并将 npm 与 Node.js 添加至 path。</p>\n<ul>\n<li>\n<p><a href=\"/code/node-js/install.html\">安装 Node.js</a></p>\n</li>\n<li>\n<p><a href=\"/code/windows/add-path.html\">添加到 path</a></p>\n</li>\n</ul>\n<h2 id=\"初始化版本库、下载网页代码并安装-npm-模块\" tabindex=\"-1\"> 初始化版本库、下载网页代码并安装 npm 模块</h2>\n<ol>\n<li>\n<p>打开文件管理器窗口找到合适位置，并在地址栏输入 cmd，以在当前界面打开终端。</p>\n</li>\n<li>\n<p>使用 <code>git clone git@github.com:Mister-Hope/vue-template.git</code> 克隆模板。</p>\n</li>\n<li>\n<p>使用 VS Code 打开刚刚克隆出来的文件夹，按下 <code>Ctrl + `</code> 打开终端。</p>\n</li>\n<li>\n<p>使用 <code>npm install</code> 命令安装模块。</p>\n</li>\n</ol>\n<div><p>提示</p>\n<p>npm 模块介绍</p>\n<p>此处待补充。</p>\n</div>\n<h2 id=\"开发工具安装\" tabindex=\"-1\"> 开发工具安装</h2>\n<p>Vue 官方提供的浏览器插件 VueTools 可以更好的帮助开发。</p>\n<p>使用 VPN 用 Chrome 打开<a href=\"https://chrome.google.com/webstore/detail/nhdogjmejiglipccpnnnanhbledajbpd\" target=\"_blank\" rel=\"noopener noreferrer\">安装网址</a>，安装 VueTools 开发工具</p>\n",
      "date_published": "2022-08-20T08:54:00.000Z",
      "date_modified": "2022-08-20T08:54:00.000Z",
      "authors": [],
      "tags": [
        "Vue"
      ]
    },
    {
      "title": "Vue 单文件组件",
      "url": "https://github.com/MisterChen9527/code/vue/vue.html",
      "id": "https://github.com/MisterChen9527/code/vue/vue.html",
      "content_html": "<h2 id=\"介绍\" tabindex=\"-1\"> 介绍</h2>\n<p>Vue 的单文件组件 (即 <code>*.vue</code> 文件，简称 <strong>SFC</strong>) 是一种特殊的文件格式，使我们能够将一个 Vue 组件的模板、逻辑与样式封装在单个文件中。下面是一个单文件组件的示例：</p>\n<div><pre><code><span><span><span>&lt;</span>script</span><span>></span></span><span><span>\n<span>export</span> <span>default</span> <span>{</span>\n  <span>data</span><span>(</span><span>)</span> <span>{</span>\n    <span>return</span> <span>{</span>\n      <span>greeting</span><span>:</span> <span>\"Hello World!\"</span><span>,</span>\n    <span>}</span><span>;</span>\n  <span>}</span><span>,</span>\n<span>}</span><span>;</span>\n</span></span><span><span><span>&lt;/</span>script</span><span>></span></span>\n\n<span><span><span>&lt;</span>template</span><span>></span></span>\n  <span><span><span>&lt;</span>p</span> <span>class</span><span><span>=</span><span>\"</span>greeting<span>\"</span></span><span>></span></span>{{ greeting }}<span><span><span>&lt;/</span>p</span><span>></span></span>\n<span><span><span>&lt;/</span>template</span><span>></span></span>\n\n<span><span><span>&lt;</span>style</span><span>></span></span><span><span>\n<span>.greeting</span> <span>{</span>\n  <span>color</span><span>:</span> red<span>;</span>\n  <span>font-weight</span><span>:</span> bold<span>;</span>\n<span>}</span>\n</span></span><span><span><span>&lt;/</span>style</span><span>></span></span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>如你所见，Vue 的单文件组件是 HTML、CSS 和 JavaScript 三种元素的自然延伸。<code>&lt;template&gt;</code>、<code>&lt;script&gt;</code> 和 <code>&lt;style&gt;</code> 三个块在同一个文件中封装、组合了组件的视图、逻辑和样式。</p>\n<h2 id=\"总览\" tabindex=\"-1\"> 总览</h2>\n<h2 id=\"总览-overview\" tabindex=\"-1\"> 总览 {#overview}</h2>\n<p>一个 Vue 单文件组件 (SFC)，通常使用 <code>*.vue</code> 作为文件扩展名，它是一种使用了类似 HTML 语法的自定义文件格式，用于定义 Vue 组件。一个 Vue 单文件组件在语法上是兼容 HTML 的。</p>\n<p>每一个 <code>*.vue</code> 文件都由三种顶层语块构成：<code>&lt;template&gt;</code>、<code>&lt;script&gt;</code> 和 <code>&lt;style&gt;</code>，以及一些其他的自定义块：</p>\n<div><pre><code><span><span><span>&lt;</span>template</span><span>></span></span>\n  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>\"</span>example<span>\"</span></span><span>></span></span>{{ msg }}<span><span><span>&lt;/</span>div</span><span>></span></span>\n<span><span><span>&lt;/</span>template</span><span>></span></span>\n\n<span><span><span>&lt;</span>script</span><span>></span></span><span><span>\n<span>export</span> <span>default</span> <span>{</span>\n  <span>data</span><span>(</span><span>)</span> <span>{</span>\n    <span>return</span> <span>{</span>\n      <span>msg</span><span>:</span> <span>\"Hello world!\"</span><span>,</span>\n    <span>}</span><span>;</span>\n  <span>}</span><span>,</span>\n<span>}</span><span>;</span>\n</span></span><span><span><span>&lt;/</span>script</span><span>></span></span>\n\n<span><span><span>&lt;</span>style</span><span>></span></span><span><span>\n<span>.example</span> <span>{</span>\n  <span>color</span><span>:</span> red<span>;</span>\n<span>}</span>\n</span></span><span><span><span>&lt;/</span>style</span><span>></span></span>\n\n<span><span><span>&lt;</span>custom1</span><span>></span></span>\n  This could be e.g. documentation for the component.\n<span><span><span>&lt;/</span>custom1</span><span>></span></span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id=\"相应语言块-language-blocks\" tabindex=\"-1\"> 相应语言块 {#language-blocks}</h2>\n<h3 id=\"template-template\" tabindex=\"-1\"> <code>&lt;template&gt;</code> {#template}</h3>\n<ul>\n<li>\n<p>每个 <code>*.vue</code> 文件最多可以包含一个顶层 <code>&lt;template&gt;</code> 块。</p>\n</li>\n<li>\n<p>语块包裹的内容将会被提取、传递给 <code>@vue/compiler-dom</code>，预编译为 JavaScript 渲染函数，并附在导出的组件上作为其 <code>render</code> 选项。</p>\n</li>\n</ul>\n<h3 id=\"script-script\" tabindex=\"-1\"> <code>&lt;script&gt;</code> {#script}</h3>\n<ul>\n<li>\n<p>每个 <code>*.vue</code> 文件最多可以包含一个 <code>&lt;script&gt;</code> 块。(使用 <a href=\"/api/sfc-script-setup.html\"><code>&lt;script setup&gt;</code></a> 的情况除外)</p>\n</li>\n<li>\n<p>这个脚本代码块将作为 ES 模块执行。</p>\n</li>\n<li>\n<p><strong>默认导出</strong>应该是 Vue 的组件选项对象，可以是一个对象字面量或是 <a href=\"/api/general.html#definecomponent\">defineComponent</a> 函数的返回值。</p>\n</li>\n</ul>\n<h3 id=\"script-setup-script-setup\" tabindex=\"-1\"> <code>&lt;script setup&gt;</code> {#script-setup}</h3>\n<ul>\n<li>\n<p>每个 <code>*.vue</code> 文件最多可以包含一个 <code>&lt;script setup&gt;</code>。(不包括一般的 <code>&lt;script&gt;</code>)</p>\n</li>\n<li>\n<p>这个脚本块将被预处理为组件的 <code>setup()</code> 函数，这意味着它将<strong>为每一个组件实例</strong>都执行。<code>&lt;script setup&gt;</code> 中的顶层绑定都将自动暴露给模板。要了解更多细节，请看 <a href=\"/api/sfc-script-setup\"><code>&lt;script setup&gt;</code> 的专门文档</a>。</p>\n</li>\n</ul>\n<h3 id=\"style-style\" tabindex=\"-1\"> <code>&lt;style&gt;</code> {#style}</h3>\n<ul>\n<li>\n<p>每个 <code>*.vue</code> 文件可以包含多个 <code>&lt;style&gt;</code> 标签。</p>\n</li>\n<li>\n<p>一个 <code>&lt;style&gt;</code> 标签可以使用 <code>scoped</code> 或 <code>module</code> attribute (查看 <a href=\"/api/sfc-css-features\">SFC 样式功能</a>了解更多细节) 来帮助封装当前组件的样式。使用了不同封装模式的多个 <code>&lt;style&gt;</code> 标签可以被混合入同一个组件。</p>\n</li>\n</ul>\n<h3 id=\"自定义块-custom-blocks\" tabindex=\"-1\"> 自定义块 {#custom-blocks}</h3>\n<p>在一个 <code>*.vue</code> 文件中可以为任何项目特定需求使用额外的自定义块。举个例子，一个用作写文档的 <code>&lt;docs&gt;</code> 块。这里是一些自定义块的真实用例：</p>\n<ul>\n<li><a href=\"https://gridsome.org/docs/querying-data/\" target=\"_blank\" rel=\"noopener noreferrer\">Gridsome：<code>&lt;page-query&gt;</code></a></li>\n<li><a href=\"https://github.com/wheatjs/vite-plugin-vue-gql\" target=\"_blank\" rel=\"noopener noreferrer\">vite-plugin-vue-gql：<code>&lt;gql&gt;</code></a></li>\n<li><a href=\"https://github.com/intlify/bundle-tools/tree/main/packages/vite-plugin-vue-i18n#i18n-custom-block\" target=\"_blank\" rel=\"noopener noreferrer\">vue-i18n：<code>&lt;i18n&gt;</code></a></li>\n</ul>\n<p>自定义块的处理需要依赖工具链。如果你想要在构建中集成你的自定义语块，请参见<a href=\"/guide/scaling-up/tooling.html#sfc-custom-block-integrations\">相关工具链指南</a>获取更多细节。</p>\n<h2 id=\"自动名称推导-automatic-name-inference\" tabindex=\"-1\"> 自动名称推导 {#automatic-name-inference}</h2>\n<p>SFC 在以下场景中会根据<strong>文件名</strong>自动推导其组件名：</p>\n<ul>\n<li>开发警告信息格式</li>\n<li>DevTools 审阅</li>\n<li>递归组件自引用。例如一个名为 <code>FooBar.vue</code> 的组件可以在模板中通过 <code>&lt;FooBar/&gt;</code> 引用自己。(同名情况下) 这比明确注册/导入的组件优先级低。</li>\n</ul>\n<h2 id=\"预处理器-pre-processors\" tabindex=\"-1\"> 预处理器 {#pre-processors}</h2>\n<p>代码块可以使用 <code>lang</code> 这个 attribute 来声明预处理器语言，最常见的用例就是对 <code>&lt;script&gt;</code> 块使用 TypeScript：</p>\n<div><pre><code>&lt;script lang=&quot;ts&quot;&gt;\n  // use TypeScript\n&lt;/script&gt;\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div></div></div><p><code>lang</code> 在任意块上都能使用，比如我们可以在 <code>&lt;style&gt;</code> 标签上使用 <a href=\"https://sass-lang.com/\" target=\"_blank\" rel=\"noopener noreferrer\">SASS</a> 或是 <code>&lt;template&gt;</code> 上使用 <a href=\"https://pugjs.org/api/getting-started.html\" target=\"_blank\" rel=\"noopener noreferrer\">Pug</a>：</p>\n<div><pre><code>&lt;template lang=&quot;pug&quot;&gt;\np {{ msg }}\n&lt;/template&gt;\n\n&lt;style lang=&quot;scss&quot;&gt;\n  $primary-color: #333;\n  body {\n    color: $primary-color;\n  }\n&lt;/style&gt;\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>注意对各种不同的预处理的集成会导致工具链的不同，你应该查看相应的工具链文档了解细节：</p>\n<ul>\n<li><a href=\"https://vitejs.dev/guide/features.html#css-pre-processors\" target=\"_blank\" rel=\"noopener noreferrer\">Vite</a></li>\n<li><a href=\"https://cli.vuejs.org/guide/css.html#pre-processors\" target=\"_blank\" rel=\"noopener noreferrer\">Vue CLI</a></li>\n<li><a href=\"https://vue-loader.vuejs.org/guide/pre-processors.html#using-pre-processors\" target=\"_blank\" rel=\"noopener noreferrer\">webpack + vue-loader</a></li>\n</ul>\n<h2 id=\"src-导入-src-imports\" tabindex=\"-1\"> Src 导入 {#src-imports}</h2>\n<p>如果你更喜欢将 <code>*.vue</code> 组件分散到多个文件中，可以为一个语块使用 <code>src</code> 这个 attribute 来导入一个外部文件：</p>\n<div><pre><code><span><span><span>&lt;</span>template</span> <span>src</span><span><span>=</span><span>\"</span>./template.html<span>\"</span></span><span>></span></span><span><span><span>&lt;/</span>template</span><span>></span></span>\n<span><span><span>&lt;</span>style</span> <span>src</span><span><span>=</span><span>\"</span>./style.css<span>\"</span></span><span>></span></span><span></span><span><span><span>&lt;/</span>style</span><span>></span></span>\n<span><span><span>&lt;</span>script</span> <span>src</span><span><span>=</span><span>\"</span>./script.js<span>\"</span></span><span>></span></span><span></span><span><span><span>&lt;/</span>script</span><span>></span></span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div></div></div><p>请注意 <code>src</code> 导入和 Webpack 的模块请求遵循相同的路径解析规则，这意味着：</p>\n<ul>\n<li>相对路径需要以 <code>./</code> 开头</li>\n<li>你也可以从 npm 依赖中导入资源</li>\n</ul>\n<div><pre><code><span>&lt;!-- 从所安装的 \"todomvc-app-css\" npm 包中导入一个文件 --></span>\n<span><span><span>&lt;</span>style</span> <span>src</span><span><span>=</span><span>\"</span>todomvc-app-css/index.css<span>\"</span></span> <span>/></span></span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div></div></div><p><code>src</code> 导入对自定义语块也同样适用：</p>\n<div><pre><code><span><span><span>&lt;</span>unit-test</span> <span>src</span><span><span>=</span><span>\"</span>./unit-test.js<span>\"</span></span><span>></span></span>\n<span><span><span>&lt;/</span>unit-test</span><span>></span></span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div></div></div><h2 id=\"注释-comments\" tabindex=\"-1\"> 注释 {#comments}</h2>\n<p>在每一个语块中你都可以按照相应语言 (HTML、CSS、JavaScript 和 Pug 等等) 的语法书写注释。对于顶层注释，请使用 HTML 的注释语法 <code>&lt;!-- comment contents here --&gt;</code></p>\n",
      "date_published": "2022-08-20T08:54:00.000Z",
      "date_modified": "2022-08-20T08:54:00.000Z",
      "authors": [],
      "tags": [
        "Vue"
      ]
    },
    {
      "title": "网页入门",
      "url": "https://github.com/MisterChen9527/code/website/",
      "id": "https://github.com/MisterChen9527/code/website/",
      "summary": "网页需要三件套: HTML、CSS 和 JavaScript。\n\nHTML 定义了网页的内容\nCSS 描述了网页的样式\nJavaScript 编写网页的行为\n\n",
      "content_html": "<p>网页需要三件套: <strong>HTML</strong>、<strong>CSS</strong> 和 <strong>JavaScript</strong>。</p>\n<ol>\n<li>HTML 定义了网页的内容</li>\n<li>CSS 描述了网页的样式</li>\n<li>JavaScript 编写网页的行为</li>\n</ol>\n\n<div><p>提示</p>\n<p>一个大型的网站，很少是直接使用原生代码写的。</p>\n<p>最新的网站大多数都是用三大框架(、、)搭建，并引入 npm 上的 UI 库编写而成。</p>\n<p>稍微老的网站会使用其他框架作为辅助，比如、等。</p>\n</div>\n<div><p>网页标准指定</p>\n<p>互联网网页标准由 W3C 组织制定，它的全称是万维网联盟组织。</p>\n</div>\n<h2 id=\"html\" tabindex=\"-1\"> HTML</h2>\n<p>HTML 指的是超文本标记语言 (Hyper Text Markup Language)，描述了网页的骨架(具体结构)。</p>\n<ul>\n<li><a href=\"/code/website/html/\">HTML 教程</a></li>\n</ul>\n<h2 id=\"css\" tabindex=\"-1\"> CSS</h2>\n<p>CSS 指层叠样式表 (Cascading Style Sheets)，声明了网页的样式(具体布局)。</p>\n<ul>\n<li><a href=\"/code/website/css/\">CSS 教程</a></li>\n</ul>\n<h2 id=\"emmet\" tabindex=\"-1\"> Emmet</h2>\n<p>Emmet 是一种快速输入 HTML 和 CSS 的语法。</p>\n<ul>\n<li><a href=\"/code/website/emmet/\">Emmet 用法介绍</a></li>\n</ul>\n<h2 id=\"javascript\" tabindex=\"-1\"> JavaScript</h2>\n<p>JavaScript 是一种编程语言，声明了网页的交互逻辑。</p>\n<p>JavaScript 是一种轻量级的编程语言，为可插入 HTML 页面的编程代码。所有现代的 HTML 页面都使用 JavaScript。</p>\n<ul>\n<li><a href=\"/code/website/js.html\">JS 教程</a></li>\n</ul>\n<h3 id=\"typescript\" tabindex=\"-1\"> TypeScript</h3>\n<p>TypeScript 是 JavaScript 的一个超集，使得 JS 变成了一种强定义语言。TypeScript 由于其诸多优良特性，目前在前端的份额越来越大。</p>\n<ul>\n<li><a href=\"/code/language/typescript/\">TypeScript 教程</a></li>\n</ul>\n<h2 id=\"node-js\" tabindex=\"-1\"> Node.js</h2>\n<p>在深入了解并进行前端开发后，就避不开 Node。</p>\n<p>Node.js 是一款全球使用广泛的框架，可以用在前端与后端上，拥有大量的模块。Node.js 主要以其丰富并及其容易导入的 Node.js package，以及其方便管理 npm (Node.js Package Manager)闻名。</p>\n<ul>\n<li><a href=\"/code/node-js/\">Node.js 教程</a></li>\n</ul>\n<h2 id=\"历史前端框架\" tabindex=\"-1\"> 历史前端框架</h2>\n<h3 id=\"jquery\" tabindex=\"-1\"> jQuery</h3>\n<p>jQuery 是一个 JavaScript 库，极大地简化了 JavaScript 编程，很容易学习。</p>\n<p>jQuery 的优势在于它能够在互联网发展早期兼容各式各样的浏览器，并轻松的选定与操作 DOM。</p>\n<p>由于 MVVM 的兴起，目前 jQuery 已逐步被前端三大框架所取代。</p>\n<ul>\n<li>\n<p><a href=\"/code/website/jQuery/\">jQuery 教程</a></p>\n</li>\n<li>\n<p><a href=\"http://www.w3school.com.cn/jquery/index.asp\" target=\"_blank\" rel=\"noopener noreferrer\">W3School</a></p>\n</li>\n<li>\n<p><a href=\"https://www.runoob.com/jquery/jquery-tutorial.html\" target=\"_blank\" rel=\"noopener noreferrer\">菜鸟教程</a></p>\n</li>\n</ul>\n<h3 id=\"bootstrap4\" tabindex=\"-1\"> Bootstrap4</h3>\n<p>Bootstrap 是全球最受欢迎的前端组件库，用于开发响应式布局、移动设备优先的 WEB 项目。</p>\n<p>Bootstrap 是一套用于 HTML、CSS 和 JS 开发的开源工具集。利用提供的 Sass 变量和大量 mixin、响应式栅格系统、可扩展的预制组件、基于 jQuery 的强大的插件系统，能够快速为您的想法开发出原型或者构建整个 app 。</p>\n<ul>\n<li>\n<p><a href=\"https://getbootstrap.com/docs/4.1/getting-started/introduction/\" target=\"_blank\" rel=\"noopener noreferrer\">bootstrap 官方文档</a></p>\n</li>\n<li>\n<p><a href=\"https://v4.bootcss.com/docs/4.0/getting-started/introduction/\" target=\"_blank\" rel=\"noopener noreferrer\">bootstrap 4.0 中文文档</a></p>\n</li>\n</ul>\n<h2 id=\"现代前端框架\" tabindex=\"-1\"> 现代前端框架</h2>\n<h3 id=\"vue\" tabindex=\"-1\"> Vue</h3>\n<p>Vue 是一套轻量化的前端渐进式框架框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。</p>\n<p>Vue 与 React、Angular 一起合称前端三大框架。</p>\n<ul>\n<li>\n<p><a href=\"/code/vue/\">Vue 学习教程</a></p>\n</li>\n<li>\n<p><a href=\"https://cn.vuejs.org/v2/guide/\" target=\"_blank\" rel=\"noopener noreferrer\">Vue 官方文档</a></p>\n</li>\n</ul>\n<h3 id=\"react\" tabindex=\"-1\"> React</h3>\n<ul>\n<li><a href=\"/code/react/\">React 教程</a></li>\n</ul>\n<h3 id=\"angular\" tabindex=\"-1\"> Angular</h3>\n<ul>\n<li><a href=\"/code/Angular/\">Angular 教程</a></li>\n</ul>\n<h2 id=\"其他文档\" tabindex=\"-1\"> 其他文档</h2>\n<ul>\n<li><a href=\"/code/website/https.html\">HTTPS 介绍</a></li>\n</ul>\n",
      "date_published": "2019-09-01T00:00:00.000Z",
      "date_modified": "2022-08-20T08:54:00.000Z",
      "authors": [],
      "tags": [
        "前端"
      ]
    },
    {
      "title": "Http 与 Https 介绍",
      "url": "https://github.com/MisterChen9527/code/website/https.html",
      "id": "https://github.com/MisterChen9527/code/website/https.html",
      "content_html": "<h2 id=\"什么是-http-协议\" tabindex=\"-1\"> 什么是 HTTP 协议</h2>\n<p>HTTP 协议全称 Hyper Text Transfer Protocol，翻译过来就是超文本传输协议，位于 TCP/IP 四层模型当中的应用层。</p>\n<p><img src=\"@source/code/website/assets/http1.jpg\" alt=\"Http 漫画\"></p>\n<p>HTTP 协议通过 <strong>请求/响应</strong> 的方式，在客户端和服务端之间进行通信。</p>\n<p><img src=\"@source/code/website/assets/http2.jpg\" alt=\"Http 漫画\"></p>\n<p>这一切看起来很美好，但是 HTTP 协议有一个致命的缺点: <strong>不够安全</strong>。</p>\n<p>HTTP 协议的信息传输完全以明文方式，不做任何加密，相当于是在网络上“裸奔”。这样会导致什么问题呢? 让我们打一个比方:</p>\n<p>小灰是客户端，小灰的同事小红是服务端，有一天小灰试图给小红发送请求。</p>\n<p><img src=\"@source/code/website/assets/http3.jpg\" alt=\"Http 漫画\"></p>\n<p>但是，由于传输信息是明文，这个信息有可能被某个中间人恶意截获甚至篡改。这种行为叫做<strong>中间人攻击</strong>。</p>\n<p><img src=\"@source/code/website/assets/http4.jpg\" alt=\"Http 漫画\"></p>\n<p><img src=\"@source/code/website/assets/http5.jpg\" alt=\"Http 漫画\"></p>\n<p><img src=\"@source/code/website/assets/http6.jpg\" alt=\"Http 漫画\"></p>\n<p>如何进行加密呢?</p>\n<p>小灰和小红可以事先约定一种<strong>对称加密</strong>方式，并且约定一个随机生成的密钥。后续的通信中，信息发送方都使用密钥对信息加密，而信息接收方通过同样的密钥对信息解密。</p>\n<p><img src=\"@source/code/website/assets/http7.jpg\" alt=\"Http 漫画\"></p>\n<p><img src=\"@source/code/website/assets/http8.jpg\" alt=\"Http 漫画\"></p>\n<p>这样做是不是就绝对安全了呢? 并不是。</p>\n<p>虽然我们在后续的通信中对明文进行了加密，但是第一次约定加密方式和密钥的通信仍然是明文，如果第一次通信就已经被拦截了，那么密钥就会泄露给中间人，中间人仍然可以解密后续所有的通信内容。</p>\n<p><img src=\"@source/code/website/assets/http9.jpg\" alt=\"Http 漫画\"></p>\n<p>这可怎么办呢? 别担心，我们可以使用<strong>非对称加密</strong>，为密钥的传输做一层额外的保护。</p>\n<p>非对称加密的一组秘钥对中，包含一个公钥和一个私钥。明文既可以用公钥加密，用私钥解密；也可以用私钥加密，用公钥解密。</p>\n<p>在小灰和小红建立通信的时候，小红首先把自己的公钥 Key1 发给小灰:</p>\n<p><img src=\"@source/code/website/assets/http10.jpg\" alt=\"Http 漫画\"></p>\n<p>收到小红的公钥以后，小灰自己生成一个用于对称加密的密钥 Key2，并且用刚才接收的公钥 Key1 对 Key2 进行加密(这里有点绕)，发送给小红:</p>\n<p><img src=\"@source/code/website/assets/http11.jpg\" alt=\"Http 漫画\"></p>\n<p>小红利用自己非对称加密的私钥，解开了公钥 Key1 的加密，获得了 Key2 的内容。从此以后，两人就可以利用 Key2 进行对称加密的通信了。</p>\n<p><img src=\"@source/code/website/assets/http12.jpg\" alt=\"Http 漫画\"></p>\n<p>在通信过程中，即使中间人在一开始就截获了公钥 Key1，由于不知道私钥是什么，也无从解密。</p>\n<p><img src=\"@source/code/website/assets/http13.jpg\" alt=\"Http 漫画\"></p>\n<p><img src=\"@source/code/website/assets/http14.jpg\" alt=\"Http 漫画\"></p>\n<p>是什么坏主意呢? 中间人虽然不知道小红的私钥是什么，但是在截获了小红的公钥 Key1 之后，却可以偷天换日，自己另外生成一对公钥私钥，把自己的公钥 Key3 发送给小灰。</p>\n<p><img src=\"@source/code/website/assets/http15.jpg\" alt=\"Http 漫画\"></p>\n<p>小灰不知道公钥被偷偷换过，以为 Key3 就是小红的公钥。于是按照先前的流程，用 Key3 加密了自己生成的对称加密密钥 Key2，发送给小红。</p>\n<p>这一次通信再次被中间人截获，中间人先用自己的私钥解开了 Key3 的加密，获得 Key2，然后再用当初小红发来的 Key1 重新加密，再发给小红。</p>\n<p><img src=\"@source/code/website/assets/http16.jpg\" alt=\"Http 漫画\"></p>\n<p>这样一来，两个人后续的通信尽管用 Key2 做了对称加密，但是中间人已经掌握了 Key2，所以可以轻松进行解密。</p>\n<p><img src=\"@source/code/website/assets/http17.jpg\" alt=\"Http 漫画\"></p>\n<p><img src=\"@source/code/website/assets/http18.jpg\" alt=\"Http 漫画\"></p>\n<p>是什么解决方案呢? 难道再把公钥进行一次加密吗? 这样只会陷入鸡生蛋蛋生鸡，永无止境的困局。</p>\n<p>这时候，我们有必要引入第三方，一个权威的证书颁发机构(CA)来解决。</p>\n<p>到底什么是证书呢? 证书包含如下信息:</p>\n<p><img src=\"@source/code/website/assets/http19.jpg\" alt=\"Http 漫画\"></p>\n<p>为了便于说明，我们这里做了简化，只列出了一些关键信息。至于这些证书信息的用处，我们看看具体的通信流程就能够弄明白了。</p>\n<p>流程如下:</p>\n<ol>\n<li>\n<p>作为服务端的小红，首先把自己的公钥发给证书颁发机构，向证书颁发机构申请证书。</p>\n<p><img src=\"@source/code/website/assets/http20.jpg\" alt=\"Http 漫画\"></p>\n</li>\n<li>\n<p>证书颁发机构自己也有一对公钥私钥。机构利用自己的私钥来加密 Key1，并且通过服务端网址等信息生成一个证书签名，证书签名同样经过机构的私钥加密。证书制作完成后，机构把证书发送给了服务端小红。</p>\n<p><img src=\"@source/code/website/assets/http21.jpg\" alt=\"Http 漫画\"></p>\n</li>\n<li>\n<p>当小灰向小红请求通信的时候，小红不再直接返回自己的公钥，而是把自己申请的证书返回给小灰。</p>\n<p><img src=\"@source/code/website/assets/http22.jpg\" alt=\"Http 漫画\"></p>\n</li>\n<li>\n<p>小灰收到证书以后，要做的第一件事情是验证证书的真伪。需要说明的是，各大浏览器和操作系统已经维护了所有权威证书机构的名称和公钥。所以小灰只需要知道是</p>\n<p>哪个机构颁布的证书，就可以从本地找到对应的机构公钥，解密出证书签名。</p>\n<p>接下来，小灰按照同样的签名规则，自己也生成一个证书签名，如果两个签名一致，说明证书是有效的。</p>\n<p>验证成功后，小灰就可以放心地再次利用机构公钥，解密出服务端小红的公钥 Key1。</p>\n<p><img src=\"@source/code/website/assets/http23.jpg\" alt=\"Http 漫画\"></p>\n</li>\n<li>\n<p>像之前一样，小灰生成自己的对称加密密钥 Key2，并且用服务端公钥 Key1 加密 Key2，发送给小红。</p>\n<p><img src=\"@source/code/website/assets/http24.jpg\" alt=\"Http 漫画\"></p>\n</li>\n<li>\n<p>最后，小红用自己的私钥解开加密，得到对称加密密钥 Key2。于是两人开始用 Key2 进行对称加密的通信。</p>\n<p><img src=\"@source/code/website/assets/http25.jpg\" alt=\"Http 漫画\"></p>\n</li>\n</ol>\n<p>在这样的流程下，我们不妨想一想，中间人是否还具有使坏的空间呢?</p>\n<p><img src=\"@source/code/website/assets/http26.jpg\" alt=\"Http 漫画\"></p>\n<p><img src=\"@source/code/website/assets/http27.jpg\" alt=\"Http 漫画\"></p>\n<p><img src=\"@source/code/website/assets/http28.jpg\" alt=\"Http 漫画\"></p>\n<p><img src=\"@source/code/website/assets/http29.jpg\" alt=\"Http 漫画\"></p>\n<p><img src=\"@source/code/website/assets/http30.jpg\" alt=\"Http 漫画\"></p>\n<p><img src=\"@source/code/website/assets/http31.jpg\" alt=\"Http 漫画\"></p>\n<p><img src=\"@source/code/website/assets/http32.jpg\" alt=\"Http 漫画\"></p>\n<div><p>相关信息</p>\n<p>最新推出的 TLS 协议，是 SSL 3.0 协议的升级版，和 SSL 协议的大体原理是相同的。</p>\n</div>\n",
      "date_published": "2019-11-03T00:00:00.000Z",
      "date_modified": "2022-08-20T08:54:00.000Z",
      "authors": [
        {
          "name": "小灰"
        }
      ],
      "tags": []
    },
    {
      "title": "JavaScript 教程",
      "url": "https://github.com/MisterChen9527/code/website/js.html",
      "id": "https://github.com/MisterChen9527/code/website/js.html",
      "content_html": "<h2 id=\"初学者教程\" tabindex=\"-1\"> 初学者教程</h2>\n<ul>\n<li><a href=\"/code/language/js/guide/\">快速上手</a></li>\n</ul>\n<h3 id=\"javascript-手册\" tabindex=\"-1\"> JavaScript 手册</h3>\n<ul>\n<li><a href=\"/code/language/js/\">JavaScript 学习教程</a></li>\n</ul>\n<h3 id=\"在线教程\" tabindex=\"-1\"> 在线教程</h3>\n<ul>\n<li>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript\" target=\"_blank\" rel=\"noopener noreferrer\">MDN 教程</a></p>\n</li>\n<li>\n<p><a href=\"http://www.w3school.com.cn/js/index.asp\" target=\"_blank\" rel=\"noopener noreferrer\">W3School 教程</a></p>\n</li>\n<li>\n<p><a href=\"https://www.runoob.com/js/js-tutorial.html\" target=\"_blank\" rel=\"noopener noreferrer\">菜鸟教程</a></p>\n</li>\n</ul>\n<h3 id=\"es6\" tabindex=\"-1\"> ES6</h3>\n<p>ES6 是 JavaScript 的 2015 标注，现已基本被广泛使用和支持；</p>\n<ul>\n<li><a href=\"/code/language/js/es6/\">ES6 教程</a></li>\n</ul>\n<div><p>提示</p>\n<p>此教程由阮一峰老师书写(<strong>真·大佬</strong>)，建议深刻理解 JavaScript 原理(大概一年左右)之后再看。</p>\n</div>\n<blockquote>\n<p>开始下一章学习前，您需要跳转到 <a href=\"/code/language/js/guide/\">JS 快速入门章节</a> 了解 JavaScript，或 <a href=\"/code/language/js/\">深入学习 JavaScript</a> 后，方能进入 jQuery 学习。</p>\n</blockquote>\n",
      "date_published": "2019-09-01T00:00:00.000Z",
      "date_modified": "2022-08-20T08:54:00.000Z",
      "authors": [],
      "tags": [
        "JavaScript"
      ]
    },
    {
      "title": "基础知识",
      "url": "https://github.com/MisterChen9527/code/windows/",
      "id": "https://github.com/MisterChen9527/code/windows/",
      "summary": "以下是有关于 Windows 10 系统的一些基础知识。\n",
      "content_html": "<p>以下是有关于 Windows 10 系统的一些基础知识。</p>\n\n<ul>\n<li>\n<p><a href=\"/code/windows/shortcut-key.html\">Windows 快捷键</a></p>\n</li>\n<li>\n<p><a href=\"/code/windows/hidden-file.html\">显示文件后缀名与隐藏文件</a></p>\n</li>\n<li>\n<p><a href=\"/code/windows/add-path.html\">添加到 path</a></p>\n</li>\n<li>\n<p><a href=\"/code/windows/cmd.html\">快速打开 CMD</a></p>\n</li>\n<li>\n<p><a href=\"/code/windows/notepad.html\">记事本的遗留问题</a></p>\n</li>\n</ul>\n",
      "date_published": "2019-09-07T00:00:00.000Z",
      "date_modified": "2022-08-20T08:54:00.000Z",
      "authors": [],
      "tags": [
        "基础"
      ]
    },
    {
      "title": "环境变量的添加",
      "url": "https://github.com/MisterChen9527/code/windows/add-path.html",
      "id": "https://github.com/MisterChen9527/code/windows/add-path.html",
      "content_html": "<p>以 Windows 10 系统为例，直接在左下角搜索栏中输入“系统变量”</p>\n<p><img src=\"@source/code/windows/assets/pathSearch.png\" alt=\"搜索\"></p>\n<p>在弹出的框中点击环境变量</p>\n<p><img src=\"@source/code/windows/assets/path.png\" alt=\"系统变量\"></p>\n<p>在弹出的新窗口中找到 path，选中并点击编辑</p>\n<p><img src=\"@source/code/windows/assets/pathDetail.png\" alt=\"系统变量\"></p>\n<p>点击添加输入想要添加到 path 的路径或者执行文件名即可</p>\n<p><img src=\"@source/code/windows/assets/pathAdd.png\" alt=\"系统变量\"></p>\n",
      "date_published": "2019-09-08T00:00:00.000Z",
      "date_modified": "2022-08-20T08:54:00.000Z",
      "authors": [],
      "tags": [
        "基础"
      ]
    },
    {
      "title": "打开命令行",
      "url": "https://github.com/MisterChen9527/code/windows/cmd.html",
      "id": "https://github.com/MisterChen9527/code/windows/cmd.html",
      "summary": "打开命令行 (命令提示符) 有多种方式。\n\n运行 - cmd: Win + R 打开运行，然后敲入 cmd 后回车。\n搜索 - cmd: 点击左下角搜索，输入 cmd，然后单击命令提示符。\n开始菜单 - Windows 系统 - 命令提示符。\n\n如果想要快速打开特定路径的 cmd，请打开对应的文件夹，在地址栏直接输入 cmd 并回车。\n",
      "content_html": "<p>打开命令行 (命令提示符) 有多种方式。</p>\n<ol>\n<li>运行 - cmd: <code>Win + R</code> 打开运行，然后敲入 <code>cmd</code> 后回车。</li>\n<li>搜索 - cmd: 点击左下角搜索，输入 cmd，然后单击命令提示符。</li>\n<li>开始菜单 - Windows 系统 - 命令提示符。</li>\n</ol>\n<p>如果想要快速打开特定路径的 cmd，请打开对应的文件夹，在地址栏直接输入 <code>cmd</code> 并回车。</p>\n\n<p><img src=\"@source/code/windows/assets/cmd.png\" alt=\"示意图\"></p>\n<p>这样就会快速打开一个路径为当前文件夹的命令提示符窗口。</p>\n",
      "date_published": "2019-09-08T00:00:00.000Z",
      "date_modified": "2022-08-20T08:54:00.000Z",
      "authors": [],
      "tags": [
        "基础"
      ]
    },
    {
      "title": "显示文件后缀名与隐藏文件",
      "url": "https://github.com/MisterChen9527/code/windows/hidden-file.html",
      "id": "https://github.com/MisterChen9527/code/windows/hidden-file.html",
      "content_html": "<p>显示文件后缀名与隐藏文件</p>\n<p><img src=\"@source/code/windows/assets/hidden-file.png\" alt=\"如何显示隐藏的文件与文件夹\"></p>\n",
      "date_published": "2020-09-15T00:00:00.000Z",
      "date_modified": "2022-08-20T08:54:00.000Z",
      "authors": [],
      "tags": [
        "基础"
      ]
    },
    {
      "title": "记事本的遗留问题",
      "url": "https://github.com/MisterChen9527/code/windows/notepad.html",
      "id": "https://github.com/MisterChen9527/code/windows/notepad.html",
      "content_html": "<p>在编写代码的时候，临时的软件选择需要注意。</p>\n<p>请注意，绝对不能用 Word 和写字板。Word 和写字板保存的不是纯文本文件。</p>\n<p>千万不要使用 Windows 自带的记事本编辑任何文本文件。</p>\n<p>原因是 Microsoft 开发记事本的团队使用了一个非常弱智的行为来保存 UTF-8 编码的文件，他们自作聪明地在每个文件开头添加了几个特殊字符(UTF-8 BOM，即 0xefbbbf)，您会遇到很多不可思议的问题，比如，网页第一行可能会显示一个“?”，明明正确的程序一编译就报语法错误，等等，都是由记事本的弱智行为带来的。</p>\n<p>这个弱智行为从 Windows XP 影响到 Windows 10，在最新的 Windows 10 版本(20H2) 中，才得到解决。</p>\n<div><p>提示</p>\n<p>如果实在是临时急用，需要用记事本替代改一下代码，也要一定注意，保存文件时使用 ANSI 编码，并且暂时不要输入(包含)中文。</p>\n</div>\n",
      "date_published": "2019-09-07T00:00:00.000Z",
      "date_modified": "2022-08-20T08:54:00.000Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "常用快捷键",
      "url": "https://github.com/MisterChen9527/code/windows/shortcut-key.html",
      "id": "https://github.com/MisterChen9527/code/windows/shortcut-key.html",
      "summary": "熟练掌握各种 Windows 快捷键，能够更加高效的使用 Windows。\n",
      "content_html": "<p>熟练掌握各种 Windows 快捷键，能够更加高效的使用 Windows。</p>\n\n<h2 id=\"最常用且最有用的\" tabindex=\"-1\"> 最常用且最有用的</h2>\n<ul>\n<li><code>F2</code>: 重命名文件；</li>\n<li><code>F5</code>: 刷新；</li>\n<li><code>PRINT SCREEN</code>: 将当前屏幕截图拷贝到剪贴板；</li>\n<li><code>Windows</code> + <code>Shift</code> + <code>S</code>: 打开截图工具；(仅在 Windows10 1809 及以上系统可用)</li>\n<li><code>ALT</code> + <code>TAB</code> 切换当前程序(加 Shift 反向)；</li>\n<li><code>ALT</code> + <code>F4</code>: 关闭当前应用程序；</li>\n<li><code>Ctrl</code> + <code>Tab</code>: 在选项卡上向后移动(加 Shift 反向)；</li>\n<li><code>CTRL</code> + <code>F4</code> 或 <code>CTRL</code> + <code>W</code>: 关闭当前选项卡；</li>\n<li><code>CTRL</code> + <code>A</code>: 全选；</li>\n<li><code>CTRL</code> + <code>X</code>: 剪切；</li>\n<li><code>CTRL</code> + <code>C</code>: 复制；</li>\n<li><code>CTRL</code> + <code>V</code>: 粘贴；</li>\n<li><code>Ctrl</code> + <code>F</code>: 查找；</li>\n<li><code>Ctrl</code> + <code>H</code>: 替换。</li>\n<li><code>CTRL</code> + <code>Shift</code> + <code>N</code>: 新建文件夹或窗口</li>\n</ul>\n<h2 id=\"通用键\" tabindex=\"-1\"> 通用键</h2>\n<ul>\n<li><code>F1</code>: 显示帮助；</li>\n<li><code>F2</code>: 重命名文件；</li>\n<li><code>F5</code>: 刷新；</li>\n<li><code>F11</code>: 全屏；</li>\n<li><code>Shift</code> + <code>F10</code>: 打开当前活动项目的快捷菜单(相当于鼠标右键)；</li>\n<li><code>ALT</code> 激活当前程序的菜单栏(使用对应字母选择)；</li>\n<li><code>Backspace</code>: 退格——删除前一个字符、文件视图下——返回上一级；</li>\n<li><code>Enter</code>: 执行或进入；</li>\n<li><code>Win</code> 或 <code>CTRL</code> + <code>ESC</code>: 打开开始菜单；</li>\n<li><code>DELETE</code>: 删除被选中的项目，如果是文件，将被放入回收站；</li>\n<li><code>PRINT SCREEN</code>: 将当前屏幕截图拷贝到剪贴板；</li>\n</ul>\n<h2 id=\"程序窗口\" tabindex=\"-1\"> 程序窗口</h2>\n<ul>\n<li><code>Win</code> + <code>Tab</code>: 最近任务和多桌面视图；</li>\n<li><code>ALT</code> + <code>TAB</code> 切换当前程序(加 Shift 反向)；</li>\n<li><code>ALT</code> + <code>F4</code>: 关闭当前应用程序；</li>\n<li><code>Ctrl</code> + <code>Tab</code>: 在选项卡上向后移动(加 Shift 反向)；</li>\n<li><code>CTRL</code> + <code>F4</code> 或 <code>CTRL</code> + <code>W</code>: 关闭当前选项卡；</li>\n<li><code>Alt</code> + <code>加下划线的字母</code> 执行与该字母匹配的命令(或选择选项)；</li>\n<li><code>Win</code> + <code>↑</code>: 显示最小化的窗口 → 最大化窗口；</li>\n<li><code>Win</code> + <code>←</code>: 将窗口最大化到屏幕的左侧；</li>\n<li><code>Win</code> + <code>→</code>: 将窗口最大化到屏幕的右侧；</li>\n<li><code>Win</code> + <code>↓</code>: 缩小窗口 → 最小化窗口；</li>\n<li><code>Win</code> + <code>Home</code>: 最小化除活动窗口之外的所有窗口；</li>\n<li><code>ALT</code> + <code>SPACEBAR</code>: 打开程序最左上角的菜单；</li>\n<li><code>Win</code> + <code>Shift</code> + <code>↑</code>: 将窗口拉伸到屏幕的顶部和底部；</li>\n<li><code>Win</code> + <code>Shift</code> + <code>←</code> 或 <code>Win</code> + <code>Shift</code> + <code>→</code>: 将窗口从一个监视器移动到另一个监视器；</li>\n</ul>\n<h2 id=\"文件浏览\" tabindex=\"-1\"> 文件浏览</h2>\n<ul>\n<li><code>F2</code>: 重命名文件；</li>\n<li><code>Shift</code> + <code>DELETE</code>: 删除被选中的项目，如果是文件，将被直接删除而不是放入回收站；</li>\n<li><code>CTRL</code> + <code>X</code>: 剪切；</li>\n<li><code>CTRL</code> + <code>C</code>: 复制；</li>\n<li><code>CTRL</code> + <code>V</code>: 粘贴；</li>\n<li><code>CTRL</code> + <code>Shift</code> + <code>N</code>: 新建文件夹或窗口</li>\n</ul>\n<h2 id=\"编辑模式\" tabindex=\"-1\"> 编辑模式</h2>\n<ul>\n<li><code>CTRL</code> + <code>O</code>: 打开文件；</li>\n<li><code>CTRL</code> + <code>S</code>: 保存；</li>\n<li><code>CTRL</code> + <code>方向键</code>: 滚动屏幕；</li>\n<li><code>CTRL</code> + <code>A</code>: 全选；</li>\n<li><code>CTRL</code> + <code>X</code>: 剪切；</li>\n<li><code>CTRL</code> + <code>C</code>: 复制；</li>\n<li><code>CTRL</code> + <code>V</code>: 粘贴；</li>\n<li><code>CTRL</code> + <code>Z</code>: 撤销；</li>\n<li><code>CTRL</code> + <code>Y</code>: 重做；</li>\n<li><code>Ctrl</code> + <code>F</code>: 查找；</li>\n<li><code>Ctrl</code> + <code>H</code>: 替换。</li>\n<li><code>CTRL</code> + <code>E</code>: 搜索/助理；</li>\n<li><code>Ctrl</code> + <code>Tab</code>: 在选项卡上向后移动(加 Shift 反向)；</li>\n<li><code>CTRL</code> + <code>F4</code> 或 <code>CTRL</code> + <code>W</code>: 关闭当前选项卡；</li>\n<li><code>CTRL</code> + <code>P</code>: 打印；</li>\n</ul>\n<div><p>提示</p>\n<p>单击鼠标左键选择光标位置，按住 <code>Shift</code> 再次在另一处单击鼠标左键，即可选中两光标间的所有文字。鼠标左键单击拖动选中内容即可移动选中内容在文档中的位置。</p>\n</div>\n<h2 id=\"系统\" tabindex=\"-1\"> 系统</h2>\n<ul>\n<li><code>CTRL</code> + <code>Shift</code> + <code>ESC</code>: 打开任务管理器;</li>\n<li><code>CTRL</code> + <code>ALT</code> + <code>DELETE</code>: 进入安全选项；</li>\n<li><code>Win</code> + <code>D</code>: 显示桌面；</li>\n<li><code>Win</code> + <code>E</code>: 打开资源管理器；</li>\n<li><code>Win</code> + <code>L</code>: 锁定计算机或切换用户；</li>\n<li><code>Win</code> + <code>M</code>: 最小化所有窗口(和显示桌面不同，自行感受)；</li>\n<li><code>Win</code> + <code>Shift</code> + <code>M</code>: 将最小化的窗口还原到桌面；</li>\n<li><code>Win</code> + <code>R</code>: 打开“运行”对话框；</li>\n<li><code>Win</code> + <code>A</code>: 打开通知中心；</li>\n<li><code>Win</code> + <code>I</code>: 打开系统设置；</li>\n<li><code>Win</code> + <code>X</code>: 打开 Windows 主选项菜单；</li>\n<li><code>Win</code> + <code>P</code>: 选择投影模式；</li>\n<li><code>Win</code> + <code>数字</code>: 启动任务栏上快捷启动项数字位置处的程序；</li>\n<li><code>Win</code> + <code>B</code> 选中桌面右下方工具栏；</li>\n<li><code>Win</code> + <code>BREAK</code>: 打开“系统属性”对话框</li>\n<li><code>Win</code> + <code>T</code>: 循环切换任务栏上的程序；</li>\n<li><code>Shift</code> + <code>Win</code> + <code>数字</code>: 打开任务栏上快捷启动项数字位置处程序的新实例；</li>\n<li><code>Alt</code> + <code>Win</code> + <code>数字</code>: 显示任务栏上快捷启动项数字位置处程序的跳转列表；</li>\n<li><code>ALT</code> + <code>ESC</code>: 保留程序的显示状态切换当前程序(最小化状态将被保留)(加 Shift 反向)；</li>\n</ul>\n<h2 id=\"输入法\" tabindex=\"-1\"> 输入法</h2>\n<ul>\n<li><code>CTRL</code> + <code>Space</code>: 切换中英文输入法；</li>\n<li><code>Win</code> + <code>Space</code>: 切换输入法；</li>\n</ul>\n<h2 id=\"屏幕截图\" tabindex=\"-1\"> 屏幕截图</h2>\n<ul>\n<li><code>PRINT SCREEN</code>: 将当前屏幕截图拷贝到剪贴板；</li>\n<li><code>Win</code> + <code>PRINT SCREEN</code>: 将当前屏幕截图保存在图片文件夹中；</li>\n<li><code>ALT</code> + <code>PRINT SCREEN</code>: 将当前活动程序窗口以图像方式拷贝到剪贴板；</li>\n<li><code>Windows</code> + <code>Shift</code> + <code>S</code>: 打开截图工具；(仅在 Windows10 1809 及以上系统可用)</li>\n</ul>\n",
      "date_published": "2019-09-07T00:00:00.000Z",
      "date_modified": "2022-08-20T08:54:00.000Z",
      "authors": [],
      "tags": [
        "基础"
      ]
    },
    {
      "title": "设计文章",
      "url": "https://github.com/MisterChen9527/design/articles/",
      "id": "https://github.com/MisterChen9527/design/articles/",
      "content_html": "<h2 id=\"文章列表\" tabindex=\"-1\"> 文章列表</h2>\n<ul>\n<li>\n<p><a href=\"/design/articles/gestalt-principle.html\">格式塔原则</a></p>\n</li>\n<li>\n<p><a href=\"/design/articles/left-or-right.html\">布局中的左和右</a></p>\n</li>\n<li>\n<p><a href=\"/design/articles/infomation-flow.html\">信息流介绍</a></p>\n</li>\n</ul>\n",
      "date_published": "2020-09-26T00:00:00.000Z",
      "date_modified": "2022-08-20T08:54:00.000Z",
      "authors": [],
      "tags": [
        "设计"
      ]
    },
    {
      "title": "格式塔原则",
      "url": "https://github.com/MisterChen9527/design/articles/gestalt-principle.html",
      "id": "https://github.com/MisterChen9527/design/articles/gestalt-principle.html",
      "content_html": "<p>好的设计师理解心理学在视觉感知中的强大作用。当别人的目光与您的设计创作相遇时，会发生什么? 他们对您分享的信息有什么反应?</p>\n<h2 id=\"格式塔原理概述\" tabindex=\"-1\"> 格式塔原理概述</h2>\n<h3 id=\"前言\" tabindex=\"-1\"> 前言</h3>\n<p>举一个场景化的栗子，大家平时逛街的时候能记住哪些广告呢? 我们虽然每天看到那么多的信息，但是真正记住的却不多。还有当我们看到复杂的事物的时候，心里会涌现不舒服的奇怪感受，有时候这种感受没有办法用语言来描述。那么为什么会有这些感受呢?</p>\n<p><img src=\"@source/design/articles/assets/gestalt-principle1.jpg\" alt=\"图片1\"></p>\n<p>其实道理很简单，我们做的东西是给人用的。人是动物不是一台机器，人的认知和记忆能力是有限的。视觉设计和心理是相互联系的，并且可以相互影响。格式塔原则可以帮助我们理解和控制这些联系。</p>\n<p>今天就给大家科普下格式塔原则到底是什么? 在设计中如何运用? 是如何影响到我们的生活学习的? 本文会结合大量案例分析讲解，无论您是平面设计师，UI 设计师，插画师，设计小白还是路人，一篇文章让格式塔帮您做出更好的设计!</p>\n<h3 id=\"什么是格式塔原理\" tabindex=\"-1\"> 什么是格式塔原理</h3>\n<p>格式塔学习理论可谓是现代认知主义学习理论的先驱，自 1912 年由韦特海墨(Ｍ，Wetheimer)提出后，在德国得到迅速发展。</p>\n<p><img src=\"@source/design/articles/assets/gestalt-principle-history.jpg\" alt=\"格式塔原理发展历史\"></p>\n<p>1910，这位心理学家乘坐火车度假旅行。当火车经过一个铁路道口的时候，他发现道口闪烁的灯竟然像马戏团表演时剧院帐篷上环绕的灯光，令他产生了光在运动的错觉。(而我们坐火车永远就只会遇到熊孩子和熊孩子)然后他赶紧下火车买了一个西洋镜，来测试自己的想法。</p>\n<p>他将一张图片放在西洋镜内部并通过狭缝观看时，一系列静止图像看起来像是动图。接着他用简单的抽象线条制作不同的画条，通过改变这些元素来研究导致错觉的原因。似动(Apparent Movement)实验成为格式塔心理学的起点。</p>\n<h3 id=\"解决什么问题\" tabindex=\"-1\"> 解决什么问题</h3>\n<p>他们认为思维是整体的、有意义的知觉，而不是联结起来的表象的简单集合；主张学习是在于构成一种完形，是改变一个完形为另一完形。我们的视觉系统自动对视觉输入构建结构，并在神经系统层面上感知形状、图形和物体，而不是只看到互不相连的边、线和区域。所谓格式塔，是德语 Gestalt 的译音，意即「完形」或「形状」；他们认为学习的过程不是试尝错误的过程，而是顿悟的过程，即结合当前整个情境对问题的突然解决。再通俗一点就是人是怎样认知和记忆所看到的事物。</p>\n<h2 id=\"格式塔实验研究\" tabindex=\"-1\"> 格式塔实验研究</h2>\n<p>主要包括以下三方面的实验研究:</p>\n<h3 id=\"_1-似动现象\" tabindex=\"-1\"> 1. 似动现象</h3>\n<p>似动现象是形成格式塔心理学的基础。是指两个相距不远、相继出现的视觉刺激物，呈现的时间间隔如果在 1/10 秒到 1/30 秒之间，那么我们看到的不是两个物体，而是一个物体在移动。</p>\n<p>例如，我们看到灯光从一处向另一处移动，事实上是这只灯熄了，那只灯同时亮了。这种现象正是不能把整体分解成部分的证据。这种现象的组成部分是一些独立的灯在一开一关，但组成一个整体后，给人造成这些灯在动的假象。</p>\n<p>后来，格式塔心理学把重点放在整体系统上，在这个系统中，各个部分是以一种能动的方式相互联系在一起的，也就是说，仅根据各分离的部分，无法推断出这个整体。所以人们把它称为「格式塔或完形心理学」。</p>\n<p><img src=\"@source/design/articles/assets/gestalt-principle-move.jpg\" alt=\"似动现象\"></p>\n<ul>\n<li>\n<p>A: 这张螺旋图是静态还是动态的? 盯着漩涡看一会，您就会感觉到它在转动。</p>\n</li>\n<li>\n<p>B: 您数数看有几个黑点? 当您的眼睛离开那个白点时，就出现白的负象，即黑。当您重新把视点 集中在原来的白点上时，它又变成白色的了。因此，当您的眼睛不断地 在移动的时候，那些黑白点 (正负像) 也就在不断地变化。</p>\n</li>\n<li>\n<p>C: 您看是水平线还是不规则的斜线? 事实上所有的横线都是水平的，不信您拿尺子比一下。</p>\n</li>\n</ul>\n<h3 id=\"_2-整体与部分\" tabindex=\"-1\"> 2. 整体与部分</h3>\n<p>看起来格式塔心理学是把重点放在整体上，但这并不意味着他们不承认分离性。事实上，格式塔也可以是指一个分离的整体。</p>\n<p>研究认为，一个人的知觉场始终被分成图形与背景两部分。「图形」是一个格式塔，是突出的实体，是我们知觉到的事物；「背景」则是尚未分化的、衬托图形的东西。知觉帮助我们把图形从背景中分离出来。图形与背景的对比越大，图形的轮廓越明显，则图形越容易被发觉。</p>\n<p><img src=\"@source/design/articles/assets/gestalt-principle-shape.jpg\" alt=\"整体与部分\"></p>\n<ul>\n<li>\n<p>A: 这幅美食节广告中，酒瓶是被战略性地放置，以创造一个叉子的错觉。黑色酒瓶是图形，白色叉子是背景；在另一种情况下，黑色酒瓶是背景，白色叉子是图形。</p>\n</li>\n<li>\n<p>B: 一黑一白两只天鹅，白天鹅和黑天鹅可以互充图形与背景的关系。</p>\n</li>\n<li>\n<p>C: 这幅海报中，小女孩和气球是被战略性的放置，以创造一个字母「R」的错觉。这两个角色同样可以在图形和背景中互换。</p>\n</li>\n</ul>\n<p><img src=\"@source/design/articles/assets/gestalt-principle-shape2.jpg\" alt=\"整体与部分\"></p>\n<h3 id=\"_3-顿悟实验\" tabindex=\"-1\"> 3. 顿悟实验</h3>\n<p>W·科勒在一次实验中用绳子把一只香蕉悬挂在笼子的顶棚上。笼子里只有惟一的一只木箱可以使用。6 只黑猩猩看到香蕉时跳跃起来竭力想抓住香蕉，但是徒劳。有一只名叫苏尔坦的黑猩猩马上停止了这些白费力气的努力，开始从各个方向打量箱子。忽然它停在箱子前面，抓起它并径直朝目标走去。它把木箱迅速放到地上，爬上箱子，从木箱上面使劲跳起，终于抓住了香蕉。</p>\n<p>W·科勒还对这组黑猩猩使用其他工具进行了观察，如利用木棍去获取放在笼子外面的水果。这些黑猩猩甚至能够将两根短棍连接起来做成一根长棍。同样，它们还能把两三个箱子叠放在一起，再爬到放在最上面的箱子顶上，借助一根木棍去获取香蕉。</p>\n<p>苛勒通过对黑猩猩进行的许多实验，提出了顿悟理论。他认为问题的解决不是由于尝试错误，而是由于顿悟。所谓顿悟，就是内在地把握情境的关系性，并依此改变整个情境。</p>\n<p>或许正如一些批评家所指出的那样，顿悟不是一种独立的学习过程或学习形式，而是学习达到一定程度的表现或者结果。一定的经验积累，是产生顿悟的前提。</p>\n<h2 id=\"影响记忆的三个因素\" tabindex=\"-1\"> 影响记忆的三个因素</h2>\n<p>沃尔夫实验时要求实验体观看样本图形并记住它们，然后在不同的时间里根据记忆把它们画出来。结果发现实验体在不同的间隔时间画出来的图像都有不同。有时再现的图画比原来的图画更简单更有规则，有时原来图画中显著的细节在再现时被更加突出了。还有的比原来的图像更像某些别的我们都很熟悉的图案了。沃尔夫把这三种记忆规律称之为格式塔三大记忆律: 「水平化」、「尖锐化」、「常态化」。</p>\n<p><img src=\"@source/design/articles/assets/gestalt-principle-logo.jpg\" alt=\"这两个品牌logo哪个才是正确的? \"></p>\n<h3 id=\"水平化-leveling\" tabindex=\"-1\"> 水平化 leveling</h3>\n<p>水平化是指在记忆中我们趋向于减少知觉图形小的不规则部分使其对称；或趋向于减少知觉图形中的具体细节。</p>\n<h3 id=\"尖锐化-sharpening\" tabindex=\"-1\"> 尖锐化 sharpening</h3>\n<p>尖锐化是在记忆中与水平化过程伴随而行的。尖锐化是指在记忆中，人们往往强调知觉图形的某些特征而忽视其它具体细节的过程。在有些心理学家看来，人类记忆的特征之一，就是客体中最明显的特征在再现过程中往往被夸大了。</p>\n<h3 id=\"常态化-normalizing\" tabindex=\"-1\"> 常态化 normalizing</h3>\n<p>常态化是指人们在记忆中，往往根据自己已有的记忆痕迹对知觉图形加以修改，即一般会趋向于按照自己认为它似乎应该是什么样子来加以修改的。</p>\n<h2 id=\"格式塔原理在设计中的应用\" tabindex=\"-1\"> 格式塔原理在设计中的应用</h2>\n<p>格式塔的七个基本原则:</p>\n<ul>\n<li>接近性原则</li>\n<li>相似性原则</li>\n<li>连续性原则</li>\n<li>闭合性原则</li>\n<li>主体/背景原则</li>\n<li>简单对称性原则</li>\n<li>共同命运原则</li>\n</ul>\n<div><p>格式塔原理的核心</p>\n<p><strong>整体决定部分的性质并且部分依从与整体</strong></p>\n</div>\n<h3 id=\"接近性原则-law-of-proximity\" tabindex=\"-1\"> 接近性原则 law of proximity</h3>\n<p>人们对知觉场中客体的知觉，是根据它们各部分彼此接近或邻近的程度而组合在一起的。两个元素越是接近，组合在一起的可能性就越大。说明它们之间关系更强。但是接近也是有对比的，在复杂的设计中，我们要一边考虑它们之间内部的逻辑关系一边来排版。</p>\n<p><img src=\"@source/design/articles/assets/gestalt-principle-proximity.jpg\" alt=\"接近性原则\"></p>\n<blockquote>\n<p>同样都是 12 个圆形，您会把左图的 12 个圆形当成一个整体；右边那幅图，上面 4 个圆和下面 8 个圆距离较远，所以您会把上面 4 个圆当成一个整体，下面 8 个圆当成另外一个整体。</p>\n</blockquote>\n<p>需要注意的是，接近性比重较大，把上图的圆形改变形状，甚至添加颜色，人们也会把相近的一组当成一个整体:</p>\n<p><img src=\"@source/design/articles/assets/gestalt-principle-proximity2.jpg\" alt=\"接近性原则\"></p>\n<div><p>案例</p>\n<p><img src=\"@source/design/articles/assets/gestalt-principle-proximity-app-store.jpg\" alt=\"App Store\"></p>\n<p>板块之间的大间距把页面信息分割成各种不同栏目，距离更近的信息暗示了他们有内在的逻辑关系</p>\n<p><img src=\"@source/design/articles/assets/gestalt-principle-proximity-zhanku.jpg\" alt=\"站酷\"></p>\n<p>设计师模块，每个设计师信息组之间有足够大的留白，即使去掉分割线，用户也会清晰分清每一组的边界</p>\n</div>\n<div><p>提示</p>\n<p>在界面设计中常用的设计方法就是划分固定的位置区域，比如导航栏，内容区，操作栏。还有就是通过距离远近来进行信息归类，同类信息接近，不同信息远离。</p>\n</div>\n<div><p>相关信息</p>\n<p>属性相同、场景相似的信息应该放到一起，降低阅读成本，提高用户感知效率;不相关的信息尽量区分开，不要放到一起模糊不清引起不必要的误解。</p>\n</div>\n<h3 id=\"相似性原则-law-of-similarity\" tabindex=\"-1\"> 相似性原则 law of similarity</h3>\n<p>人们在感知时，会对那些相似的项目，只要不被接近因素干扰，会倾向于把它们联合在一起。换言之，相似的部分在知觉中会形成若干组。</p>\n<p>例如，我们在小组辩论中，往往几个人争着发言，但我们仍然能从嘈杂的声音中听出某个人的讲话，这是因为这个人讲话的音质始终有相似性的缘故。如果他讲话的音质经常在变化，那就很难从噪音声中分辨出他的话来。</p>\n<p>人们会把那些明显具有共同特性(如形状、大小、共同运动、方向、颜色等)的事物当成一个整体。与不具有相似视觉特征的元素相比，具有相似视觉特征的元素被认为更加相关。</p>\n<p><img src=\"@source/design/articles/assets/gestalt-principle-similarity.jpg\" alt=\"相似性原则\"></p>\n<p>举个例子相似性原则在实际产品中的应用:</p>\n<p><img src=\"@source/design/articles/assets/gestalt-principle-similarity-bilibili.jpg\" alt=\"bilibili\"></p>\n<blockquote>\n<p>上图全部频道页面，我们在浏览时，会从心理上默认，把频道头像、介绍和订阅按钮自动归为一类。类似外形的单元会被我们人脑默认为同一属类</p>\n</blockquote>\n<div><p>相关信息</p>\n<p>看起来跟亲密性非常类似，但是他们确实不同的两个概念。亲密性强调位置，相似性则强调内容。通常把有明显特征的事物(形状、颜色、大小)组合在一起。多用于表单和导航。</p>\n</div>\n<h3 id=\"连续性原则-law-of-continuity\" tabindex=\"-1\"> 连续性原则 law of continuity</h3>\n<p>在知觉过程中人们往往倾向于使知觉对象的直线继续成为直线，使曲线继续成为曲线，也就是视觉的惯性。利用连续律我们可以让用户操作界面时不经过思考就点击一个固定的位置。</p>\n<p>我们倾向于完整地连接一个图形，而不是观察残缺的线条或形状。这种知觉上的结束，称之为闭合。如果局部形象过于陌生或者简略，则不会产生整体闭合联想。</p>\n<p>人的视觉有追随一个方向的延续，以便把元素联接在一起，使它们看来是连续向着特定的方向。</p>\n<p><img src=\"@source/design/articles/assets/gestalt-principle-continuity.jpg\" alt=\"连续性原则\"></p>\n<p>△ 左图我们不会认为是两个残缺的圆，而是两个相交的圆；中间的 IBM 商标我们之所以能看出来是 IBM，就是因为我们在视觉上看到的不是离散的线条，而是连续的图形；右图我们会看到是向两个方向连续的曲线。</p>\n<div><p>案例</p>\n<p><img src=\"@source/design/articles/assets/gestalt-principle-continuity-stock.jpg\" alt=\"股市\"></p>\n<p>每天的股市数据构成走势图，视觉上会跟随曲线方向知道由左向右去看走势</p>\n</div>\n<div><p>相关信息</p>\n<p>视觉倾向于感知连续的形式而不是分散的碎片通过找到非常微小的共性，将多个不同的信息结成一个整体，是界面设计和 logo 设计常用的原则之一</p>\n</div>\n<h3 id=\"闭合性原则-law-of-closure\" tabindex=\"-1\"> 闭合性原则 law of closure</h3>\n<p>人们在观察熟悉的视觉形象时，会把不完整的局部形象当作一个整体的形象来感知，这种知觉上的结束，称之为闭合。如果局部形象过于陌生或者简略，则不会产生整体闭合联想。</p>\n<p>闭合是一种完成某种图形(完形)的行动。就算没有外形的约束，我们也会自动把图形脑补完全。比如半个形状或者有缺口的形状我们不会认为是一条线或各种零碎的图形，而是一个完整的形状。闭合是指一种完形的认知规律。</p>\n<p><img src=\"@source/design/articles/assets/gestalt-principle-closure.jpg\" alt=\"闭合性原则\"></p>\n<div><p>案例</p>\n<p><img src=\"@source/design/articles/assets/gestalt-principle-closure-apple-music.jpg\" alt=\"Apple Music\"></p>\n<p>我们常见的页面横滑组件就运用了闭合律原则，通常在界面右侧露出一半(或少部分)内容，来提示用户右边还隐藏着更多内容</p>\n</div>\n<div><p>相关信息</p>\n<p>人们的视觉系统会自动将不相干的图形元素封闭起来感知为完整的个体为不实单独的碎片</p>\n<p>表现手法有:正负形、封闭边界、不完全闭合</p>\n</div>\n<h3 id=\"主体-背景原则\" tabindex=\"-1\"> 主体/背景原则</h3>\n<p>主体指的是在界面当中占据我们主要注意力的所有元素，其余的元素在此时均成为背景。当主体与背景重叠时，人的视觉更加倾向于将小的物体视为主体，大的物体视为背景，所以我们可以通过大小与图的关系，将我们希望传递的不同层次的内容进行展示。</p>\n<p>当小图形重叠大图形之上，我们的视觉会倾向于将小图形归为主体，大色块为背景，这就是格式塔中的主体与背景原则。</p>\n<p><img src=\"@source/design/articles/assets/gestalt-principle-main.jpg\" alt=\"主体/背景原则\"></p>\n<div><p>案例</p>\n<p><img src=\"@source/design/articles/assets/gestalt-principle-main-doubanFM.jpg\" alt=\"豆瓣 FM\"></p>\n<p>在白色背景上有非常突出的主体: 歌曲封面、歌名、进度条、播放/暂停、收藏等，歌曲播放时，进度条有非常明显的进度变化，切换歌曲时，封面的前后错层，这些都与背景有非常鲜明的对比</p>\n</div>\n<div><p>相关信息</p>\n<p>在界面设计中，主体背景是弹窗常常运用到的表现手法利用空间感给用户带来视觉引导，让用户快速感知重要的信息内容，和可忽略的信息内容</p>\n</div>\n<h3 id=\"简单对称性原则-simple-principle\" tabindex=\"-1\"> 简单对称性原则 Simple principle</h3>\n<p>在观察事物过程中，我们第一印象更倾向于简单而且对称的图形，这就是格式塔的简化对称性原则。</p>\n<p>具有对称、规则、平滑的简单图形特征的各部分趋于组成整体。对称的元素往往被认为是归属在一起的，而不管它们之间的距离，都给我们一种牢固和有序的感觉。</p>\n<p><img src=\"@source/design/articles/assets/gestalt-principle-simple.jpg\" alt=\"简单对称性原则\"></p>\n<p>人的眼睛喜欢在复杂的形状中找到简单而有序的对象，当我们在一个设计中看到复杂的物体时，眼睛更愿意将它们转换为单一统一形状，并尝试从这些形状中移除无关的细节来简化这些物体。</p>\n<p>对称的构图是令人满意的，但它们也会变得有点沉闷。在对称的设计中加入不对称的元素可以在给人留下印象的同时吸引注意力。</p>\n<div><p>案例</p>\n<p><img src=\"@source/design/articles/assets/gestalt-principle-simple-pinterest.jpg\" alt=\"Pinterest\"></p>\n<p>左右布局的瀑布流就是格式塔的简化对称性的体现，用户在浏览的的过程中有效减轻了阅读压力。特别适合这种以图片流为主的产品，能大大提高浏览效率。</p>\n</div>\n<div><p>相关信息</p>\n<p>对称元素简单、和谐，但往往容易单调，一般来说加入不对称的样式会更容易让人印象深刻，在平面设计中对称的使用趣味性更加广泛</p>\n</div>\n<h3 id=\"共同命运原则-common-destiny\" tabindex=\"-1\"> 共同命运原则 Common destiny</h3>\n<p>无论元素之间的距离有多远，或者它们看起来有多不同，如果它们一起运动或变化，它们都被认为是相关的。这里的共同命运针对的是运动的物体。与接近性原理和相似性原理相像，都与我们的视觉系统会有着给对象进行分组来感知事物的倾向相关，但是一起运动的物体会被感知为属于同一组或是彼此相关这样的一种视觉现象，这就是格式塔中的共同命运原则。</p>\n<p><img src=\"@source/design/articles/assets/gestalt-principle-common-destiny.jpg\" alt=\"共同命运原则\"></p>\n<p>向同一方向移动的元素，我们在处理的过程当中，会默认把它们归为一类。</p>\n<div><p>案例</p>\n<p><img src=\"@source/design/articles/assets/gestalt-principle-common-destiny-iOS.jpg\" alt=\"ios 桌面\"></p>\n<p>iPhone 删除应用时候，所有图标都一起晃动起来(意思瑟瑟发抖，不要删我不要删我! )，左上角都有一个删除的按钮，要么删除，要么保留，这就是共同命运原则。</p>\n</div>\n<div><p>相关信息</p>\n<p>共同命运强调的是方向，当元素的运动、方向具有共同运动形式或者某种规律使，我们会将其视为为彼此相关的一个群组或整体</p>\n</div>\n<h3 id=\"更多\" tabindex=\"-1\"> 更多</h3>\n<p>事实上，以上 7 条原则只是格式塔心理学中的一小部分而已，比如还有:</p>\n<h4 id=\"成员特性律\" tabindex=\"-1\"> 成员特性律</h4>\n<p>一个整体中的个别部分并不具有固定的特性，个别部分的特性是从它与其他部分的关系中显现出来的。</p>\n<p><img src=\"@source/design/articles/assets/gestalt-principle-special.jpg\" alt=\"成员特性律\"></p>\n<p>如果我们有很多同样的按钮，如何让某个更重要的按钮突出但是仍然让用户感知还是按钮呢? 那就要用到成员特性律了。成员特性律赋予了集体中某一个元素特殊的一些刺激元素从而突出它。</p>\n<p>独特的外形暗示了它与别的元素有不同的功能</p>\n<div><p>案例</p>\n<p><img src=\"@source/design/articles/assets/gestalt-principle-special-taobao.jpg\" alt=\"淘宝\"></p>\n<p>商品详情页有两个重要的操作按钮: 加入购物车、立即购买。为了促使用户尽快购买，给「立即购买」更重的红色以突出它的独特性</p>\n</div>\n<h2 id=\"格式塔学习理论的基本观点\" tabindex=\"-1\"> 格式塔学习理论的基本观点</h2>\n<h3 id=\"认知重组\" tabindex=\"-1\"> 认知重组</h3>\n<p>格式塔心理学认为，通过学习，会在头脑中留下记忆痕迹，这些痕迹不是孤立的要素，而是一个有组织的整体，即完形。因此，学习主要不是加进新痕迹或减去旧痕迹的问题，而是要使一种完形改变成另一种完形。一个人学习的过程，通常是从一种混沌的模糊状态，转变成一种有意义的、有结构的状态，这就是知觉重组的过程。</p>\n<h3 id=\"顿悟学习\" tabindex=\"-1\"> 顿悟学习</h3>\n<p>顿悟学习可以避免多余的试误，同时又有助于迁移。格式塔心理学家认为，通过对问题情境的内在性质有所顿悟的方式来解决问题，就可以避免与这一问题情境不相干的大量随机的、盲目的行动，而且有利于把学习所得迁移到新的问题情境中去。顿悟学习的核心是要把握事物的本质，而不是无关紧要的细节。</p>\n<h3 id=\"遗忘曲线\" tabindex=\"-1\"> 遗忘曲线</h3>\n<p>真正的学习是不会遗忘的。通过顿悟习得的内容，一旦掌握后，永远也不会遗忘。顿悟将成为我们知识技能中永久的部分。用现代认知信息加工心理学的术语来说，顿悟的内容是进入了长时记忆将永远保留在学习者的头脑中。</p>\n<div><p>提示</p>\n<p>有人在一项实验中，把 149162536496481 写在一张卡片上，要一组被试看 15 秒钟，然后试图回忆它。这是一项相当困难的任务。在一般情况下，除了记住其中少数几个数字外，没有人能全部记住。但在给另一组被试看这张卡片之前，告诉他们在试图记住它以前，先想一下这些数字为什么这样排列，是否有规律可循。结果不少被试都觉察到，这些数原是用 1 到 9 的平方排列起来的。这样一来，回忆这些数字就毫无困难，哪怕是在几周或几个月之后也能轻易做到。</p>\n</div>\n<h3 id=\"学习奖励\" tabindex=\"-1\"> 学习奖励</h3>\n<p>格式塔心理学家认为，真正的学习常常会伴随着一种兴奋感。例如，一些人对智力拼图、字迷填空玩得津津有味。也因此有人抨击滥用各种外部奖励，诸如使用糖果、好分数、五角星或金钱之类的东西来驱动学习。对于教育工作者来说，不加区分地使用奖励物，可能会使学生分心，不把心思用在学习上，而只关心能得到什么奖励上，从而不可能达到对问题情境有顿悟的理解。</p>\n<h3 id=\"顿悟说对错误说的批判\" tabindex=\"-1\"> 顿悟说对错误说的批判</h3>\n<p>还记得第二部分对猩猩的实验吗，实验表明猩猩在行动之前，已经领会到了自己的动作为什么进行，怎样去进行以及最终的结果为何，在苛勒看来，猩猩对问题的解决并非是一种盲目尝试错误的过程，而是处于对问题产生了顿悟。</p>\n<p>在格式塔心理学家看来，学习是一种智慧行为，是一种顿悟过程，需要有理解、领会与思维等认识活动的参与，并且它是一种突现、速变、飞跃的过程。顿悟学习特点可归纳如下: 问题解决前尚有一个困惑或沉静的时期，表现得迟疑不决，有长时间停顿；从问题解决前到问题解决之间的过渡不是一种渐变的过程，而是一种突发性的质变过程；在问题解决阶段，行为操作是一个顺利的不间断的过程，形成一个连续的完整体，很少有错误的行为；由顿悟获得的问题解决方法能在记忆中保持较长的时间；由顿悟而掌握的学习原则有利于适应新的情境，解决新的问题。</p>\n<h3 id=\"创造性思维\" tabindex=\"-1\"> 创造性思维</h3>\n<p>韦特默认为要想创造性地解决问题必须让整体支配部分。即使在必要的关注问题的细节时，也决不能忽视问题的整体。必须把细节放在问题的整体中，把它们与整体结构联系起来加以考虑。这是一种自上而下、由整体到部分的思维。他认为要使人们顺利地解决问题，必须把问题的整个情境呈现出来，使之能对问题有个完全概观，决不能像桑代克那样，有意地把解决问题的方法和途径藏起来，迫使被试不得不去盲目试误。学习贵在打破旧有知识和模式的束缚，争取在对问题领域的基础上产生顿悟，掌据解决问题的原则，做到触类旁通、举一反三，促进智力水平的提高。</p>\n<h2 id=\"格式塔学习理论的分支\" tabindex=\"-1\"> 格式塔学习理论的分支</h2>\n<h3 id=\"勒温的基本观点\" tabindex=\"-1\"> 勒温的基本观点</h3>\n<p>传统的格式塔心理学在探讨学习的问题时，认为学习者「渴望达到某些目的」是理所当然的，因而他们关注的是通过知觉重组达到目的的途径；而勒温则把注意力集中在「渴望」和「目的」本身上，并把它们与个性联系起来研究。勒温由此而形成的理论体系，主要不是一种学习理论，而是一种描述系统。</p>\n<h3 id=\"勒温论学习\" tabindex=\"-1\"> 勒温论学习</h3>\n<p>勒温的基本观点是社会心理学方面的，尤其是关于个体的动机。从某种角度来看，这弥补了格式塔学习理论的不足。勒温认为，用场论来研究学习的问题，需要注意以下几个方面:</p>\n<p>要使用构成法(Constructive method)，而不是用分类法或分析法。这就是说，要用心理学中最基本的几个构成来探讨学习的问题。这些基本构成就是生活空间，心理环境、诱发力和约束力等。</p>\n<p>要对行为作动态分析，要了解作为行为之基础的各种力(forces)。他把行为变化看作是各种心理力量的结果。</p>\n<p>要从心理的角度来分析学习者当时的生活空间和心理世界，而不能像行为主义者那样用客观的物理主义者的术语来界定刺激。</p>\n<p>要从整体情境分析入手，而不能只是从刺激情境中抽取一两个孤立的要素。因为不从整体上考虑问题，是不可能作出正确判断的。</p>\n<p>行为是行为发生时场的函数。勒温认为行为取决于有机体以往的经验和强化史，这是形而上学的。因为过去的事情现在并不存在，所以不可能直接影响现在的行为。虽说过去的心理场是现在的心理场的来源，但影响现在行为的，毕竟是现在的心理场。</p>\n<p>在研究学习时，至少必须区别这样四种变化: 第一，作为认知结构(即知识)变化的学习；第二，作为动机变化的学习；第三，作为群体属性和意识形态变化的学习；第四，作为身体肌肉随意控制发生变化的学习。在勒温看来，学习理论要探讨的，主要是学习者认知结构和动机的变化。</p>\n<h3 id=\"评论\" tabindex=\"-1\"> 评论</h3>\n<p>勒温在格式塔心理学的框架结构内引进「场」、「生活空间」、「拓扑学」和「向量」等概念，另辟蹊径，从而丰富和发展了传统的格塔理论。尽管他研究的重心放在社会心理学方面，但他对行为、问题和动机等方面探讨，在当时是很有新意的。</p>\n<h2 id=\"格式塔原理的贡献与局限性\" tabindex=\"-1\"> 格式塔原理的贡献与局限性</h2>\n<h3 id=\"_1-贡献\" tabindex=\"-1\"> 1. 贡献</h3>\n<h4 id=\"对元素主义的反击具有进步意义\" tabindex=\"-1\"> 对元素主义的反击具有进步意义</h4>\n<p>格式塔学派用大量的事实证明了冯特元素主义理论的漏洞百出，并大胆地冲破了元素主义的束缚，积极而有成效地进行了大量的探索，并取得了一系列引人注目的成果，这对促进心理学事业的繁荣和发展是大有脾益的。</p>\n<h4 id=\"格式塔学派引发了知觉心理学的革新\" tabindex=\"-1\"> 格式塔学派引发了知觉心理学的革新</h4>\n<p>由于格式塔学派在知觉领域做了大量有目共睹的研究，使得经验论、联想论、官能主义的传统方法逐渐让位于先验论、整体论和突创论。知觉心理学也由感觉心理学的附庸变成一个独立的分支，并在短时期内就取得了一系列突破。</p>\n<h4 id=\"格式塔学派的学习理论独具特色\" tabindex=\"-1\"> 格式塔学派的学习理论独具特色</h4>\n<p>格式塔学派的顿悟说及对迁移、创造性思维的研究，冲击了联结主义和行为主义的框框，不论在理论创建还是在教育实践中都具有独到的价值和意义。顿悟说也成为西方学习理论中最重要的理论之一。</p>\n<h4 id=\"对人本主义心理学影响较大\" tabindex=\"-1\"> 对人本主义心理学影响较大</h4>\n<p>人本主义心理学的创建人马斯洛(就是提出人生 7 个层次的需求理论的那位)曾在他老师的惠特海默指导下，研究整体论，从而积累下了研究人的经验；同时期的对人的心理事件或整体研究。主张存在分析的心理学，这些都表明了格式塔学派的潜在影响。</p>\n<h4 id=\"对现代认知心理学的产生起了推动作用\" tabindex=\"-1\"> 对现代认知心理学的产生起了推动作用</h4>\n<p>格式塔学派研究的那些认知过程及心理过程成了现代认知心理学的基本观点，正如罗伯特逊指出，认知心理学实际上是一种新格式塔现象。</p>\n<h3 id=\"_2-局限性\" tabindex=\"-1\"> 2. 局限性</h3>\n<p>过分强调顿悟，而全面否定尝试错误，犯了以偏概全的偏激性错误。</p>\n<p>顿悟似乎是一个神秘的概念，它的心理活动机制没有揭示清楚。还不能说是一个完善的理论解释。</p>\n<p>顿悟说还缺乏对其他与学习有关问题的研究。而且研究的主要是动物的经验学习，还不能很好地解释人类的所有直接经验学习，如技能的习得等。</p>\n<p>其理论观点和术语含糊不清。格式塔学派不加分析地采用了一些物理学的概念和数理术语，观点模棱两可，概念不确切，给人的感觉是理论主张过于晦涩深奥，神秘莫测。</p>\n<p>对其他学派的批评过于苛刻，他们只批评其他学派的缺陷，却没有提出更好的改进措施，且自身的理论建设和主张又并不明确和高明多少。原来每个行业都有一条鄙视链的存在啊。</p>\n<p>格式塔学派的实验不够严谨，过分依赖现象学的方法，缺乏信度和效度，就水平而言，并不比他们所批评的其他学派好多少。</p>\n<h2 id=\"总结\" tabindex=\"-1\"> 总结</h2>\n<p>我们把原理归类、总结的目的有两个: 一个是自我检查，我们在构思设计的过程中往往会多于专注视觉效果的创作而忽略最基本的原理，比如在设计之前进行完整的设计构思；设计过程中检查自己的设计作品，避免低级错误导致反复改稿，比如信息不对齐，布局杂乱等；再就是设计完成之后对需求方有理有据的陈述。第二个是在深入理解的前提下做设计时能够举一反三。</p>\n<p>用户界面设计并不全是关于漂亮的像素和完美的图形。它主要是关于沟通、性能和便利性。格式塔原则总是帮助我们实现这些目标，为用户创造愉快的体验，为企业创造巨大的成功。</p>\n<p>通过例子可以发现，这 7 项法则并不是独立存在的，它们之间具有高度的关联性，是相辅相成的关系，我们需要跟进不同的需求类型和用户场景，运用这些基本法则打出组合拳，使您的设计方案更有依据。在做产品或者设计的时候一定要考虑人的认知与记忆的因素，这是与生俱来的天性，人们的审美对简单与和谐具有基本的要求。我们只有更好的利用视觉空间设计作品，减少设计的复杂性，尽量保持格式塔原则的完整，用户才能更好更容易地理解使用我们的产品。</p>\n<blockquote>\n<p>参考文献:</p>\n<ul>\n<li>《格式塔心理学理论》MBA 智库</li>\n<li>《格式塔心理学原理》库尔特.考夫卡</li>\n<li>《视觉设计中的格式塔艺术心理学》</li>\n<li>《格式塔心理学 5 项法则的学习与思考》Tencent CDC</li>\n<li>《设计中的格式塔原则》Souche Blog</li>\n<li>维基百科及其他</li>\n</ul>\n</blockquote>\n",
      "date_published": "2020-09-26T00:00:00.000Z",
      "date_modified": "2022-08-20T08:54:00.000Z",
      "authors": [
        {
          "name": "印迹"
        }
      ],
      "tags": [
        "设计"
      ]
    },
    {
      "title": "信息流介绍",
      "url": "https://github.com/MisterChen9527/design/articles/infomation-flow.html",
      "id": "https://github.com/MisterChen9527/design/articles/infomation-flow.html",
      "content_html": "<p>今日头条的出现颠覆了传统新闻产品(如网易、新浪和搜狐新闻)。</p>\n<p>传统新闻依靠着编辑人员的推荐，将新闻触达给用户，而今日头条则依靠着新闻算法，抛弃传统人工分发的思路，使分发效率数以万计的提升，其迅速崛起，成为头部新闻资讯产品。</p>\n<p>今日头条作为新闻信息流的头部产品，里面的设计细节和设计逻辑值得我们思考和分析。</p>\n<h2 id=\"信息流样式\" tabindex=\"-1\"> 信息流样式</h2>\n<p>什么是信息流? 信息流由两部分组成，信息流=信息+流。</p>\n<p>信息指的是内容，这些内容可以是新闻、视频、图片等，所呈现的样式多为列表或卡片。</p>\n<p>流指的是瀑布流，可以无限滑动浏览。</p>\n<p>所以信息流就是可以无限滑动浏览内容信息。</p>\n<p>信息流的样式的好坏，会直接影响到信息的展现效率和点击率，从而影响到用户获取信息的效率和整体阅读时长。</p>\n<p>下图为今日头条首页推荐频道的信息流:</p>\n<p><img src=\"@source/design/articles/assets/infomation-flow1.jpg\" alt=\"信息流\"></p>\n<p>将信息流样式进行简单分类，使用最多的四种样式为纯文、左文右图、短内容、大图视频。如下图所示:</p>\n<p><img src=\"@source/design/articles/assets/infomation-flow2.jpg\" alt=\"信息流\"></p>\n<p>纯文样式用于新闻中没有图片的情况，当文章中没有图片时，这时候采用改样式。列表含有: 标题、来源、评论数、发布时间。</p>\n<p>对于含有图片时候，采用左文右图样式。目前新闻对于含有图片的列表样式，一般有 3 种分别为: 左文右图、左图右文和三图。</p>\n<p>左图右文的样式，强化图片，弱化标题。对于新闻资讯来说，图片无法准确的表达其新闻资讯的内容，所以这种样式目前没什么产品使用。</p>\n<p>目前市面上绝大部分产品都采用左文右图，例如今日头条、网易新闻、腾讯新闻、新浪新闻等。只有是搜狐新闻采用左图右文。</p>\n<p><img src=\"@source/design/articles/assets/infomation-flow3.jpg\" alt=\"信息流\"></p>\n<p>三图则通过图片吸引用户点击查看，更加通过图片引导用户点击，好处是可以提升点击率，但是整个信息流显得乱，影响用户阅读。</p>\n<p><img src=\"@source/design/articles/assets/infomation-flow4.jpg\" alt=\"信息流\"></p>\n<p>和网易相比，头条信息流阅读起来更加舒服，视觉压力减少，这是基于今日头条三图样式占比很少，如下图所示，网易新闻信息流插入三图样式导致整个信息流杂乱。</p>\n<p><img src=\"@source/design/articles/assets/infomation-flow5.jpg\" alt=\"信息流\"></p>\n<p>对比下网易新闻和今日头条信息流样式，如下图所示:</p>\n<p>纯文，今日头条的标题颜色更深，网易的相对而言淡一些。头条的列表高度比网易的高，这意味着，头条的屏幕展示条数比网易新闻的少，但是整体的空间感和留白呼吸感更舒服。同时今日头条含有发布时间，使得用户观看新闻资讯时，能够感知新闻的实时性。</p>\n<p><img src=\"@source/design/articles/assets/infomation-flow6.jpg\" alt=\"信息流\"></p>\n<p>左文右图，头条的列表比网易的要高一些，对比来看，头条的标题更加明显，图片含有圆角半径，使得头条整体看上去更舒服。</p>\n<p><img src=\"@source/design/articles/assets/infomation-flow7.jpg\" alt=\"信息流\"></p>\n<p>大图视频，两者的区别不大，依然是标题文字颜色、封面圆角和发布时间的差异性。</p>\n<p><img src=\"@source/design/articles/assets/infomation-flow8.jpg\" alt=\"信息流\"></p>\n<h3 id=\"小结\" tabindex=\"-1\"> 小结</h3>\n<p>头条流整体的空间感、留白，标题颜色对比做的比较好。</p>\n<p>留白相对于网易更多一些，相同的屏幕空间，展示的内容信息会少一点，屏幕展示效率会低一些。但用户在阅读过程中舒适度更强，同样的情况下用户的阅读时长会变长。</p>\n<h2 id=\"信息流分发\" tabindex=\"-1\"> 信息流分发</h2>\n<p>什么是信息流分发? 通过一定的设计策略，将用户的流量合理的分配到其他各个地方，从而达到产品的设计目标，促进流量利用最大化。提升流量最大限度的转化，获得更大的商业化价值。</p>\n<p>今日头条的信息流主要包含 5 个模块: 置顶模块、资讯列表、广告模块、短内容、其他功能模块的卡片入口。如下图所示:</p>\n<p><img src=\"@source/design/articles/assets/infomation-flow9.jpg\" alt=\"信息流\"></p>\n<p>推荐流顶部的置顶内容，最多置顶两条，这里是因为相关政策原因。</p>\n<p>在正常信息流第一条之后，插入广告，为平台做商业化营收。之后就会根据用户的阅读习惯，给用户推荐信息内容，并时不时的插入广告等。</p>\n<p>今日头条没有编辑运营，所以几乎所有的新闻都来自于机器算法。少了编辑人员的人工运营，使得今日头条有巨量的内容按照不同用户的阅读习惯推荐用户不同的内容。</p>\n<h2 id=\"搜索栏\" tabindex=\"-1\"> 搜索栏</h2>\n<p>在新闻信息流产品里，搜索栏所承接的使用场景主要有两个。一个是提供搜索新闻功能，通过关键词对当前或过去的新闻进行搜索。</p>\n<p>另一个是在搜索模块提供热搜新闻，提供用户阅读。</p>\n<p>那么如何提升搜索栏的点击次数。今日头条将热搜新闻以提示语的形式展示在搜索栏滚动，吸引用户。同时为了更大限度的展示新闻条数，采用一排两个的设计，保证最大程度的提升点击率。</p>\n<p><img src=\"@source/design/articles/assets/infomation-flow10.jpg\" alt=\"信息流\"></p>\n<p>用户点击搜索框之后，搜索框里面内置第一条热搜关键词。用户可通过键盘上的搜索，进行搜索。也可以点击搜索栏下方的两个热搜新闻进行搜索查看。</p>\n<h2 id=\"短视频\" tabindex=\"-1\"> 短视频</h2>\n<p>视频标题内置于播放器中，这样的好处可以减少卡片高度，让视频曝光量提升，缺点是用户如果想看视频标题介绍时，则需要点击下播放器，标题才能再次出现。</p>\n<p><img src=\"@source/design/articles/assets/infomation-flow11.jpg\" alt=\"信息流\"></p>\n<p>标题置于播放器里面，头条可以展示 2.5 条，而好看视频将标题置于外面只能展示 2 条，如下图所示:</p>\n<p><img src=\"@source/design/articles/assets/infomation-flow12.jpg\" alt=\"信息流\"></p>\n<p>对于广告业务来说，收入的一个重要指标则是广告曝光量，为了提升广告的收入，则必须降低视频高度，使得广告曝光效率得到提升，以此提升收入，所以头条将标题放置于播放器里面符合商业目标，但是不符合用户目标。</p>\n<h2 id=\"小视频\" tabindex=\"-1\"> 小视频</h2>\n<p>小视频的布局设计大致有两种，一种是抖音式布局，采用头像和操作项位于右侧。这样的好处是，视频的互动量很明显的展示出来，可引导用户互动。但对视频的内容有一定遮挡影响。</p>\n<p>另一种是好看视频式布局，将头像昵称、操作项放在底部，弱化视频的互动数据。让用户专注于视频内容。</p>\n<p><img src=\"@source/design/articles/assets/infomation-flow13.jpg\" alt=\"信息流\"></p>\n<p>今日头条的小视频采用和抖音一样的布局。头像和操作项放于右侧。但是为了引导用户评论，在界面底部加入了输入框，引导用户评论，为了让用户更加方便的看评论。上滑手势变成了调起起评论。</p>\n<p><img src=\"@source/design/articles/assets/infomation-flow14.jpg\" alt=\"信息流\"></p>\n<h2 id=\"短内容流\" tabindex=\"-1\"> 短内容流</h2>\n<p>推荐流里面的短内容(微头条)，点击进入短内容 feed 流。而非短内容详情页。用户如果想看详情，那么需要用户再次点击。</p>\n<p><img src=\"@source/design/articles/assets/infomation-flow15.jpg\" alt=\"信息流\"></p>\n<p>这种设计明显体验不好，估计产品为其他短内容导流。这样的交互设计，可以使得整体的短内容流的曝光量提升好几倍。</p>\n<p>这种做法牺牲了体验，用户如果需要看详情，则需要连续点击两次。这是为了业务指标作出牺牲的设计。</p>\n",
      "date_published": "2020-09-26T00:00:00.000Z",
      "date_modified": "2022-08-20T08:54:00.000Z",
      "authors": [],
      "tags": [
        "设计"
      ]
    },
    {
      "title": "布局中的左和右",
      "url": "https://github.com/MisterChen9527/design/articles/left-or-right.html",
      "id": "https://github.com/MisterChen9527/design/articles/left-or-right.html",
      "content_html": "<h2 id=\"左右横跳的泳道\" tabindex=\"-1\"> 左右横跳的泳道</h2>\n<p>最近经常在人人视频上看电视剧，发现人人视频在设计上有个很有意思的点。</p>\n<p>它的电影页中有很多推荐电影片单，每个片单里有 5-12 部电影；碍于手机尺寸，用户只能看到 3 部电影；如果您对这个片单里的电影比较感兴趣，可以滑动查看更多的电影——这种横向滑动的设计又被称之为“泳道”。</p>\n<p><img src=\"@source/design/articles/assets/left-or-right-renren.jpg\" alt=\"泳道\"></p>\n<p>那么问题来了，究竟向哪个方向滑动呢?</p>\n<p>或许您会觉得这是一个送分题，肯定是左滑啊；没错，您去查看 100 个 APP，这种水平横滑的泳道，99 个都是左滑的；但是人人视频就是那唯一的特例，它是左滑和右滑相互组合的。</p>\n<p><img src=\"@source/design/articles/assets/left-or-right-renren.gif\" alt=\"人人交互\"></p>\n<p>前一个片单是左滑，后一个就是右滑；反之，前一个片单是右滑，后一个就是左滑。</p>\n<p>第一次碰到这种设计，我很奇怪: 为什么要做出这种挑战用户固有认知的调整? 后来思考了一下，开始理解他们的做法。</p>\n<p>当用户左滑查看电影时，浏览完最后一部电影，用户的视线是停留在在屏幕右侧；如果下一个片单依然采用左滑，那么用户的视线需要先移动到屏幕左侧，再移动到右侧——这个路线就是 Z 型浏览模式；而人人视频紧接着的是右滑，第一个视频直接从右侧开始，避免了用户视线的转移。</p>\n<p><img src=\"@source/design/articles/assets/left-or-right-sight.jpg\" alt=\"视线路径\"></p>\n<p>人人视频的这种方案，让我想起夸克浏览器——用户在夸克浏览器里观看视频，如果点击屏幕的位置靠左，那么菜单就会出现在左边；如果点击的位置靠右，菜单就会出现在右边；这样的处理方式，可以缩短用户手指的移动距离。</p>\n<p><img src=\"@source/design/articles/assets/left-or-right-quark.gif\" alt=\"夸克菜单\"></p>\n<p>一个是缩短视线移动距离，一个是缩短手指移动距离。</p>\n<h2 id=\"左还是右\" tabindex=\"-1\"> 左还是右</h2>\n<p>设计中有很多这样“左、右”的争论。最经典的就是: 对话框的确定按钮到底是在左边还是右边? 这个话题被讨论了无数次。</p>\n<p>那么不管是左还是右，我们到底在争论什么? 左和右代表了什么?</p>\n<p>我们习惯的浏览方向是由左至右，那么左代表了用户视线的起点。</p>\n<p>我们经常说用户的浏览模式是 Z 型的，但是在移动端界面中，左边为信息区，右边为操作区。</p>\n<p>用户在快速浏览页面的模式下，根据左边的信息区判断自己是否对这条内容感兴趣，如果感兴趣才进行操作；所以更多的情况下，用户的浏览模式不是 Z 型，而是 L 型的。</p>\n<p><img src=\"@source/design/articles/assets/left-or-right-L.jpg\" alt=\"视线移动\"></p>\n<p>iOS 11 与 iOS 10 相比，我们可以发现页面标题、搜索框文案和内容都是改成放在左边。</p>\n<p><img src=\"@source/design/articles/assets/left-or-right-app-store.jpg\" alt=\"iOS页面对比\"></p>\n<p>整体的视觉动线由中间改成了左边，用户在快速浏览过程中视线不需要发生偏移。</p>\n<p><img src=\"@source/design/articles/assets/left-or-right-app-store2.jpg\" alt=\"iOS 页面对比\"></p>\n<p>右代表着更好的易用性。因为在移动端，用户更习惯单手握持手机进行操作；而我们大部分人都是右撇子。</p>\n<p>谷歌的 MD 设计中的浮动按钮，是位于界面右侧；微信的浮窗也是位于界面右侧，就是为了方便用户操作。</p>\n<p><img src=\"@source/design/articles/assets/left-or-right-float.jpg\" alt=\"浮动按钮\"></p>\n<p>看到这里或许您会理解为什么“对话框的确定按钮在左边还是右边? ”这个话题经久不衰了吧。</p>\n<p>因为左边和右边背后都有理论支撑——左代表着离您的眼睛更近，右代表着离您的手更近。</p>\n<p>我们再来设想一个场景，针对左撇子用户，界面设计应该怎么调整；用户的惯用手是左手，那是不是要做镜面反转，把操作区移动到左边呢? 读者中肯定有左撇子用户，您们会喜欢这种布局吗?</p>\n<p><img src=\"@source/design/articles/assets/left-or-right-direction.jpg\" alt=\"文字方向\"></p>\n<h2 id=\"流量分发\" tabindex=\"-1\"> 流量分发</h2>\n<p>当然也会有一些设计方案在“左/右”的选择上没这么纠结，例如在微博、抖音这类社交产品中，其主页的“推荐”栏目永远在“关注”栏目的左边。</p>\n<p><img src=\"@source/design/articles/assets/left-or-right-flow.jpg\" alt=\"流量分发\"></p>\n<p>以微博为例，“关注”和“推荐”在信息架构上是类似的，下面都有一些细分类目: “关注”里有不同的分组，“推荐”里也有不同内容类别，例如热门、同城、榜单等。</p>\n<p>但是“关注”用户需要点击下拉框才能筛选，而“推荐”里用户直接右滑就可以切换不同的内容类别；如果把“关注”里的分组也改成滑动切换的样式，那么必然会降低“推荐”栏目的流量。</p>\n<p><img src=\"@source/design/articles/assets/left-or-right-flow2.jpg\" alt=\"流量分发\"></p>\n<p>抖音也是类似的道理，因为用户左滑可以查看作者的主页，如果把推荐栏目放在左边，那么用户左滑就会进入关注栏目。</p>\n<p>引导用户进入已经关注的作者主页，相对来说意义不是很大；抖音的想法是——用户在刷推荐视频的时候，觉得这个视频很好玩，对这个视频的作者产生兴趣；用户可以直接滑动进入作者的主页，而不是需要点击头像才能进入主页。</p>\n<p><img src=\"@source/design/articles/assets/left-or-right-flow3.jpg\" alt=\"流量分发\"></p>\n<p>微博和抖音的“左关注，右推荐”的模式都是为了往推荐栏目引流。</p>\n<p>社交产品追求的是用户可以在这个产品里建立更多关系链，关系链是社交产品的护城河；既然这个人您已经关注了，说明关系链已经形成，那就没有必要引流了。</p>\n<p>从这里我们也能看出，在考虑方案的时候，不仅仅要考虑交互易用性，更要着眼于流量分配——哪个方案的流量分配更符合您的诉求，哪个就是好的方案。</p>\n<p>甚至在很多时候，当交互易用性跟流量分配相冲突时，交互易用性是被牺牲的一方，因为流量代表了产品经理的 KPI。</p>\n<p><img src=\"@source/design/articles/assets/left-or-right-flow4.jpg\" alt=\"流量分发\"></p>\n<p>最典型的例子就是知乎为了给答案底部的广告引流把左右滑动切换答案改成了上下滑动；当然，我们也不能批判知乎的这种行为。</p>\n<p>还是回到对话框的话题，“确定按钮到底在左边还是右边? ”，最好的办法就是 A/B 测试；如果是一个引导用户安装 APP 的对话框，您就看“确定”按钮放在哪边可以带来更多的转化率。</p>\n<p>这个 A/B 测试，搜狗输入法曾经做过，结果显示: 确定按钮放在左边转化率更高，误操作率更低，操作平均时长也更短；那么我们是否可以说，以后“确定”按钮就放在左边了?</p>\n<p>当然不可以，因为这个测试是在安卓 4.0 时期进行的；安卓 4.0 之前的系统对话框的确定按钮是在左边的，4.0 才改成右边——用户之前的操作习惯会影响测试结果。</p>\n<p>还有一个因素就是设备尺寸，手机尺寸现在越来越大，用户需要双手握持手机；那么在双手操作的模式下，手指可以全覆盖屏幕，那么右边的易用性就没那么高了。</p>\n<p>总之，同一个交互问题，在不同的设备，系统，时间和场景下，会有不同的答案。</p>\n",
      "date_published": "2020-09-26T00:00:00.000Z",
      "date_modified": "2022-08-20T08:54:00.000Z",
      "authors": [],
      "tags": [
        "设计"
      ]
    },
    {
      "title": "图标",
      "url": "https://github.com/MisterChen9527/design/icon/",
      "id": "https://github.com/MisterChen9527/design/icon/",
      "summary": "本文介绍了 UI 设计中图标的相关介绍与技巧。\n",
      "content_html": "<p>本文介绍了 UI 设计中图标的相关介绍与技巧。</p>\n\n<h2 id=\"图标网站\" tabindex=\"-1\"> 图标网站</h2>\n<ul>\n<li>\n<p><a href=\"https://www.iconfont.cn/\" target=\"_blank\" rel=\"noopener noreferrer\">iconfont</a></p>\n<p>阿里妈妈 MUX 倾力打造的矢量图标管理、交流平台。</p>\n<p>设计师将图标上传到 Iconfont 平台，用户可以自定义下载多种格式的 icon，平台也可将图标转换为字体，便于前端工程师自由调整与调用。</p>\n<p>强大的图标在线编辑与自定义下载</p>\n<p>图标项目的项目管理、协同、分享</p>\n</li>\n</ul>\n<h2 id=\"相关文档\" tabindex=\"-1\"> 相关文档</h2>\n<p>图标是 UI 的设计体系最重要的组成部分之一，是任何 UI 界面中都不可或缺的视觉元素。了解图标相关的概念，以及正确绘制的方法，是入门 UI 设计的必备条件。</p>\n<ul>\n<li>\n<p><a href=\"/design/icon/intro.html\">图标介绍</a></p>\n</li>\n<li>\n<p><a href=\"/design/icon/type.html\">图标种类</a></p>\n</li>\n<li>\n<p><a href=\"/design/icon/guide.html\">图标设计指南</a></p>\n</li>\n<li>\n<p><a href=\"/design/icon/software.html\">图标设计软件</a></p>\n</li>\n<li>\n<p><a href=\"/design/icon/draw.html\">图标绘制流程</a></p>\n</li>\n<li>\n<p><a href=\"/design/icon/rule.html\">图标设计准则</a></p>\n</li>\n<li>\n<p><a href=\"/design/icon/line.html\">线性图标设计演示</a></p>\n</li>\n<li>\n<p><a href=\"/design/icon/flour.html\">面性图标设计指南</a></p>\n</li>\n<li>\n<p><a href=\"/design/icon/decorative.html\">装饰性图标设计指南</a></p>\n</li>\n<li>\n<p><a href=\"/design/icon/start.html\">启动图标设计指南</a></p>\n</li>\n<li>\n<p><a href=\"/design/icon/skill.html\">图标设计技巧</a></p>\n</li>\n<li>\n<p><a href=\"/design/icon/apply.html\">图标实践注意事项</a></p>\n</li>\n</ul>\n<h2 id=\"相关要求\" tabindex=\"-1\"> 相关要求</h2>\n<ul>\n<li>\n<p>了解图标的常见设计准则</p>\n<ul>\n<li>\n<p>能够对一个图标的好坏做出评判。</p>\n</li>\n<li>\n<p>了解不同的图标风格</p>\n</li>\n<li>\n<p>能够从现有图表库中中选取合适的图标应用到项目中。</p>\n</li>\n</ul>\n</li>\n<li>\n<p>简单了解图标的制作软件与制作方式</p>\n<ul>\n<li>\n<p>能够制作简单的图标</p>\n</li>\n<li>\n<p>在项目拥有一套完善图标风格，但部分图标存在缺失时能够自制图标补全。</p>\n</li>\n</ul>\n</li>\n</ul>\n",
      "date_published": "2020-09-13T00:00:00.000Z",
      "date_modified": "2022-08-20T08:54:00.000Z",
      "authors": [],
      "tags": [
        "设计"
      ]
    },
    {
      "title": "图标应用",
      "url": "https://github.com/MisterChen9527/design/icon/apply.html",
      "id": "https://github.com/MisterChen9527/design/icon/apply.html",
      "summary": "在 UI 设计中，图标不是孤立存在的。我们学习图标的设计，不是为了画一组套图，然后上传到设计平台中分享或求赞，而是要在真实的项目中发挥作用。如果不了解图标应用到项目中的知识点，那么真实的图标设计水平就会在项目设计过程中被损耗。\n所以，本章讲述工具图标在项目中应用的方法。\n",
      "content_html": "<p>在 UI 设计中，图标不是孤立存在的。我们学习图标的设计，不是为了画一组套图，然后上传到设计平台中分享或求赞，而是要在真实的项目中发挥作用。如果不了解图标应用到项目中的知识点，那么真实的图标设计水平就会在项目设计过程中被损耗。</p>\n<p>所以，本章讲述工具图标在项目中应用的方法。</p>\n\n<h2 id=\"一套应用中的图标规格\" tabindex=\"-1\"> 一套应用中的图标规格</h2>\n<p>图标是一个应用不可或缺的组成元素，在应用的界面中随处可见。也因为图标的常见性，我们往往需要在一个应用中应用多套图标，这和崇尚简约的第一印象是有背离的。</p>\n<p>很多新手，都以为我们只要设计一套大而全的图标，在项目中对应提取即可。但有很多场景，如果只使用一种图标类型，那么效果会非常差劲。比如，我们看看下面的淘宝设置页，前后包含了 6 种以上的图标。是太复杂了没错，但如果我们把图标都替换成同一套呢?</p>\n<p><img src=\"@source/design/icon/assets/place-same.jpg\" alt=\"替换淘宝图标\"></p>\n<p>可以看见，右侧替换后的案例，效果非常的不理想，缺乏对比和趣味性。交互规则中说: 如无必要，勿增实体，但对于图标的使用来说，这就是必要。</p>\n<hr>\n<p>应用内的图标规格不同，可以用两个属性来划分，大小和风格。</p>\n<h3 id=\"图标的尺寸\" tabindex=\"-1\"> 图标的尺寸</h3>\n<p>大小就是图标的尺寸规格，有些界面的元素权重低，图标的尺寸就小，有些权重高的则反之。比如在 Apple Music 的播放界面，播放快进等按钮，作为页面最重要的按钮，尺寸非常大，其它可以点击的图标次之，而表示音量的两个按钮则最小。</p>\n<p><img src=\"@source/design/icon/assets/icon-size.jpg\" alt=\"图标尺寸\"></p>\n<p>确定图标尺寸，是我们在项目中进行图标设计的第一件事。但尺寸的确定，不是我们凭空制定出来的，我们要先构建出实际的「场景」进行分析，即先完成了界面的高保真原型或交互原型。</p>\n<p>下方是一个原型演示，在构建了这样的页面以后可以在原型中检查，总共用了多少种图标的尺寸，它们分别会应用在哪些场景中，然后整理出来。如果出现了一些觉得没有必要的，可以将它们进行调整合并成一种尺寸。</p>\n<p><img src=\"@source/design/icon/assets/icon-template.jpg\" alt=\"图标模板\"></p>\n<p>所以，在这个案例中，我整理出了 4 种图标的尺寸:</p>\n<ul>\n<li>48pt: 分类、快速入口大图标</li>\n<li>32pt: 底部 TabBar 图标</li>\n<li>24pt: 常规工具图标</li>\n<li>16pt: 小型提示图标</li>\n</ul>\n<p>定好了这 4 种规格，我们在后续的设计上才有明确的设计方向。再复习一遍，为什么我们需要先定尺寸再设计，而不是统一设计一套很大的图标进行缩小。</p>\n<p>因为图标要尽可能满足像素对齐的要求，通过缩小的图标往往在细节上会发生错位、模糊、丢失等问题。且在大画布上设计图标和一开始就在小画布中设计，两者在过程中得到的视觉反馈是完全不一样的，先在大画布画完，再缩小到 16pt、12pt 的规格时往往会显得太复杂，或描边太粗。</p>\n<h3 id=\"图标的风格\" tabindex=\"-1\"> 图标的风格</h3>\n<p>图标尺寸确认完以后，下面就是确认图标的风格了，和尺寸一样，我们要应用什么风格的图标，是需要在已经具备视觉雏形的页面中对比确定的，而不能提前开始设计。</p>\n<p>在正常的设计流程中，通常会将图标放在项目的最后再开始设计，原因就是图标的视觉样式风格是取决于所处位置和环境的，是「先有界面样式，再有图标风格」的。</p>\n<p>在常规情况下，如果一个应用中有多套图标，那么普通的中小尺寸图标使用一般的线性或面性风格即可。而在分类、快速入口这些具备装饰性、大尺寸的类型中，就应该使用一些更激进的设计风格。比如下图是 58 同城客户端应用图标案例:</p>\n<p><img src=\"@source/design/icon/assets/58icon.jpg\" alt=\"58 同城图标\"></p>\n<p>通常，一种风格会应用在一种「类别」的图标中。上方案例属于比较理想的状态，一种类别的图标对应一种尺寸，但是在一些更复杂的环境中，往往同一种尺寸下还会包括不同类别的图标。</p>\n<h2 id=\"图标的不同状态\" tabindex=\"-1\"> 图标的不同状态</h2>\n<p>图标在一个产品中，除了充当装饰以外，往往也可以作为按钮来使用。每个应用中都有大量的图标可以进行点击和交互，比如底部导航栏，头部的消息图标、发布图标等等。</p>\n<p>当一个图标能被操作后，那么我们就要注意到它的状态变化。从导航栏图标举例，常规的选中状态是更换色彩，但也有越来越多的应用会在选中状态采取不同的设计风格，通过更丰富的样式表现来提升可看性。比如淘宝、QQ 的底部导航栏。</p>\n<p><img src=\"@source/design/icon/assets/icon-change.jpg\" alt=\"改变图标状态\"></p>\n<p>还有，一些包含在控件内的图标，也会跟随控件状态的变更发生变更。例如在账号输入框中，如果选中了输入框，那么图标的色彩也得到改变。如果输入框目前处于不可输入状态，那么图标也会对应置灰。</p>\n<p><img src=\"@source/design/icon/assets/icon-change2.jpg\" alt=\"改变图标状态\"></p>\n<p>合格的 UI 设计师会充分考虑到图标所变换的各种状态，并在提交给开发的过程中会进行详细的说明、归类。以及，充分运用 Sketch 等软件中的组件功能，提升项目的效率和最后的产出成果。</p>\n<p><img src=\"@source/design/icon/assets/sketch.jpg\" alt=\"提升效率\"></p>\n<h2 id=\"图标的标注和切图\" tabindex=\"-1\"> 图标的标注和切图</h2>\n<p>在我们完成了界面和图标的设计以后，要提交我们的设计给开发人员。其中，包含我们的标注和切图。抛开其它设计元素不谈，我们就讲讲图标的切图需要遵循哪些规范，它和字体都是在这个过程中最容易出错的地方。</p>\n<p>应用图标的导出我们已经在上一章提到过，所以下面还是以工具图标的说明为主。</p>\n<h3 id=\"图标的边界\" tabindex=\"-1\"> 图标的边界</h3>\n<p>我们要回到第二章工具图标的规范中，当我们确定出图标的尺寸时，不是要把图形设计得正好撑满这个尺寸，而是利用格线系统来定义它们的大小。</p>\n<p>很多新人会在这个过程中产生疑惑，那么在标注的过程中，我们标注的到底是图形到其它元素的距离，还是图标外轮廓到别的图形的距离。</p>\n<p>其实，图标的距离是根据外部轮廓进行计算的。虽然这个轮廓我们肉眼不可见，但它包含的内在规律可以帮助我们忽略一些不必要的小问题。</p>\n<p><img src=\"@source/design/icon/assets/border.jpg\" alt=\"图标的边界\"></p>\n<p>所以，要让标注有效，就一定不要偷懒只把图标置入画布中，而没有透明矩形背景。</p>\n<h3 id=\"图标的画布\" tabindex=\"-1\"> 图标的画布</h3>\n<p>现在有很多帮助我们进行标注和切图的协作工具，比如蓝湖、Zeplin 等。我们只要将设计稿上传，程序员可以自行获取图标对应的切图。</p>\n<p>在裁切一些特定元素时很好用，但通过线上页面导出图标的方法，是非常不牢靠的。我们说过，一个应用中可能出现多种规格的图标，所以合理的图标切图，要根据不同的规格进行导出和整理，而不是让程序员自己在线上工具中下载，这样不仅操作起来困难，而且图标间不同的状态难以被轻易获取。</p>\n<p>所以，要在项目设计过程中，创建不同规格的画布(Symbol)并将它们分类排列，不仅利于我们对以后图标的调用，也方便在最后批量导出切图到对应文件夹中。</p>\n<h3 id=\"图标的命名\" tabindex=\"-1\"> 图标的命名</h3>\n<p>下面我们简单讲讲图标的命名规则。有很多新手和刚入职场的 UI 设计师会不明就里的强调图标一定要用英文命名，并且各种收集常见的英文命名词汇，我首先要指出这种做法是错误的。</p>\n<p>因为涉及到整个应用的图标系统时，会出现大量寓意「抽象」的图标。比如在我上方案例中，有一个启动图标的中文名是「中二」，那么这个词应该如何翻译? 即使不受制于英文水平的发挥，但是您写的英文不代表开发人员能看得懂，而大量抽象词汇的堆积最后导致命名无法成为有效的索引条件，因为没人看得懂，开发需要查找一个图标的时候依旧是通过缩略图而不是命名。</p>\n<p>所以，在内部没有具体的命名规范，亦或是程序员没有特殊要求的情况下，更建议使用中文命名系统，因为国内多数程序员的习惯会将获取的图标进行二次命名。</p>\n<p>命名的格式可以分成 3 级，格式大致为: 「模块_名称_状态@1x」，比如下面的案例:</p>\n<ul>\n<li>设置_钱包_高亮@1x.png</li>\n<li>动态_评论_默认@1x.png</li>\n<li>登录_按钮_点击@2x.png</li>\n</ul>\n<p>当然，这不是唯一准确的命名方式，可以根据实际场景自由调整，但大家要牢记，图标的命名是为了方便查找、检索。</p>\n<p>最后，图标 Symbol 的命名，要和图标的命名保持一致，这样才能起到事半功倍的效果。</p>\n<p><img src=\"@source/design/icon/assets/name-example.jpg\" alt=\"命名示例\"></p>\n<h3 id=\"图标的格式\" tabindex=\"-1\"> 图标的格式</h3>\n<p>上一章启动图标的导出格式，会根据不同设备、场景导出不同的尺寸，并且使用 PNG 的格式。不要担心，工具图标虽然也面临设备不同的问题，但不需要导出这么多的规格。下面讲讲两种图标的导出类型。</p>\n<h4 id=\"位图格式\" tabindex=\"-1\"> 位图格式</h4>\n<p>最常用的导出格式就是位图 PNG 格式，因为显示器显示倍率的不同，所以我们要导出 1x、2x、3x 三种倍率规格的图片，即设计了 16pt 的图标的话，我们需要导出 16pt、32pt、48pt 三种尺寸。并在导出的文件名后缀上标有 @1x、@2x、@3x 的标注。</p>\n<p><img src=\"@source/design/icon/assets/png-export.jpg\" alt=\"位图导出\"></p>\n<p>这个规格对于 iOS 还是 Android 都是通用的，虽然还有 3x 以上的设备，但是那些设备只要调用 3x 的规格即可。</p>\n<p>虽然后面会提图标可以使用矢量格式导出，但对于使用了渐变、投影或者拟物风格的图标，必须使用位图的格式，否则无法完整记录图形的细节元素。</p>\n<h4 id=\"矢量格式\" tabindex=\"-1\"> 矢量格式</h4>\n<p>导出 3 种规格的图标很麻烦，而且位图占用的空间往往较大。所以，iOS 和 Android 为了优化这个问题，在之前的系统更新中都默认支持了矢量格式的切图文件:</p>\n<ul>\n<li>iOS 使用 PDF 的 1x 切图</li>\n<li>Android 使用 SVG 的 1x 切图</li>\n</ul>\n<p>当然，如果使用矢量格式导出，那么切记在分类文件夹的时候，要将 iOS 和 Android 分开保存，而不是混合在一起。</p>\n",
      "date_published": "2020-09-14T00:00:00.000Z",
      "date_modified": "2022-08-20T08:54:00.000Z",
      "authors": [],
      "tags": [
        "设计"
      ]
    },
    {
      "title": "装饰性图标设计",
      "url": "https://github.com/MisterChen9527/design/icon/decorative.html",
      "id": "https://github.com/MisterChen9527/design/icon/decorative.html",
      "summary": "装饰图标最主要的应用区域，集中在首页的快速入口上，也是今天多数应用中会使用的组件。下面，我们会讲解国内主流应用中的几种装饰图标的设计。\n",
      "content_html": "<p>装饰图标最主要的应用区域，集中在首页的快速入口上，也是今天多数应用中会使用的组件。下面，我们会讲解国内主流应用中的几种装饰图标的设计。</p>\n\n<p><img src=\"@source/design/icon/assets/decorate-type.jpg\" alt=\"装饰图标分类\"></p>\n<h2 id=\"扁平插画风格\" tabindex=\"-1\"> 扁平插画风格</h2>\n<p>装饰图标的主要作用是丰富视觉体验，对于识别性的要求较低，所以我们可以在这里应用更复杂的图形和添加更多的细节。在这里的扁平插画风格设计更具象，而不是像工具图标一样的抽象化，所以完整的采用扁平插画的设计是没问题的。</p>\n<p>例如在肯德基客户端首页的服务分类中，使用的图标就是依据扁平插画的形式设计的，有较多的色彩和完整的细节。</p>\n<p><img src=\"@source/design/icon/assets/KFC.jpg\" alt=\"肯德基设计图\"></p>\n<p>这类图标的设计并不困难，只要具备了工具图标的设计基础，就可以很快学会并运用。它的设计特征是这样的，先通过绘制具体的图形轮廓，然后为这个轮廓内添加细节，并对不同的面填充不同的色彩进行区分。</p>\n<p>下面，我们通过讲解几个图标的设计过程，帮助大家学习这种设计风格。</p>\n<ol>\n<li>\n<p>优惠券图标</p>\n<p>先通过模拟现实世界的优惠券样式，确定出基本的线性轮廓。</p>\n<p><img src=\"@source/design/icon/assets/KFC-ticket1.jpg\" alt=\"优惠券1\"></p>\n<p>但作为装饰图标来说，这样的设计目前有些简陋，左侧空出了大量的留白，所以我们要考虑如何增加细节来丰富这个区域。于是，使用 % 号就可以比较好的标示折扣。</p>\n<p><img src=\"@source/design/icon/assets/KFC-ticket2.jpg\" alt=\"优惠券2\"></p>\n<p>最后，开始为图标填色。因为在这套图标中，红色是主要基调，所以我们不能大面积的使用其它颜色，于是就将其中一侧进行留白处理，只修改了它描边的色彩。并且还在票据两侧的连接处添加了一个用来标示阴影的竖线。</p>\n<p><img src=\"@source/design/icon/assets/KFC-ticket3.jpg\" alt=\"优惠券3\"></p>\n</li>\n<li>\n<p>店铺图标</p>\n<p><img src=\"@source/design/icon/assets/shop.jpg\" alt=\"店铺图标\"></p>\n</li>\n<li>\n<p>我的卡包图标</p>\n<p><img src=\"@source/design/icon/assets/wallet.jpg\" alt=\"我的卡包\"></p>\n</li>\n</ol>\n<h2 id=\"渐变几何背景\" tabindex=\"-1\"> 渐变几何背景</h2>\n<p>和其它风格比较，在快速入口中，线上案例应用得最多的风格其实是渐变几何背景的设计方案，即在一个应用渐变色的背景上贴了一个线性或面性的图标。</p>\n<p><img src=\"@source/design/icon/assets/gradient-background.jpg\" alt=\"渐变几何背景\"></p>\n<p>这种风格的设计，主要在于背景渐变色的应用，通常，在一组彩色快速入口的图标中，要让它们的渐变色看起来自然和谐，是需要技巧的。</p>\n<p>例如有四个图标，首先要定义出不同的色相，然后再对它们应用相同的渐变模式。例如，使用相同的渐变角度，然后在渐变的起始色使用该色相，在结尾使用不同明度、饱和度的色彩。</p>\n<p><img src=\"@source/design/icon/assets/gradient-background2.jpg\" alt=\"渐变几何背景1\"></p>\n<p>之后，再在上方置入图标的图形，并为它们添加适当的阴影即可。</p>\n<p><img src=\"@source/design/icon/assets/gradient-background3.jpg\" alt=\"渐变几何背景2\"></p>\n<p>如果在这个基础上，还想再添加细节，那么就可以在上方的图形中添加一些折叠的阴影效果，强化立体感。</p>\n<p><img src=\"@source/design/icon/assets/gradient-background4.jpg\" alt=\"渐变几何背景3\"></p>\n<h2 id=\"炫彩渐变风格\" tabindex=\"-1\"> 炫彩渐变风格</h2>\n<p>这是一个比较奇特的设计风格，在过去只存在于飞机稿中，是一种单纯为了追求视觉表现力的设计形式，通过高饱和的渐变、撞色，抓取浏览者的眼球。</p>\n<p><img src=\"@source/design/icon/assets/shine.jpg\" alt=\"炫彩渐变风格\"></p>\n<p>这类风格的设计，在确定了图形以后，就是为它们填充高饱和度的渐变色。和扁平插画比较不同的是，色彩的填充不是用来描绘物体的颜色，而仅仅是视觉表现的一种方法，所以颜色的添加追求的不是「合理」，而是纯粹的「好看」。</p>\n<p>并且，通常这类图标还会使用前两年开始流行的彩色投影，增加界面本身的层次感。下面，我们也通过 3 个案例，为大家演示一下这类图标设计的过程。</p>\n<p>案例 1:</p>\n<p><img src=\"@source/design/icon/assets/shine1.jpg\" alt=\"炫彩渐变风格1\"></p>\n<p>案例 2:</p>\n<p><img src=\"@source/design/icon/assets/shine2.jpg\" alt=\"炫彩渐变风格2\"></p>\n<p>案例 3:</p>\n<p><img src=\"@source/design/icon/assets/shine3.jpg\" alt=\"炫彩渐变风格3\"></p>\n<h2 id=\"实物贴图风格\" tabindex=\"-1\"> 实物贴图风格</h2>\n<p>最后，讲讲实物贴图的图标风格。这种图标出现在涉及到实物产品的应用中，例如电商应用，智能硬件控制应用等等。</p>\n<p><img src=\"@source/design/icon/assets/good.jpg\" alt=\"实物贴图风格\"></p>\n<p>这类设计看起来很简单，只要画出一个几何的背景，并建立蒙版将实物图置入进去即可，但还是有不少新手会犯错误，下面我们主要说说常见的问题有哪些。</p>\n<ol>\n<li>\n<p>物体的透视</p>\n<p>和工具图标一样，我们要尽可能的保证整组图标中图形的形状和透视可以统一，如果实物图采用的透视不一致，那么空间的对立感就更强，也容易被用户觉察到违和感。</p>\n<p><img src=\"@source/design/icon/assets/good1.jpg\" alt=\"实物贴图风格1\"></p>\n</li>\n<li>\n<p>形体和比例</p>\n<p>当我们采用实物照片时，我们往往不能控制该物体完整的形状，但需要切记的是，不是物体本身是什么形状我们都要完整的置入进去。</p>\n<p>比如入口中有口红和香水两种，口红是细长的而香水是圆形，那么我们可以做的就是放大口红，最终只展示它的局部，否则它们的对比会完全失衡。</p>\n<p><img src=\"@source/design/icon/assets/good2.jpg\" alt=\"实物贴图风格2\"></p>\n</li>\n<li>\n<p>图形的质感</p>\n<p>实物的图形，还有一个非常重要的细节，就是它们的质感。这种质感指的不是物体本身的材质，而是摄影、后期产生的质感。如下图的对比，同一件商品，手机直出的图，和经过商品精修的图，展现出来的质感是完全不一样的。</p>\n<p><img src=\"@source/design/icon/assets/good3.jpg\" alt=\"实物贴图风格3\"></p>\n<p>如果强行将有精修痕迹和普通照片抠出来的商品放到一起，也只能给用户产生巨大的违和感。所以，如果提供给我们的素材本身质感不同，那么我们就要在 PS 中对它们进行调试，尽可能保证它们的一致。</p>\n</li>\n<li>\n<p>前后对比</p>\n<p>因为是摄影图，所以图形本身包含的细节会非常丰富，而且色彩也可能比较多。在采用了几何背景时，就要保证它能更好地衬托主体物。如果使用较强的颜色，或是太多细节，就会导致前后元素的分离度不足，无法凸显物体本身。所以，多数采用这种风格的设计案例中，背景用色都使用饱和度偏低的配色。</p>\n<p><img src=\"@source/design/icon/assets/good4.jpg\" alt=\"实物贴图风格4\"></p>\n</li>\n</ol>\n<p>只要不犯上面 4 种错误，那么设计这类图标时，就能保证最终的效果不会太差。</p>\n<h2 id=\"小结\" tabindex=\"-1\"> 小结</h2>\n<p>掌握以上这种风格的画法，已经可以应对绝大多数的需求和场景了。但这并不是终点，应用对于视觉风格的追求愈发的重要，想要尝试更多的设计风格，那么就需要掌握更多种装饰类图标的设计方法。需要大家在之后的时间里努力积累相关的技巧和思路。</p>\n",
      "date_published": "2020-09-14T00:00:00.000Z",
      "date_modified": "2022-08-20T08:54:00.000Z",
      "authors": [],
      "tags": [
        "设计"
      ]
    },
    {
      "title": "图标绘制流程",
      "url": "https://github.com/MisterChen9527/design/icon/draw.html",
      "id": "https://github.com/MisterChen9527/design/icon/draw.html",
      "content_html": "<h2 id=\"情绪板\" tabindex=\"-1\"> 情绪板</h2>\n<p>情绪板是在执行一项设计操作之前非常重要的一个步骤，情绪板并不是像设计平台展示作品集里那样放几张图片，几个关键词，而是一套对接下来设计的一个风格走向定位。根据不同的用户人群，不同颜色的色彩情绪，不同产品的业务，将用户调研的结果，产品的背景进行总结与思考，定位接下来的设计风格。</p>\n<h2 id=\"绘制流程\" tabindex=\"-1\"> 绘制流程</h2>\n<h3 id=\"选取照片\" tabindex=\"-1\"> 选取照片</h3>\n<p>观察生活，对想画的图标进行照片实物造型的提取。图标是对生活中事物的精简概括。利用现实照片作为设计参考可以让绘制出的图标更真实，辨识度更高，还可以做到差异化设计。</p>\n<h3 id=\"造型勾勒\" tabindex=\"-1\"> 造型勾勒</h3>\n<p>使用矢量软件的基本图形与钢笔工具描着照片进行轮廓的绘制。</p>\n<h3 id=\"简化优化\" tabindex=\"-1\"> 简化优化</h3>\n<p>简化草稿轮廓的结构，只保留一个物体的主要特点元素，删除多余元素。优化图标细节，需要时将图标线性转面性。</p>\n<h3 id=\"业务属性\" tabindex=\"-1\"> 业务属性</h3>\n<p>根据业务需要，调整图标风格，添加质感。</p>\n<p><img src=\"@source/design/icon/assets/design-step.jpg\" alt=\"图标制作流程\"></p>\n<h2 id=\"制定规范\" tabindex=\"-1\"> 制定规范</h2>\n<p>无规矩不成方圆，规矩的出现可以让一切杂乱的东西变得合理，统一起来。在设计上也是如此，规范具有统一输出，指引细节、便于查看的好处，规范就是一组图标中的规矩，所有图标的绘制都按照规矩来，最终的成品就会显得井然有序。</p>\n<p>在制定规范时，通常先绘制出一个符合业务风格的图标，然后根据这一个图标定制后续的图标规范，最基本的规范便是描边宽度，断点位置、圆角大小，主色辅色，渐变角度，点缀元素，光影角度等，在一组中的图标需要在这些图形属性中进行统一，这样的图标虽然形状不一样但是在视觉上看起来是属于同一合集的。</p>\n<p>制定规范一般分为三个过程:</p>\n<ul>\n<li>拆分细节: 将图标中的细节元素进行分解，在规范中制定细节元素的使用法则。</li>\n<li>风格定位: 根据产品调性，业务属性在规范中制定相应的色彩心理、质感风格。</li>\n<li>功能划分: 功能相近的包括色彩、质感应该采取相近性。</li>\n</ul>\n",
      "date_published": "2020-09-15T00:00:00.000Z",
      "date_modified": "2022-08-20T08:54:00.000Z",
      "authors": [],
      "tags": [
        "设计"
      ]
    },
    {
      "title": "面性图标设计",
      "url": "https://github.com/MisterChen9527/design/icon/flour.html",
      "id": "https://github.com/MisterChen9527/design/icon/flour.html",
      "content_html": "<p>面性图标在操作中和线性图标的最大差别就在于描边和填充模式，我们知道为了满足像素对齐的要求，线性描边会在操作中产生很多不可控的因素，要用很多额外的操作步骤去弥补。在面性图标中，就不需要使用描边，并且使用相同的图标模板即可。</p>\n<p><img src=\"@source/design/icon/assets/flour-icon.jpg\" alt=\"面性图标\"></p>\n<p>下面就进入本篇的具体案例演示。</p>\n<h2 id=\"基本面性风格\" tabindex=\"-1\"> 基本面性风格</h2>\n<p><img src=\"@source/design/icon/assets/gen-flour-from-line.jpg\" alt=\"使用线性图标生成面性图标\"></p>\n<p>如图所示，我们使用线性图标中的样式，设计成面性效果。具体的操作步骤就不需要再完整演示了，只需要将所有线性风格演示中的描边替换成填充，再使用对应的路径查找器功能即可。</p>\n<p>需要注意的是，可能我们会习惯于使用线条工具绘制很多 1pt 宽的直线，这是错误的做法。我们需要使用矩形工具画出一个完整的闭合图形，再使用路径查找器工具或者对图形进行批量操作，这样才能保证统一。</p>\n<p><img src=\"@source/design/icon/assets/flour-path.jpg\" alt=\"面性图标路径\"></p>\n<p>还有，面性图标不代表完全不能出现「线性」元素，在一些特定的情况下，我们依旧要通过线条的形式展现图形轮廓，比如搜索图标的镜片，使用全填充的样式显然效果不理想，所以镂空镜片区域是不可避免的。</p>\n<p><img src=\"@source/design/icon/assets/flour-search.jpg\" alt=\"面性搜索图标\"></p>\n<p>虽然我们不可避免要使用「线性」的元素，但在面性风格中，这些图形的描边元素不能太细，应该使用不小于 2pt 的宽度。并且，为了保证图标的一致性，整套图标的线条都要尽可能使用相同的粗细，而不是这里使用了 2pt，在别的图标中就是 4pt。</p>\n<h2 id=\"扁平插画风格\" tabindex=\"-1\"> 扁平插画风格</h2>\n<p><img src=\"@source/design/icon/assets/flour-paint.jpg\" alt=\"扁平插画风格\"></p>\n<p>扁平插画风格实际上是一个自由度非常高的图标风格，可以设计出很多有趣又极具创意的插画式图标。在本案例中，我们只讲解其中一种最基础的设计方式，便于新人入门。</p>\n<p>最基础的扁平插画，就是在面性图标的基础上，将图形拆分成不同面的组合，然后分别为这些面填充纯色即可。比如心型图标，看起来像是只有一个面的图形，但我们可以人为居中将它分割成两个面，然后填充同色系的不同明度，就可以得到一个扁平插画风格的图标。</p>\n<p><img src=\"@source/design/icon/assets/flour-heart.jpg\" alt=\"爱心示例\"></p>\n<p>类似搜索或消息图标这样有镂空区域的图标，我们就可以为镂空区域填充不同的色彩，使其作为独立的面呈现，也能达到相同的风格。</p>\n<p><img src=\"@source/design/icon/assets/flour-search2.jpg\" alt=\"搜索示例\"></p>\n<p>最后一种，就是将图标「拟真」化。比如眼睛图标，我们可以用接近真实眼睛的样式来创作，为它增加瞳孔、高光等细节，只要依旧使用纯色填充，且将细节数量保持在合理的范围内，就不会与其它图标产生冲突。</p>\n<p><img src=\"@source/design/icon/assets/flour-eye.jpg\" alt=\"眼睛示例\"></p>\n<h2 id=\"彩色渐变风格\" tabindex=\"-1\"> 彩色渐变风格</h2>\n<p><img src=\"@source/design/icon/assets/gradient.jpg\" alt=\"彩色渐变风格\"></p>\n<p>在面性图标的彩色渐变中，有多种更细致的设计类型，比如整个图标采用同一渐变，或者图标中不同的面采取不同的渐变方式。</p>\n<p>整个图标使用同一渐变色的做法，和线性图标的渐变方法几乎一样，只要在开始填充渐变前将所有图层进行合并即可。我们来讲解一个比较特殊的基础渐变风格——不同透明度渐变。</p>\n<p>比如心形图标，我们把它划分成了两个不同的面的组合，然后都使用了红色的渐变色，一强一弱。通常，我们只要先设定出较强的渐变，然后再复制这个渐变色到另一个面中，降低它的透明度即可。</p>\n<p><img src=\"@source/design/icon/assets/gradient-design.jpg\" alt=\"渐变设计\"></p>\n<p>在使用了透明度的图形中，要注意的是为了保证在实际使用中不让图形背面的元素影响到图标色彩本身，我们要将这些图形复制一层填充成白色并置于底部。</p>\n<h2 id=\"透明叠加风格\" tabindex=\"-1\"> 透明叠加风格</h2>\n<p><img src=\"@source/design/icon/assets/transparent-add.jpg\" alt=\"透明叠加风格\"></p>\n<p>最后，就是这类透明叠加的设计风格了。和线性图标中的叠加设计方式一样，我们需要将图形拆分成若干面，才能创造出重叠的区域。</p>\n<p>在这个方案中，图标尽可能使用纯色，会比使用渐变的效果更好，原因在于我们对重叠区域色彩的控制上。可能很多同学看到这个风格，会以为叠加的区域只要控制透明度就可以了，但这种效果通常很不理想，尤其在配色为撞色上，相交部分的色彩就会有「朦胧」感，缺少通透的舒适性，并且图形本身的饱和度也会受到影响，比如下面的演示:</p>\n<p><img src=\"@source/design/icon/assets/transparent-add2.jpg\" alt=\"透明叠加设计1\"></p>\n<p>通常，相交区域的色彩要另外配置。也就是在绘制好图形的所有轮廓以后，将它们一起选中，然后使用「图像生成工具」，再为相交的区域单独选择配色。下图就是单独挑选的两个配色和透明度的方式对比。</p>\n<p><img src=\"@source/design/icon/assets/transparent-add3.jpg\" alt=\"透明叠加设计2\"></p>\n<h2 id=\"总结\" tabindex=\"-1\"> 总结</h2>\n<p>相对于线性图标的设计而言，面性工具图标的设计就简单很多，虽然设计风格有非常多的延展性和可能性，但大家始终要记得它们依旧是「工具图标」，识别性是优先于视觉风格的，所以切勿过度强调视觉性而将它们做成了装饰性图标。</p>\n",
      "date_published": "2020-09-13T00:00:00.000Z",
      "date_modified": "2022-08-20T08:54:00.000Z",
      "authors": [],
      "tags": [
        "设计"
      ]
    },
    {
      "title": "图标设计指南",
      "url": "https://github.com/MisterChen9527/design/icon/guide.html",
      "id": "https://github.com/MisterChen9527/design/icon/guide.html",
      "content_html": "<h2 id=\"图标的可用性\" tabindex=\"-1\"> 图标的可用性</h2>\n<p>图标可用性，顾名思义就是图标绘制出来是否能被用户所看懂并快速识别，是否可以为业务赋能。以下是总结的四条图标绘制的评判标准。</p>\n<p><img src=\"@source/design/icon/assets/rule.jpg\" alt=\"图标绘制的评判标准\"></p>\n<h3 id=\"凸显性\" tabindex=\"-1\"> 凸显性</h3>\n<p>用户是否能在某页面上迅速找到该图标，凸显性的目的是可以快速查找，帮助用户做选择。图标在识别的速度上远远大于文字，所以在一些页面中的重要功能使用图标的目的是为了吸引用户的注意力，让重要功能得到凸显，提高重要功能的点击率。</p>\n<h3 id=\"可识别性\" tabindex=\"-1\"> 可识别性</h3>\n<p>图标的目的是要让用户猜出他看到的图标所表达的意义，有什么作用，以及点击后会出现什么样的场景，发生什么样的事情。所以一个图标的好与坏最重要的因素就体现在这里: 图标的可识别性与可预知性。</p>\n<div><p>影响图标可识别性的三点因素</p>\n<ul>\n<li>视觉复杂性: 图标的细节与组合图形的元素</li>\n<li>熟悉性: 图标中图形所表达语义的熟悉程度</li>\n<li>具体性: 图标或者图标中的图形与现实生活中物体的相似程度</li>\n</ul>\n</div>\n<h3 id=\"美观度\" tabindex=\"-1\"> 美观度</h3>\n<p>图标是否美观，对用户是否有足够的吸引力。在《设计通用法则》一书中有一条设计法则是: 美即适用效应。不管任何事物，美丽的外表都会给人带来好感，让人觉得这种事物在任何方面都非常美好。作为设计师，把一件事物美观化是一件终生的必修课，用户对图标或者界面的第一印象就是始于颜值。</p>\n<h3 id=\"业务属性\" tabindex=\"-1\"> 业务属性</h3>\n<p>图标是否符合业务属性，是否可以唤起用户的使用情绪，提高点击率，起到为业务赋能的作用。在界面中图标最终目的不只是让用户觉得它美观，而是要为产品赋能，什么是为产品赋能呢? 通俗来说就是使图标能够提升点击率从而给公司创造收益。</p>\n<h3 id=\"图标如何为产品赋能\" tabindex=\"-1\"> 图标如何为产品赋能</h3>\n<ul>\n<li>\n<p>符合产品与业务属性: 比如儿童类产品，图标就要圆滑，多彩，看起来萌一点的感觉；如果是金融类的产品就应该使用微圆角，直角，中性色，金色来代表金融的庄严感与高级感。</p>\n</li>\n<li>\n<p>唤起用户的使用情绪: 比如在大众点评 app 中，有关与食品的图标都使用橙色的拟物，因为暖色可以给人们带来食欲感，微拟物配合暖色系就可以唤起用户对食品的情绪感。</p>\n</li>\n<li>\n<p>引导用户点击，提升点击率: 想要让用户点击一个内容，那必须要有足够的吸引力吸引用户去点击，一般来说美观度越高、趣味元素越多的图标可以占据大部分的吸引力，一个图标在页面中所占的比例也会影响对用户的吸引力，合理的文案搭配也会吸引用户去点击，比如优惠信息，新功能提示等。</p>\n</li>\n</ul>\n<h2 id=\"图标类型选取\" tabindex=\"-1\"> 图标类型选取</h2>\n<h3 id=\"线性图标\" tabindex=\"-1\"> 线性图标</h3>\n<p>线性图标，顾名思义，即图标是由直线、曲线、点在内等元素组合而成的图标样式。</p>\n<p><strong>优点</strong>:</p>\n<p>线性图标辨识度高，清晰唯美，简约易看，不会对页面造成太多的视觉干扰。</p>\n<p><strong>缺点</strong>:</p>\n<p>线性图标的创作空间较少，太复杂的线性图标看起来会让人感觉到累。</p>\n<h3 id=\"面性图标\" tabindex=\"-1\"> 面性图标</h3>\n<p>面性图标，即使用对图形内容进行色彩填充的图标样式。</p>\n<p><strong>优点</strong>:</p>\n<p>面性图标是现实生活中物体的缩影，其表意能力强，细节丰富，色彩丰富，情绪感强，视觉突出，创作空间大等。面性图标可以让用户迅速定位图标位置，快速预知点击后的状态。</p>\n<p><strong>缺点</strong>:</p>\n<p>面性图标在页面中不可过多出现，否则会造成页面臃肿，难分主次，用户视觉疲劳。</p>\n<h3 id=\"混合型图标\" tabindex=\"-1\"> 混合型图标</h3>\n<p>在设计图标类型的时候，不一定局限于单纯的线性与面性，也可以两者结合，让图标即有线性描边的轮廓，还有色彩填充的区域。</p>\n<p>混合型图标可以让页面变得更加有活力，同时还可以吸引用户的注意力，美观与创意性强。</p>\n<p>但是混合型图标在商业产品中要谨慎使用，因为使用不当会让页面变得杂乱不堪，用户无法识别图标表达的语义。</p>\n<p><img src=\"@source/design/icon/assets/icon-type.jpg\" alt=\"不同图标类型\"></p>\n<h2 id=\"图标的色彩\" tabindex=\"-1\"> 图标的色彩</h2>\n<h3 id=\"色彩情绪\" tabindex=\"-1\"> 色彩情绪</h3>\n<p>色彩情绪即颜色心理，指不同波长色彩的光信息作用于人的视觉器官，通过视觉神经传入大脑后，经过思维，与以往的记忆及经验产生联想，从而形成一系列的色彩心理反应。在任何场景下合理使用色彩心理可以调起用户情绪，还可以让用户产生联想进而快速识别。</p>\n<p>在设计图标的时候，合理的运用色彩情绪，会使图标更具有科学性，可以让用户在使用的过程中更加自然、舒服，同时也会增加用户的识别速度唤起用户的使用情绪。</p>\n<div><p>色彩情绪表</p>\n<p><img src=\"@source/design/icon/assets/color-emotion.jpg\" alt=\"色彩情绪表\"></p>\n</div>\n<h3 id=\"配色方法\" tabindex=\"-1\"> 配色方法</h3>\n<p>在配色时，应采用更具备科学性、更符合人类感官的 HSB 系统进行配置。在根据主色配置渐变色时，通常在主色的基础上加白或者加黑。但是只加入大量的白或者黑就会改变原本色彩的明度与饱和度，从而使画面显得雾蒙蒙的，不够清晰通透。正确的做法是在给主色变亮减暗的同时，改变主色的饱和度。在 hsb 色相条中，最亮的三个颜色分别是，蓝紫色，青绿色与黄色，如果需要加亮主色就在混白的同时将蓝色向青色改变色相，如果需要减暗则是相反，这样在调制渐变色变化的过程中不会出现太脏的颜色。</p>\n<p><img src=\"@source/design/icon/assets/color-plan.jpg\" alt=\"色调\"></p>\n<h3 id=\"配色方案\" tabindex=\"-1\"> 配色方案</h3>\n<h4 id=\"常见的色彩搭配\" tabindex=\"-1\"> 常见的色彩搭配</h4>\n<ul>\n<li>中性色(黑白) + 主色</li>\n<li>主色 + 点缀色</li>\n<li>主色 + 透明度</li>\n<li>单渐变</li>\n<li>双渐变错层</li>\n<li>撞色叠加穿透等</li>\n</ul>\n<p>一般常用的就是 中性色 + 主色、主色 + 点缀色。</p>\n<h4 id=\"点缀色配色\" tabindex=\"-1\"> 点缀色配色</h4>\n<ul>\n<li>互补色: 互补色就是在色环上距离 180° 的色彩，形成具有视觉冲击力的色彩。</li>\n<li>近似色: 近似色是在色环上距离 45° 左右的色彩，形成的配色效果风格和谐统一。</li>\n<li>对比色: 对比色是在色环上 120° 左右的色彩，可以产生较为强烈鲜明的视觉效果。</li>\n</ul>\n<p><img src=\"@source/design/icon/assets/color-rule.jpg\" alt=\"色调\"></p>\n<h2 id=\"图标绘制技巧\" tabindex=\"-1\"> 图标绘制技巧</h2>\n<h3 id=\"像素对齐\" tabindex=\"-1\"> 像素对齐</h3>\n<p>在绘制图标的时候，应该将图标的每个像素尽量对齐于像素点，这样导出图标时像素的边缘不会出现锯齿，不会出现过于模糊的情况。通常在绘制时去除绘制软件中 x 与 y 轴，宽(w)与高(h)的小数点，这样就可以避免无法对齐像素的情况。</p>\n<p><img src=\"@source/design/icon/assets/align.jpg\" alt=\"图标对齐\"></p>\n<h3 id=\"图标参考线\" tabindex=\"-1\"> 图标参考线</h3>\n<p>在绘制两个或者以上的图标时，为了避免多个图标出现大小不一的情况，应该使用由谷歌材料设计语言提供的图标参考线进行绘制，使用图标盒子可以让一整套图标在视觉效果上更加统一和谐，不会出现一大一小一长一短的情况。</p>\n<p><img src=\"@source/design/icon/assets/reference-line.jpg\" alt=\"图标参考线\"></p>\n<h4 id=\"使用方法\" tabindex=\"-1\"> 使用方法</h4>\n<p>先绘制一个 152×152px 的正方形，一个 176×176px 的正圆形，一个宽 176×128px 的水平矩形和一个 128×176px 的垂直矩形，圆角为 4px，然后将这个四个形状进行水平居中对齐，之后得出一个图标的参考线。</p>\n<p>在宽度相等的情况下，正方形的面积要大于正圆的面积，所以在绘制圆形图标时应该将圆形的上下左右四个顶点顶齐与图标盒子正方形区域的四条边；在绘制方形图标时应该将方形的四个角点顶齐与圆形参考线的外围边；在绘制横向矩形与纵向矩形图标时，应该将图标的左右边或者是上下边控制在正方形的参考线之内，这样矩形图标绘制出来会更加的圆润，相对于其他的形状图标更加匹配。</p>\n<p><img src=\"@source/design/icon/assets/layout.jpg\" alt=\"图标布局\"></p>\n<h3 id=\"可访问性\" tabindex=\"-1\"> 可访问性</h3>\n<p>图标必须要保证清晰度，可辨别性。不管是在强光下还是正常光下都需要良好的可读性。这就需要图标不论是自身元素之间的对比度还是和页面底板背景之间的对比度都需要很好的可读性。检测图标的可读性通常要将图标的背景色底板在黑色和白色之间进行切换对比，不论是黑色还是白色的背景都可以看清图标的全部细节，还需要确保图标中的每一种颜色都是可见的。第二就是将图标拿到强光下进行观察，在强光下是否可以看清图标的主题结构，图标是否有足够的辨识度。</p>\n<p>在绘制图标时，可以参考 WCAG 2.1: 图形和用户界面组件的对比度至少为 3 : 1 的标准进行相应配色，以达到良好的可视状态。</p>\n<p>可访问性测试: <a href=\"https://webaim.org/resources/contrastchecker/\" target=\"_blank\" rel=\"noopener noreferrer\">https://webaim.org/resources/contrastchecker/</a></p>\n<p><img src=\"@source/design/icon/assets/access.jpg\" alt=\"可访问性\"></p>\n<h3 id=\"统一性\" tabindex=\"-1\"> 统一性</h3>\n<p>在绘制多个类型相同的图标时，需要注意这一套图标合集需要在视觉上保持统一性。在一整套产品中，会有很多种图标，但是图标的功能不一样，所表达的内容也不同。这时，图标一致性的意义就体现出来了，根据格式塔原理中的相似性原则: 人们会将如元素彼此相似的东西感知为一组。这也意味着如果具有相同功能、含义和层次结构级别的元素，则应在视觉上保持统一匹配。通常倾向于将彼此相似的元素视为同一个分组，相似性可以帮助组织和分类页面里的元素对象，并将它们与特定的含义或功能相关联。有不同的方法可以使元素被认为是相似的，这些方法包括颜色、大小、形状、纹理、尺寸和方向的相似性。</p>\n<p>图标内容的统一会让用户明白相似的图标所代表的的功能也相同，而且在视觉上也更加和谐美观。因此在绘标后还需检查线条的粗细比重，边角的大小，配色方案，细节层次和设计元素在整个合集中是否是不变且一致的。</p>\n<p><img src=\"@source/design/icon/assets/union.jpg\" alt=\"统一性\"></p>\n<h3 id=\"图标呼吸感\" tabindex=\"-1\"> 图标呼吸感</h3>\n<p>呼吸感的意思就是适当留白。在设计中，适当的留白可以突出主体内容，让内容具备易看性。不管是图标还是界面，元素与元素之间都应该存在一定的间距。在图标的绘制过程中，图标元素之间的间距不宜过近，元素也不宜过多。图标是一个物体的简略缩影，目的是为了表达内容，让用户快速理解，但是在有限的空间中，太过复杂的细节会影响图标的识别速度。因此在图标的绘制过程中应该删除所有无法传达图标意义的元素，避免使图标变得太过复杂难以识别。</p>\n<p><img src=\"@source/design/icon/assets/space.jpg\" alt=\"呼吸感\"></p>\n<h3 id=\"合理运用布尔运算\" tabindex=\"-1\"> 合理运用布尔运算</h3>\n<p>布尔运算在设计行业中被得到广泛的运用，比如工业设计，影视后期，logo 设计等，布尔运算具有一致性与规范性的优点。在设计面性图标的时候可以合理使用布尔运算进行绘制，这样绘制的图标具有吸引力和说服力。</p>\n<p><img src=\"@source/design/icon/assets/bool.jpg\" alt=\"合理运用布尔运算\"></p>\n<h3 id=\"页面层次感\" tabindex=\"-1\"> 页面层次感</h3>\n<p>在页面中，有需要吸引用户点击的图标，也有起到辅助作用的指示图标，还有引导用户操作的图标，这些图标在页面中占据着不同的地位.在所有图标中，有色图标强于无色图标，多色图标强于单色图标，面性图标强于线性图标，带背景图标强于无背景图标，在设计图标的时候应该根据业务需要进行视觉强弱不同的设计。</p>\n<p><img src=\"@source/design/icon/assets/index.jpg\" alt=\"层次感\"></p>\n<h3 id=\"符合业务属性\" tabindex=\"-1\"> 符合业务属性</h3>\n<p>如文上所说，图标采用与业务相符合的色彩搭配会让用户在使用的过程中更加自然、舒服，同时也会增加用户的识别速度，唤起用户的使用情绪。一个图标的绘制是否具备商业价值也恰恰体现在这里。</p>\n<p>如下图所示，左图是斗鱼直播 APP 的截图，右图是京东金融的图标截图。这两款产品的业务以及所对应的用户群体完全不一样，斗鱼是一款直播的产品，直播面向的用户群体是青少年，所以整体的产品调性是: 萌、活泼、多彩、绚丽、时尚等，斗鱼直播的图标绘制需要面向年轻人，色彩的高饱和与有趣的元素来抓住用户的眼球。但是京东金融是一款理财的产品，面向的用户则是中老年，大多数都是有一些存款的人，这些人不需要斗鱼那样花里胡哨的元素，他们只在乎这个产品是否安全，利息是否高，所以京东金融这个产品的整体风格就需要偏向于: 安全、高端、大气，这样才能给用户从视觉上营造信任感。设计图标时通常使用产品的调性作为主风格，但是像美团淘宝这些业务众多的产品中，就需要根据产品下的细分业务进行风格定位，然后设计中相应融入产品的品牌元素，使用合理的色彩情绪等让图标变得更符合业务的风格。</p>\n<p><img src=\"@source/design/icon/assets/location.jpg\" alt=\"图标风格\"></p>\n<h2 id=\"最终测试\" tabindex=\"-1\"> 最终测试</h2>\n<p>使用前，还需要测试这一组图标的重心是否统一，常用的方法是使用标准的正圆形和正方形来和所有绘制的图标进行对比，保证所有的图标重心相近，视觉统一。也可以采用不同角度的观察法，可以从上下左右四个角度去观察图标，看看图标在不同的角度下重心是否统一。</p>\n<p><img src=\"@source/design/icon/assets/center.jpg\" alt=\"图标重心\"></p>\n",
      "date_published": "2020-09-13T00:00:00.000Z",
      "date_modified": "2022-08-20T08:54:00.000Z",
      "authors": [],
      "tags": [
        "设计"
      ]
    },
    {
      "title": "图标介绍",
      "url": "https://github.com/MisterChen9527/design/icon/intro.html",
      "id": "https://github.com/MisterChen9527/design/icon/intro.html",
      "content_html": "<h2 id=\"图标的基本认识\" tabindex=\"-1\"> 图标的基本认识</h2>\n<p>图标，是一种图形化的标识，它有广义和狭义两种概念，广义指的是所有现实中有明确指向含义的图形符号，狭义主要指在计算机设备界面中的图形符号，有非常大的覆盖范围。</p>\n<p>对于 UI 设计师而言，主要针对的就是狭义的概念，它是 UI 界面视觉组成的关键元素之一。</p>\n<p>在当下最常见的扁平化设计风格中，界面的实际视觉组成只有 4 种元素，图片、文字、几何图形、图标。</p>\n<p><img src=\"@source/design/icon/assets/app-layout.jpg\" alt=\"由图片、文字、几何、图标组成的界面\"></p>\n<p>可以说，图片、文字、几何图形的运用，都只用到排版的技巧，而图标，是 UI 设计中除了插画元素以外唯一需要「绘制」、「创作」的元素，一涉及到这两件事，难度就直线上升了。</p>\n<p>本来往界面里丢一些方方圆圆、贴几张图、填一些字，就可以把界面做出来了，比如 Clear APP，不仅工作量少，而且还符合极简原则，为什么还要吃力不讨好的设计图标?</p>\n<p><img src=\"@source/design/icon/assets/clear-app.jpg\" alt=\"Clear APP 的截图\"></p>\n<p>这就涉及图标作用的探讨了，本文就不长篇大论从上古时期人类与图形符号的纠葛开始写了，就谈对于图形界面本身，为什么图标有这么重要的地位，没它不行?</p>\n<p>有两个原因，第一文字虽然也是一种图形符号，但相对于图标而言，文字实在太复杂了，在识别效率上有先天的劣势。再者，不同的语言，文字的长度也不同，如果换成阿拉伯语或者俄罗斯语，或许一行还装不下所有文字。图标可以以一种更高效的方式，将想要传递的信息进行浓缩，不仅易于识别，也能让界面更简洁，利于排版，比如下方案例。</p>\n<p><img src=\"@source/design/icon/assets/icon-effect.jpg\" alt=\"应用文字替换了图标的对比\"></p>\n<p>第二点，就是关于视觉的观赏性。有些页面中，如果把图标去掉了，也丝毫不会影响操作效率，以及对内容的理解。但没有图标，缺少这些点缀，这个页面看起来就会太枯燥，最好的例子就是应用的设置页了，见下方案例。</p>\n<p><img src=\"@source/design/icon/assets/icon-compare.jpg\" alt=\"设置页有图标和没有图标的对比\"></p>\n<h2 id=\"总结\" tabindex=\"-1\"> 总结</h2>\n<p>在 UI 的界面中，图标的主要作用是用来高效地传递信息，以及起到美化界面的作用。</p>\n",
      "date_published": "2020-09-13T00:00:00.000Z",
      "date_modified": "2022-08-20T08:54:00.000Z",
      "authors": [],
      "tags": [
        "设计"
      ]
    },
    {
      "title": "线性图标设计",
      "url": "https://github.com/MisterChen9527/design/icon/line.html",
      "id": "https://github.com/MisterChen9527/design/icon/line.html",
      "summary": "线性图标是所有图标中最基础的设计形式，也是最简单的入门。在我们后续设计其它的风格图标前，首先要通过练习线性图标来打下坚实的基础。\n",
      "content_html": "<p>线性图标是所有图标中最基础的设计形式，也是最简单的入门。在我们后续设计其它的风格图标前，首先要通过练习线性图标来打下坚实的基础。</p>\n\n<p><img src=\"@source/design/icon/assets/line-icon.jpg\" alt=\"线性图标\"></p>\n<h2 id=\"设计注意事项\" tabindex=\"-1\"> 设计注意事项</h2>\n<p>设计线性图标需要注意:</p>\n<ul>\n<li>制图的规范性</li>\n<li>图形的合理应用</li>\n</ul>\n<p>只要图形的设计能达到这两个要求，才能在进一步的创作中施展拳脚。</p>\n<p>线性图标的设计首先要确定图标的尺寸、描边的粗细和绘制图标的栅格系统，所以先确定图标的规格为 28pt * 28pt，使用 2pt 的内描边(设计中 PT 可以等同 PX )，然后再画出栅格，并进行编组。</p>\n<p><img src=\"@source/design/icon/assets/grid-example.jpg\" alt=\"栅格示例\"></p>\n<h2 id=\"设计演示\" tabindex=\"-1\"> 设计演示</h2>\n<h3 id=\"搜索图标\" tabindex=\"-1\"> 搜索图标</h3>\n<p>搜索图标是 APP 中最常见的图标，绘制原理也很简单，就是一个圆和圆角矩形的结合。</p>\n<ol>\n<li>\n<p>在案例中，设计的风格主要是偏圆润一点的，那么镜片的比例就要偏大。在这里使用了尺寸为 20pt 的圆，和一个宽 2pt 高 9pt 的圆角矩形。</p>\n<p><img src=\"@source/design/icon/assets/search-step1.jpg\" alt=\"搜索图标绘制步骤 1\"></p>\n</li>\n<li>\n<p>将矩形和圆形进行连接并且垂直方向居中、编组，然后旋转 45 度。之所以要先垂直再旋转，是因为如果直接画出一条倾斜的矩形再去连接镜片，那么矩形的中轴将很难移动到和圆心相交的位置。</p>\n<p><img src=\"@source/design/icon/assets/search-step2.jpg\" alt=\"搜索图标绘制步骤 2\"></p>\n</li>\n<li>\n<p>调整搜索图标在模版中的位置，因为几何视觉差的关系，要让图标重心平稳，那么就要向右下角偏移，最终效果见下图。</p>\n<p><img src=\"@source/design/icon/assets/search-step3.jpg\" alt=\"搜索图标绘制步骤 3\"></p>\n</li>\n</ol>\n<h3 id=\"聊天图标\" tabindex=\"-1\"> 聊天图标</h3>\n<p>聊天图标的设计和搜索图标一样，需要通过几何图形的组合完成，但不同于搜索图标的是，该图标需要应用到路径查找器面板的相关功能。</p>\n<ol>\n<li>\n<p>首先要画出聊天气泡的外轮廓，可以看出它是由一个圆角矩形和三角形组成，所以第一步要做的就是画出这两个元素。</p>\n<p><img src=\"@source/design/icon/assets/talk-step1.jpg\" alt=\"聊天图标绘制步骤 1\"></p>\n</li>\n<li>\n<p>将它们连接并垂直方向居中，然后使用路径查找器面板的「联集」选项，将它们合并成一个图形。</p>\n<p><img src=\"@source/design/icon/assets/talk-step2.jpg\" alt=\"聊天图标绘制步骤 2\"></p>\n</li>\n<li>\n<p>在轮廓内部画一长一短两条 2pt 宽的矩形。</p>\n<p><img src=\"@source/design/icon/assets/talk-step3.jpg\" alt=\"聊天图标绘制步骤 3\"></p>\n</li>\n<li>\n<p>调整图标在模版中的位置，根据视觉差要将图标向下偏移，最终效果见下图。</p>\n<p><img src=\"@source/design/icon/assets/talk-step4.jpg\" alt=\"聊天图标绘制步骤 4\"></p>\n</li>\n</ol>\n<h3 id=\"查看图标\" tabindex=\"-1\"> 查看图标</h3>\n<p>查看图标的设计也需要应用路径查找器的功能，实现过程也非常简单。</p>\n<ol>\n<li>\n<p>画两个 2pt 描边，垂直方向对齐且相交的圆，并使用路径查找器中的「交集」功能获取它们相交的部分。</p>\n<p><img src=\"@source/design/icon/assets/view-step1.jpg\" alt=\"查看图标绘制步骤 1\"></p>\n</li>\n<li>\n<p>将这个图形置入到模版中，然后可以通过拖动图形大小的方式，更改它的左右两边到像素对齐的位置(这个形状的比例发生变化是没问题的)。</p>\n<p><img src=\"@source/design/icon/assets/view-step2.jpg\" alt=\"查看图标绘制步骤 2\"></p>\n</li>\n<li>\n<p>在中央位置添加一个 8pt 大小的圆，就完成了最终的效果。</p>\n<p><img src=\"@source/design/icon/assets/view-step3.jpg\" alt=\"查看图标绘制步骤 3\"></p>\n</li>\n</ol>\n<h3 id=\"心形图标\" tabindex=\"-1\"> 心形图标</h3>\n<p>心形图标如何绘制，对于新人来说是一个非常常见的问题。很多人都不知道具体该怎么画出这个图形，而心形图标又几乎被运用在所有应用中，所以就要巧妙运用几何图形的组合。</p>\n<ol>\n<li>\n<p>画两个矩形，一个竖直一个水平放置，并将上方和右侧的两个边缘进行圆角处理。</p>\n<p><img src=\"@source/design/icon/assets/heart-step1.jpg\" alt=\"心性图标绘制步骤 1\"></p>\n</li>\n<li>\n<p>将两个图形进行移动相交，并保证上方和右侧的两个半圆正好紧贴在另一个矩形的边缘，然后使用路径查找器中的 「联集」功能，就可以得到一个躺着的心形。</p>\n<p><img src=\"@source/design/icon/assets/heart-step2.jpg\" alt=\"心性图标绘制步骤 2\"></p>\n</li>\n<li>\n<p>将心形进行旋转，并置入到模版中，添加圆角细节，略微向下偏移，就可以得到下图的最终效果。</p>\n<p><img src=\"@source/design/icon/assets/heart-step3.jpg\" alt=\"心性图标绘制步骤 3\"></p>\n</li>\n</ol>\n<h3 id=\"卡券图标\" tabindex=\"-1\"> 卡券图标</h3>\n<p>卡券图标有一个外轮廓和内部的虚线部分，外轮廓在上下有两个半圆的凹槽，要通过两个圆进行裁切。</p>\n<ol>\n<li>\n<p>画一个 28pt * 24pt 的圆角矩形，并在上下方各画一个 4pt 大小的圆，与矩形的边缘相交。</p>\n<p><img src=\"@source/design/icon/assets/ticket-step1.jpg\" alt=\"卡券图标绘制步骤 1\"></p>\n</li>\n<li>\n<p>确认两个小圆图层顺序在矩形的上方，然后选中三个图层，使用路径查找器中的「减去顶层」即可得到外轮廓。</p>\n<p><img src=\"@source/design/icon/assets/ticket-step2.jpg\" alt=\"卡券图标绘制步骤 2\"></p>\n</li>\n<li>\n<p>最后，就是画出卡片中的两条「虚线」，再置入到模版中，就可以得到下图的最终效果。</p>\n<p><img src=\"@source/design/icon/assets/ticket-step3.jpg\" alt=\"卡券图标绘制步骤 3\"></p>\n</li>\n</ol>\n<h3 id=\"房屋图标\" tabindex=\"-1\"> 房屋图标</h3>\n<p>从房屋图标的形状中，我们可以看出它包含了三角、圆和矩形这三个形状，主要的难点是如何通过三角形和矩形画出外部的轮廓。</p>\n<ol>\n<li>\n<p>首先画出一个 28pt × 10pt 的等腰三角形，再画一个 22pt × 16pt 的矩形，将它们边缘进行重叠。</p>\n<p><img src=\"@source/design/icon/assets/home-step1.jpg\" alt=\"房屋图标绘制步骤 1\"></p>\n</li>\n<li>\n<p>三角形三个尖角的圆角依次设置为 3pt、1pt、1pt(上、左、右)，再将矩形下半部分的两个直角添加 4pt 圆角。</p>\n<p><img src=\"@source/design/icon/assets/home-step2.jpg\" alt=\"房屋图标绘制步骤 2\"></p>\n</li>\n<li>\n<p>执行「联集」操作，生成完整的外轮廓。之所以先做圆角再执行联集，是因为提前合并两个形状，会导致一些尖角无法使用圆角工具。</p>\n<p><img src=\"@source/design/icon/assets/home-step3.jpg\" alt=\"房屋图标绘制步骤 3\"></p>\n</li>\n<li>\n<p>画出房屋中间的圆形，然后将图形置入模版中，就可以得到下图的最终效果。</p>\n<p><img src=\"@source/design/icon/assets/home-step4.jpg\" alt=\"房屋图标绘制步骤 4\"></p>\n</li>\n</ol>\n<h3 id=\"齿轮图标\" tabindex=\"-1\"> 齿轮图标</h3>\n<p>齿轮在 UI 中一般作为设置的图标使用，也是常用图标中最难画的图标之一。</p>\n<ol>\n<li>\n<p>画一个 28pt 的大圆，然后再画一个 8pt 的小圆，置于圆的左侧。然后使用「旋转工具」，将小圆旋转中心固定到大圆的圆心中，按回车键，在弹出的对话框中选择 60° 然后点击复制按钮，生成第二个圆。之后再按 Ctrl / Command +D 重复操作 4 次，就可以得到完整的圆环。</p>\n<p><img src=\"@source/design/icon/assets/setting-step1.jpg\" alt=\"齿轮图标绘制步骤 1\"></p>\n</li>\n<li>\n<p>保证周围的 6 个圆在大圆的上层(一般来说，新画的六个小圆必然在大圆上层)，并将 7 个圆全部选中，执行「减去顶层」操作。</p>\n<p><img src=\"@source/design/icon/assets/setting-step2.jpg\" alt=\"齿轮图标绘制步骤 2\"></p>\n</li>\n<li>\n<p>最后，将所有内圆角改为 2pt，再画一个直径 8pt 的内圆，然后在模版中调整到正确的位置即可，就可以得到下图的最终效果。</p>\n<p><img src=\"@source/design/icon/assets/setting-step3.jpg\" alt=\"齿轮图标绘制步骤 3\"></p>\n</li>\n</ol>\n<h3 id=\"文件图标\" tabindex=\"-1\"> 文件图标</h3>\n<p>文件图标也是一个很简单，但是大多数人就是做不好的图标，右下角的折角难倒了很多新手，在这里我们用一个简单的方法进行实现。</p>\n<ol>\n<li>\n<p>先画一个 20pt * 23pt 的圆角矩形(高不是偶数，后面会解释)，然后要先把右下角的缺口做出来。这里如果要使用减去顶层的方法做也可以，但我们要用一个更简单的操作，在右下角顶点上方和左侧 6pt 的位置各添加一个锚点，然后使用「删除锚点工具」删除右下角顶点的锚点，就可以得到一个倾斜的切口。</p>\n<p><img src=\"@source/design/icon/assets/file-step1.jpg\" alt=\"文件图标绘制步骤 1\"></p>\n</li>\n<li>\n<p>在右下角画一个圆角为 4pt 的矩形，然后将其中一个边与上个步骤的缺口相交，相交的部分即为折角的部分。这时候选中两个矩形，使用「形状生成器工具」(快捷键 Shift + M)，点击一下图示的部分，就会生成一个新的形状组，接着取消它们的编组，再选中多余的图形进行删除，就可以得到一个完整的折角效果。</p>\n<p><img src=\"@source/design/icon/assets/file-step2.jpg\" alt=\"文件图标绘制步骤 2\"></p>\n</li>\n<li>\n<p>最后，设置大圆角(4pt)和小圆角(2pt)，并在内部添加 3 个圆角矩形，再根据几何的视觉差将图标置入模版中，向下移动一个像素，就可以得到下图的最终效果。</p>\n<p><img src=\"@source/design/icon/assets/file-step3.jpg\" alt=\"文件图标绘制步骤 3\"></p>\n</li>\n</ol>\n<h2 id=\"总结\" tabindex=\"-1\"> 总结</h2>\n<h3 id=\"栅格的使用\" tabindex=\"-1\"> 栅格的使用</h3>\n<p>针对栅格的使用，为了便于演示都给出了具体的数值，在最后一步才置入到模版中。实际上，我们应该在一开始的绘制中就在模版中进行，而往往刚开始画的图形尺寸是不能代表最终效果的。</p>\n<p>比如最后一个文件图标中，为什么是 23pt，并且偏下 1pt。是因为一开始创建 24pt 高的矩形，在完成最终效果以后会发现重心上移，而且整体偏大了(下图第一行)，这时候缩减高度才能保证视觉的稳定性(下图第二行)。而房屋屋顶的三角形，我们使用的是 28pt 撑满画布，这也是经过了不断地尝试，测试了多种宽度和圆角效果后才确定出来的，并不是一蹴而就的。</p>\n<h3 id=\"图形的调整\" tabindex=\"-1\"> 图形的调整</h3>\n<p>图形的不同角度、尺寸和比例，都会影响图标最后呈现的效果，需要我们在制作过程中保持对图形优化的态度，通过持续调整和对比找到最合适的结果。</p>\n<p>比如搜索图标，重点在于圆和矩形的比例，不同比例会带给我们截然不同的感受。</p>\n<p><img src=\"@source/design/icon/assets/style-adjust.jpg\" alt=\"风格调整\"></p>\n<p>以及在查看图标中，圆形相切的比例不同，也决定了最终呈现的效果差异，相交越少感觉越尖锐，相交越多则感觉越圆润。</p>\n<p><img src=\"@source/design/icon/assets/style-adjust2.jpg\" alt=\"风格调整\"></p>\n<h3 id=\"多种操作方式\" tabindex=\"-1\"> 多种操作方式</h3>\n<p>实现同一种效果，可以有非常多的操作方法，殊途同归。虽然软件只是实现设计的工具，但对工具的理解越全面越好，很多时候我们都可以尝试使用不同的方法来实现相同的效果，而不用太拘泥于一种固定的形式。</p>\n<p>比如在房子图标的绘制中，我们用的是三角形和矩形合并的形式制作的外轮廓。因为网格的存在，还可以直接通过钢笔工具绘制，自由度更高，但对我们图形把控能力的要求也更高。</p>\n<p><img src=\"@source/design/icon/assets/way1.jpg\" alt=\"钢笔方式\"></p>\n<p>再比如文件图标的步骤 2 中，用的是「形状生成器工具」。如果将两个图形轮廓化，再使用路径查找器中的「分割」，也能够达到相同的效果。</p>\n<p><img src=\"@source/design/icon/assets/way2.jpg\" alt=\"轮廓化方式\"></p>\n<hr>\n<p>如果想要开启图标的练习，就要从这些最基础的线性图标入手，不断练习和思考如何通过正确、规范的操作制作图标。如果实在不知道要画什么，可以临摹微信、QQ 等成熟的应用工具图标。</p>\n",
      "date_published": "2020-09-13T00:00:00.000Z",
      "date_modified": "2022-08-20T08:54:00.000Z",
      "authors": [],
      "tags": [
        "设计"
      ]
    },
    {
      "title": "图标设计准则",
      "url": "https://github.com/MisterChen9527/design/icon/rule.html",
      "id": "https://github.com/MisterChen9527/design/icon/rule.html",
      "summary": "规范是图标设计的重点。\n",
      "content_html": "<p>规范是图标设计的重点。</p>\n\n<p><img src=\"@source/design/icon/assets/type.jpg\" alt=\"三种主要类型的图标\"></p>\n<h2 id=\"表意的准确\" tabindex=\"-1\"> 表意的准确</h2>\n<p>第一部分已经介绍了图标的主要作用之一就是作为文字的替代品，具有明确的寓意。比如看见一个放大镜，大家会当成那是搜索；看见钥匙或者锁，大家就会理解成是密码。</p>\n<p>下面这些图标，每一个指代的功能和寓意都是非常直白和清晰的。</p>\n<p><img src=\"@source/design/icon/assets/meaning.jpg\" alt=\"寓意明确的图标\"></p>\n<p>表达的寓意清晰，是图标最基本的要求，否则它只会传递错误的信息，造成用户的困惑。</p>\n<p>在常见的图标类型里，如通知、设置、用户和分享之类的图标，对于任何手机用户来说都没有认知和选择压力。但表意准确麻烦的地方在于，一些非常规的寓意，极难用图标表现出来，这才是使用线性图标的首要麻烦。</p>\n<p>比如下方这些图标，如果不加上文字信息，大家能理解它们是什么吗?</p>\n<p><img src=\"@source/design/icon/assets/without-text.jpg\" alt=\"无文字信息\"></p>\n<p>那么，再把文字信息补充进去，是不是就会觉得图形挺贴合内容的?</p>\n<p><img src=\"@source/design/icon/assets/with-text.jpg\" alt=\"有文字信息\"></p>\n<p>在这种案例中，需要要关注的就是，面对这样不常见的内容，设计师是怎么把图形的创意和样式想出来的，如果自己遇到一样的问题怎么办?</p>\n<p>所以，除了知道每个图标都要表意准确之后，该如何通过合适的创意将图标样式确定出来?</p>\n<p>一般抽象的图标，难点在于寓意信息是非实体的，很难直接构建对图形样式的联想，所以办法就是将抽象的内容「实体化」。也就是说，可以先把这个词写到纸上，把和这个抽象信息相关的所有实体物写下来。</p>\n<p><img src=\"@source/design/icon/assets/to-goods.jpg\" alt=\"实体化扩展\"></p>\n<p>之后可以挑选出某个合适的实物，以它作为原型开始绘制。如果对挑选出来的实物要以什么图形表现还没概念，那么就可以借助网上的图标素材网站，比如 iconfont、iconfinder 等，在搜索框中输入这些词语，通过别人的设计获取灵感。</p>\n<p><img src=\"@source/design/icon/assets/iconfont.jpg\" alt=\"Iconfont\"></p>\n<p>如果本身拥有比较好的手绘基础或是平面基础，也可以直接通过对照片进行提炼的方式，设计出图形内容。</p>\n<p>所以，在设计图标时要符合表意准确的概念，需要设计师不断收集图形，并提升对词汇联想的能力。很多优秀的创意，就是在这些基础的积累之上逐渐形成的，而不是一蹴而就。</p>\n<h2 id=\"图标的一致性\" tabindex=\"-1\"> 图标的一致性</h2>\n<p>第二个规范，叫图标的一致性。即一个或一套图标中，应该保持一致的细节。首先看看下面的反面案例:</p>\n<p><img src=\"@source/design/icon/assets/unconst.jpg\" alt=\"不一致的图标\"></p>\n<p>在上面的案例中，不同图标间有很大的割裂感，完全不像处于同一套设计体系之下，这就是缺乏一致性的表现。这也是新手在设计一整套图标最大的难点，要让所有图标保持视觉细节上的一致。</p>\n<p>那么，图标要保持视觉一致性有哪些细节呢?</p>\n<h3 id=\"类型一致\" tabindex=\"-1\"> 类型一致</h3>\n<p>前面说过，图标有线性的和填充的类型，在正常的情况中，同一套图标应该保持相同的类型，如果使用了线性图标那么后续就不要设计填充以及混合的类型。</p>\n<p><img src=\"@source/design/icon/assets/same-type.jpg\" alt=\"类型一致\"></p>\n<h3 id=\"风格一致\" tabindex=\"-1\"> 风格一致</h3>\n<p>每一套图标都有自己的设计风格，不同风格在细节中都有不同的表现，需要让这些风格特征保持高度统一，看看下面这些案例。</p>\n<p>第一，为图标添加缺口的设计风格，不过要保证这个缺口的大小是一致的，并且每一个图标中有且只有一个缺口，而不是靠感觉随意添加。</p>\n<p><img src=\"@source/design/icon/assets/add-gap.jpg\" alt=\"添加缺口\"></p>\n<p>第二，在设计一套偏圆润可爱的设计风格中，外轮廓使用了较大的圆角，那么应当尽可能保证圆角的大小是一致的，而不是有的用 4pt，有的用 2pt 或者直接使用直角。</p>\n<p><img src=\"@source/design/icon/assets/make-round.jpg\" alt=\"使用圆角\"></p>\n<p>第三，采用了填充色偏移的设计风格，首先要保证填充色一致，并且偏移的距离和方向也要保持固定的规律，不能随喜好任意制定。</p>\n<p><img src=\"@source/design/icon/assets/fill-color.jpg\" alt=\"填充色\"></p>\n<h3 id=\"透视一致\" tabindex=\"-1\"> 透视一致</h3>\n<p>透视关系是在平面中对物体空间性质的表现方式，当图标应用了透视时，物体就有了一定的「立体感」。</p>\n<p><img src=\"@source/design/icon/assets/3D.jpg\" alt=\"立体感\"></p>\n<p>透视的表现不是绘制图标时必须使用的风格，但是如果在图标中应用了透视，就要确保使用的视角是一致的。要极力避免同一套图标中既用了正视图又包含了侧视图。</p>\n<p><img src=\"@source/design/icon/assets/perspective.jpg\" alt=\"不同视角\"></p>\n<h3 id=\"粗细一致\" tabindex=\"-1\"> 粗细一致</h3>\n<p>在图标中会常常应用到矩形线段或是描边，应尽可能保证粗细一致。</p>\n<p>比如，在线性的设计中，路径的描边尺寸要保持一致，不能这个图标用 2pt，那个图标用 1pt。</p>\n<p><img src=\"@source/design/icon/assets/same-weight.jpg\" alt=\"粗细一致\"></p>\n<p>在填充图标中，我们会在一个矩形或是圆形中增加矩形的镂空，比如下图的几个图标，在这种情况下也要保证它们的粗细是一致的，而不是各不相同。</p>\n<p><img src=\"@source/design/icon/assets/same-weight2.jpg\" alt=\"粗细一致2\"></p>\n<h3 id=\"大小一致\" tabindex=\"-1\"> 大小一致</h3>\n<p>大小一致，就是让图标的视觉大小保持一致，而不是它们字面上的长宽属性保持一致。因为这是一个比较复杂的知识点，需要大家对几何图形的视觉差有比较完整的认识。这些和一致性有关的特征，是一套图标看起来专业、有整体感的必要条件。</p>\n<p>但是，在真实的设计场景中需要灵活变通。如果有一些特定的图标，在保证了一致性的要求后却极难被人理解，且找不到更好的设计方式，就可以差别对待。比如在一套图标中，播放、快进等图标往往都是填充类型的，这并不会造成视觉或是使用上的困扰。</p>\n<h2 id=\"几何图形的视觉差\" tabindex=\"-1\"> 几何图形的视觉差</h2>\n<p>几何图形的视觉差，是对于图标来说最重要的细节，也是平面基础理论中不可忽视的内容，这个理论要解决一个核心的问题，即怎么让不同的图形看上去一样大?</p>\n<p>可能大家有人会觉得这有什么难的? 通过软件的参考线或者属性设置，把它们的长宽设置成一样不就完事了。比如下图这样:</p>\n<p><img src=\"@source/design/icon/assets/size-feel.jpg\" alt=\"尺寸等大的几何形视觉大小并不一致\"></p>\n<p>画起来轻轻松松，参数上完美无缺。但是，怎么看上去这些图形大小有点不一样，为什么正方形看起来这么大，三角形看起来这么小?</p>\n<p>这个问题的根源是，不同几何图形带给人们的视觉大小是不同的。而要解决这样的问题，就要对它们的尺寸做出额外的调整。比如下图这样:</p>\n<p><img src=\"@source/design/icon/assets/size-adjust.jpg\" alt=\"圆和三角需要进行放大修正\"></p>\n<p>适当调整完圆形和三角形以后，是不是觉得大小的感觉一致了? 这就要牵扯一个更基础的视觉规律，占据面积越大的图形，给人的视觉感受就越大，所以给人感受越小的元素，就要放得越大。</p>\n<p>并且，这个问题在一个图形的内部也会产生影响，比如知乎 APP 下面的点赞和反对按钮，都有三角形图标，但图形其实对于外部矩形是非居中的。</p>\n<p><img src=\"@source/design/icon/assets/weight-feel.jpg\" alt=\"重心感觉\"></p>\n<p>如果一个图形其中一部分面积远大于另一部分，那么就会让这个图形的重心产生偏移，必须要往较小的部分的方向移动才能产生平衡。</p>\n<p><img src=\"@source/design/icon/assets/weight-adjust.jpg\" alt=\"调节重心\"></p>\n<p>所以，在设计一整套的应用中，如果没有对这个理论的理解，只定义一个矩形出来，把所有图形的尺寸与矩形对齐，那么最终看到的图标效果一定是极度不平衡的。</p>\n<p><img src=\"@source/design/icon/assets/center-compare.jpg\" alt=\"重心对比\"></p>\n<h2 id=\"图标栅格\" tabindex=\"-1\"> 图标栅格</h2>\n<p>其实，针对图标的规范，大家可能第一个想到的应该就是参考线了，也就是所谓的栅格模板。之所以放在这里，是因为图标的栅格规范，是根据几何的视觉差特性衍生出来的。</p>\n<p>下面是常见的图标栅格:</p>\n<p><img src=\"@source/design/icon/assets/grid.jpg\" alt=\"栅格\"></p>\n<p>里面包含了正方形、长方形和圆形。将它们分别罗列出来，可以发现这些图形的视觉尺寸是非常接近的。这样通过该尺寸设计对应的图形，也就看起来都一样大了。</p>\n<p><img src=\"@source/design/icon/assets/grid-compare.jpg\" alt=\"栅格对比\"></p>\n<p>所以，应用图标的栅格系统对于图标的设计来说，是一个用来应对几何图形视觉差的「参照物」。</p>\n<p>之所以要说参照物，原因在于一套图标不会只存在这几种图形的样式，还有很多千奇百怪的形状，但大体上我们可以识别出来它的类似轮廓或者重心方向，于是就可以通过参照图形来判断设计出来的图形尺寸是否符合标准。</p>\n<p>如果设计图形和参照图形类似，那么尺寸就不能大于参照图形；如果设计图形的宽大于参照图，那么高就要小于参照图，反之亦然。如果图形的重心有偏移，那就要往重心偏移的反方向移动，比如搜索按钮，Wi-Fi 图标等。</p>\n<p><img src=\"@source/design/icon/assets/grid-usage.jpg\" alt=\"栅格使用\"></p>\n<p>最后，说说栅格系统的画法，和大家想象的不一样，想要画一套图标，栅格系统是自己画出来的，不是到网上下载下来的，所以怎么画也是这个知识的重点。</p>\n<ol>\n<li>如何绘制图标栅格系统</li>\n</ol>\n<p>如果定义一套 28pt 的图标，那么首先要画一个 28pt 的正方形，然后确定一个 2 - 4pt 的内边距，正所谓四边留一线，日后好相见。</p>\n<p><img src=\"@source/design/icon/assets/grid-guide1.jpg\" alt=\"步骤1\"></p>\n<p>然后就要开始在其中绘制正方形和圆形，正方形通常在整个图标尺寸 1/2 的比例，可以使用 14 或 16 的偶数(为了可以居中)。然后再确定圆形的尺寸，圆肯定比正方形大 2 - 4pt，于是就得到下方的图形。</p>\n<p><img src=\"@source/design/icon/assets/grid-guide2.jpg\" alt=\"步骤2\"></p>\n<p>之后，再确定横竖长方形的尺寸，可以直接顶到内边距的边缘。它的尺寸不是通过数值计算的，而是要先画出来，把它们和前面的圆和正方形置于一条水平线上，调整出一个平衡的视觉尺寸，再合并进栅格系统中，就完成了栅格系统的绘制，如下图的案例。</p>\n<p><img src=\"@source/design/icon/assets/grid-guide3.jpg\" alt=\"步骤3\"></p>\n<p>这一步也旨在检查参考线系统是否在基础结构上经得起考验，是非常关键的一步。因为不同尺寸的图标中，参考线系统都是有区别的，不能直接按一个固定的比例来设置，要根据实际场景做判断。</p>\n<div><p>栅格素材</p>\n<p>此处有一套现成的栅格素材，包含 16、24、28、32、36、48 等六个尺寸。</p>\n<ul>\n<li><a href=\"https://mrhope.site/file/design/tool-grid.ai\" target=\"_blank\" rel=\"noopener noreferrer\">工具栅格下载</a></li>\n</ul>\n</div>\n<h2 id=\"像素对齐\" tabindex=\"-1\"> 像素对齐</h2>\n<p>在栅格的绘制中，如果您足够信心，您肯定发现了几个关键字，「对齐」、「偶数」，这就是在这一部分要提及的内容。关于显示器的倍率问题是 UI 基础知识点之一，可能有的同学不太了解，不过没关系，直接看下面的内容即可。</p>\n<p>大家都知道像素是屏幕显示中的最小单位，一个像素只能显示一种颜色。小时候玩过的 GBA 和 FC 游戏机，都是通过像素画的形式呈现，人物锯齿是无法避免的。</p>\n<p><img src=\"@source/design/icon/assets/old-game.jpg\" alt=\"老游戏\"></p>\n<p>而随着技术发展，像素密度是降低了，但如果依旧是按过去这种一个萝卜一个坑的方式显示内容，那锯齿感无论如何是无法消除的。于是，开发了次像素渲染(Subpixel Rendering)的技术。一个在显示器中让人们觉得平滑的圆，一直放大，就可以发现它的周边充满了饱和度较低的其它方块色彩。</p>\n<p><img src=\"@source/design/icon/assets/subpixel-rendering.jpg\" alt=\"子像素渲染\"></p>\n<p>这项技术，让像素可以用特有的方式来显示非完整的色块，即尽可能还原设计师对元素定义的小数点。但为什么还要提这个概念呢?</p>\n<p>因为工具的图标太小了，而且 UI 的元素对精细和准确度的要求都不低，如果没有尽可能满足像素对齐的要求，那么就可能导致元素边缘的模糊。</p>\n<p><img src=\"@source/design/icon/assets/fuzzy.jpg\" alt=\"模糊的边缘\"></p>\n<p>所以要满足像素对齐的要求，就要符合元素本身的尺寸为整数、描边为整数和 XY 轴坐标为整数的特性。</p>\n<h3 id=\"ai-中的像素对齐设置\" tabindex=\"-1\"> AI 中的像素对齐设置</h3>\n<p>在 AI 中，可以通过两个设定来查看和保证像素对齐，即网格的设置显示，以及对齐到点的设置。</p>\n<p><img src=\"@source/design/icon/assets/AI-align.jpg\" alt=\"AI 对齐\"></p>\n<p>像素的对齐主要表现在横线和竖线上，虽然现在手机显示精度越来越高，但并不意味着可以无视像素对齐的规律。在线性图标中，对于 1pt 或者 2pt 描边的应用，觉得不是太细就是太粗，可以用 1.5pt 的数值(1.5pt 在 2x 中就是 3px)，但切记不要出现类似 1.23、2.16、3.46 这种小数。</p>\n<p>像素对齐是一个专业 UI 设计师对于极致追求的表现之一，是每一个一线大厂 UI 设计师的基本操作，所以，想要冲刺更高的段位，就不要忽视这个规范的使用。</p>\n<h2 id=\"总结\" tabindex=\"-1\"> 总结</h2>\n<ul>\n<li>\n<p>图标要表意准确，能被用户识别并契合想要表达的寓意。</p>\n</li>\n<li>\n<p>设计整套图标的时候要符合一致性原则，包括类型、风格、粗细、透视、大小等特征。</p>\n</li>\n<li>\n<p>不同的几何图形会给我们不同的大小视感，不能只看元素的参数。</p>\n</li>\n<li>\n<p>栅格系统根据视觉差的方式定义出来，作为图标尺寸设定的重要参考。</p>\n</li>\n<li>\n<p>图标的绘制要保证横竖的直线对齐到像素，图标尽量采用整数粗细，如果一定要用小数的话就使用 0.5 递进的。</p>\n</li>\n</ul>\n",
      "date_published": "2020-09-15T00:00:00.000Z",
      "date_modified": "2022-08-20T08:54:00.000Z",
      "authors": [],
      "tags": [
        "设计"
      ]
    },
    {
      "title": "图标设计技巧",
      "url": "https://github.com/MisterChen9527/design/icon/skill.html",
      "id": "https://github.com/MisterChen9527/design/icon/skill.html",
      "content_html": "<p>图标是 UI 设计中最基础也是很重要的部分，辅助人们更好的理解功能内容。随着扁平化设计风格的普及，图标的风格越来越简约，看似简单的图形，实际要准确的表达含义，也是需要注意一些方法的。下面是是图标设计的实用技巧。</p>\n<h2 id=\"简单\" tabindex=\"-1\"> 简单</h2>\n<p>一个图标一个非写实的表现。不需要担心图标不够真实，消除不必要的细节，用基本的形状只保留最基础的部分，让这个图标更容易被理解。</p>\n<p><img src=\"@source/design/icon/assets/simple.jpg\" alt=\"简单\"></p>\n<p>有时候图标会因为有更多细节而传达了更复杂的意思，这反而是样式问题!</p>\n<h2 id=\"一致性\" tabindex=\"-1\"> 一致性</h2>\n<p>在整个图标系统中，您的图标要保持同一种样式来确保图标完美协调。比如同样的形状，填充，描边粗细，尺寸等。要制定好可以被复用的栅格，规范和样式。</p>\n<p><img src=\"@source/design/icon/assets/same.jpg\" alt=\"一致性\"></p>\n<p>如果可以的话，尽可能重新设计这些图标，而不要混入其他不同风格的图标来使用。</p>\n<h2 id=\"清晰\" tabindex=\"-1\"> 清晰</h2>\n<p>设计「完美像素」的图标，特别是在图标非常小的时候。这样图标的描边就可以保持锐利，不会有模糊。注意半像素的情况出现，尽量避免小数点参数。</p>\n<p><img src=\"@source/design/icon/assets/clear.jpg\" alt=\"清晰\"></p>\n<p>这也可以帮您保持图标的辨识度，在您等比缩放他们的时候保持清晰。</p>\n<h2 id=\"空间\" tabindex=\"-1\"> 空间</h2>\n<p>确保您的图标的所有形状有足够的空间。笔画和空间过于狭小会使图标更难被理解。</p>\n<p><img src=\"@source/design/icon/assets/with-space.jpg\" alt=\"空间\"></p>\n<p>最少给 2px 的负空间</p>\n<h2 id=\"视觉调整\" tabindex=\"-1\"> 视觉调整</h2>\n<p>确保您的图标看起来是正确的，适当的调整元素的对齐来达到视觉上的平衡。</p>\n<p><img src=\"@source/design/icon/assets/center-adjust.jpg\" alt=\"视觉调整\"></p>\n<p>不要只关注参数，如果有需要就用上您的眼睛来衡量，轻微移动这些元素。</p>\n<h2 id=\"布局规格\" tabindex=\"-1\"> 布局规格</h2>\n<p>所有图标保持同样的尺寸，在图标周围定义一个可调整的内边距范围，尽量让元素设计在这个范围内。不要挤满所有元素。</p>\n<p><img src=\"@source/design/icon/assets/layout.jpg\" alt=\"布局规格\"></p>\n<p>当图标需要额外控件时可以超出这个内边距范围。</p>\n",
      "date_published": "2020-09-14T00:00:00.000Z",
      "date_modified": "2022-08-20T08:54:00.000Z",
      "authors": [],
      "tags": [
        "设计"
      ]
    },
    {
      "title": "学习图标所需的软件",
      "url": "https://github.com/MisterChen9527/design/icon/software.html",
      "id": "https://github.com/MisterChen9527/design/icon/software.html",
      "summary": "了解了图标的类型，就要开始了解做出这些图标应该使用哪些软件了。通常，UI 主要使用的设计软件包含 PS、AI、Sketch、XD 四款，理论上，它们都包含了图标绘制的功能，下面介绍这四款软件对于图标设计的优劣，以及需要掌握的部分。\n",
      "content_html": "<p>了解了图标的类型，就要开始了解做出这些图标应该使用哪些软件了。通常，UI 主要使用的设计软件包含 PS、AI、Sketch、XD 四款，理论上，它们都包含了图标绘制的功能，下面介绍这四款软件对于图标设计的优劣，以及需要掌握的部分。</p>\n\n<p><img src=\"@source/design/icon/assets/software.jpg\" alt=\"使用软件\"></p>\n<h2 id=\"sketch-xd\" tabindex=\"-1\"> Sketch / XD</h2>\n<p>这两款软件是设计 UI 界面的主力。但大家一定要记得，它们主要的功能是用来完成 UI 界面元素的排版，而不是创作和绘图。</p>\n<p>虽然它们都包含路径、钢笔、布尔运算等功能(Sketch 相对 XD 更完善一点)，想要绘制一些非常基础的线性或面性图标时没有问题，但只要涉及到比较复杂的图形，往往就束手无策。</p>\n<p>所以，建议新手都不要从这两个软件中入手，而是先掌握 PS 和 AI，后面想要快速实现一些简单的图标时，自然懂得如何使用 Sketch 和 XD。</p>\n<p>可以说，PS 和 AI 的应用决定了我们图标设计的上限，而 Sketch 和 XD 是下限，所以，把上限拓展得越高越好。</p>\n<h2 id=\"photoshop\" tabindex=\"-1\"> Photoshop</h2>\n<p>PS 是一款无论什么东西都设计得出来的设计软件，但是，它本质上是一款「位图软件」。后续的文章中会提及，在界面中采用矢量格式的图标是最理想的，而 PS 针对矢量的操作并不便捷，比如将矢量图层复制到其它软件中。</p>\n<p>实际项目中，会用 PS 设计一些视觉表现相对复杂的图标，例如主体图标、拟物图标、实物图标等等。</p>\n<p>绘制图标需要用到的 PS 功能并不太多，需要在前期学习这个软件的过程中加以筛选，重点是以下知识点:</p>\n<ul>\n<li>路径创建和调整</li>\n<li>钢笔工具和锚点</li>\n<li>路径图层</li>\n<li>布尔运算</li>\n<li>图层属性</li>\n</ul>\n<p>虽然 PS 在实际项目中是用来画复杂的图标，但并不妨碍使用 PS 从最基础的图标开始画起，因为想要熟练掌握上方的知识点，简易的工具图标是最好的磨刀石，之后再学习 AI 的操作，就可以更快的上手。</p>\n<h2 id=\"illastrator\" tabindex=\"-1\"> Illastrator</h2>\n<p>AI 也是 UI 设计必学的一款软件，它的功能异常丰富，主要用来设计矢量图形。对比 PS，它有更好的矢量操作支持，对于路径细节的调整上，是最全面最细腻的软件，并且 AI 中的图形还可以直接复制粘贴到其它应用的画布中。</p>\n<p>如果掌握了上方提及的 PS 基础，那么学习 AI 也就轻松了不少，其中，AI 设计图标中有三个特殊的功能是需要重点掌握和学习的:</p>\n<ul>\n<li>形状生成器</li>\n<li>轮廓化描边</li>\n<li>路径查找器</li>\n</ul>\n<h2 id=\"总结\" tabindex=\"-1\"> 总结</h2>\n<p>优先学习 PS、AI 的路径相关功能，而不是 Sketch 和 XD。</p>\n",
      "date_published": "2020-09-13T00:00:00.000Z",
      "date_modified": "2022-08-20T08:54:00.000Z",
      "authors": [],
      "tags": [
        "设计"
      ]
    },
    {
      "title": "启动图标设计指南",
      "url": "https://github.com/MisterChen9527/design/icon/start.html",
      "id": "https://github.com/MisterChen9527/design/icon/start.html",
      "content_html": "<p>想要在启动图标设计上入门，就要先从规范开始学习，然后了解不同的风格以及对应风格的设计过程。</p>\n<h2 id=\"启动图标的设计规范\" tabindex=\"-1\"> 启动图标的设计规范</h2>\n<p>说到启动图标的规范，首先会想到的，就是 iOS 提供的图标栅格。通过这个栅格，会规范图形的尺寸，以及所处的位置。</p>\n<p><img src=\"@source/design/icon/assets/ios-grid.jpg\" alt=\"iOS 提供的图标栅格\"></p>\n<p>这个模板和工具图标的使用方法类似，我们在后面的案例进一步讲解。接着，来说明一个更重要的问题，就是启动图标画布的尺寸。</p>\n<p>默认的情况下，我们使用 1024×1024 尺寸来设计启动图标，这个参数在 iOS 和 Android 中都适用。</p>\n<p>之所以使用这么大的尺寸，是由屏幕分辨率的差异和使用场景导致的。</p>\n<p>第一，在手机硬件中，根据屏幕规格的不同，展示图标的实际像素量也不同，即图标的尺寸会发生改变。</p>\n<p>例如在 1x 的屏幕中，图标使用 60x60px；在 2x 的屏幕中，就使用 120x120pt；3x 则是 180×180。</p>\n<p><img src=\"@source/design/icon/assets/app-size.jpg\" alt=\"不同的图标大小\"></p>\n<p>第二，不同设备和显示场景里，应用的图标尺寸也不一样。对于一个真实的项目来说，图标不是只放在手机上运行，无论是 iOS 还是 Android 的 APP 都可以在 PAD 上安装，图标尺寸规格就不同。并且，在网页或者手机应用商店里，也需要展示启动图标，显示的规格和真实应用列表中又不同。</p>\n<p><img src=\"@source/design/icon/assets/app-size2.jpg\" alt=\"不同的图标大小\"></p>\n<p>所以，在 iOS 官方的图标模板中，我们会看见里面罗列了非常多的图标尺寸，我们只需要设计第一个 1024 规格的，将这个图标置入到 PS 的智能对象，或者 Sketch 的 Symbol 中，就可以一次性生成所有尺寸，不需要我们自己手动调整各种规格的图标输出。</p>\n<p><img src=\"@source/design/icon/assets/app-generate.jpg\" alt=\"不同图标生成\"></p>\n<p>应该有同学这时候还会产生疑问，模板里的画布就是一个正方形，但是大多数手机的 启动图标使用的是圆角，所以，应该如何制作这个圆角，以及它的相关参数呢?</p>\n<p>真实项目中，除非项目的特定要求，只需要提交正方形的图形即可，之后无论是 APP Store，还是多数安卓应用商店，都会「自动」对该图形进行裁切，生成符合自己系统的圆角图标。</p>\n<p><img src=\"@source/design/icon/assets/app-cut.jpg\" alt=\"图表的剪切\"></p>\n<p>如果我们想要设计出正方形图形后预览真实的效果，就可以用我们准备的 PSD 模板，将正方形置入到模板中即可。</p>\n<p><img src=\"@source/design/icon/assets/app-template.jpg\" alt=\"启动图标模板\"></p>\n<p>在设计已经确认以后，我们就要导出这些图标。因为启动图标有很多拟物的设计或会使用真实的摄影素材，所以应用商店提交的格式会选用位图格式而不是矢量格式，所以导出启动图标，只需要导出对应尺寸的 PNG 即可。</p>\n<h2 id=\"启动图标的设计演示\" tabindex=\"-1\"> 启动图标的设计演示</h2>\n<h3 id=\"图标形式\" tabindex=\"-1\"> 图标形式</h3>\n<p><img src=\"@source/design/icon/assets/app-icon2.jpg\" alt=\"图标形式\"></p>\n<p>在一些比较基础的应用类型中，通常会直接使用工具图标的图形设计启动图标。因为基础的 APP 服务大多有表意极其清晰的工具图标与之对应，例如邮箱、计算器、音乐、地图等类型应用，企业往往在使用一些抽象的品牌化图形与表意更清晰的工具图标中选择后者。</p>\n<p>工具图标的设计其实很简单，就是在画板中完成两种元素的设计，一个是背景，一个是上方图标。</p>\n<p>背景的设计，比较常见的有两种类型，纯色、渐变。而上方图标的设计里，包含的类型就是我们前面讲过的几种常见的工具图标。所以您看，只要将它们组合，就可以很轻松地设计出符合主流特征的启动图标。</p>\n<p><img src=\"@source/design/icon/assets/app-combine.jpg\" alt=\"APP 组合\"></p>\n<p>所以，如果我们要设计一款笔记应用，那么就可以先画一个线性的笔记图标，然后再将它置入格线模板中确认大小，再分别为它们上色，就可以完成设计了。</p>\n<h3 id=\"文字形式\" tabindex=\"-1\"> 文字形式</h3>\n<p><img src=\"@source/design/icon/assets/app-text2.jpg\" alt=\"文字形式\"></p>\n<p>文字形式的设计，背景和上方一样，也只使用纯色和渐变，但这种设计的主要难点在于字体的设计上。</p>\n<p>想要放文字，大家首先想到的肯定是直接用字体打进去，但是切记，字体的商业版权问题是不能视而不见的。选择字体前，一定要关注该字体是否是免费的，百度或者官网都可以查询。或者一开始就在免费字库中挑选，如思源黑、思源宋、王汉宗系列等等。</p>\n<p>如果觉得直接使用字库文字太没有设计感，那可以选择做一次字体的二次创作，对于新手来说简单一点。即一开始挑选一个合适的字体，然后在 AI 中对该字体进行临摹，再对细节进行重新加工，比如衬线的调整，笔画粗细的调整等等。</p>\n<p>比如要设计一个我的应用，那么我可以取「超级帅的 Mr.Chen」的第一个字 ── 超，作为图标上方的文字。然后我选用「方正兰亭大黑」作为基础字形，对它进行重构即可。</p>\n<p><img src=\"@source/design/icon/assets/font-design.jpg\" alt=\"字体设计\"></p>\n<p>最后建议，如果不是一些比较严肃或是传统的题材，尽量不要选用宋体或是楷体进行设计。</p>\n<h3 id=\"拟物形式\" tabindex=\"-1\"> 拟物形式</h3>\n<p><img src=\"@source/design/icon/assets/app-tool.jpg\" alt=\"拟物形式\"></p>\n<p>虽然现在整体设计环境中，拟物已经被扁平取代，但不代表它已经消失，或是在形式上不合理。适当的拟物设计会让我们对应用功能的认识更清晰，且更有趣味性。</p>\n<p>还是老惯例，我们从简单的拟物设计入手。目前拟物的领域中，使用最普遍的风格也是新手最容易学习的风格，即「轻拟物」的设计。这种风格需要刻画的细节相对较少，更易于我们掌握，只要能用好渐变即可。</p>\n<p>比如，iOS 的官方应用 ── 文件，图标的形式就符合轻拟物的特征。简单分析一遍，即在确定完轮廓后，通过渐变填充来表示物体本身的高光和阴影，并添加投影来制造立体感。</p>\n<p><img src=\"@source/design/icon/assets/app-tool-design.jpg\" alt=\"iOS 文件设计\"></p>\n<p>如果要设计一些更复杂的拟物图形，可以通过多做拟物图标的练习会更有帮助。在今天扁平化图形当道的环境中，设计得精良的拟物图标往往可以在满屏的扁平图标中脱颖而出，助于吸引用户启动应用。</p>\n<h2 id=\"小结\" tabindex=\"-1\"> 小结</h2>\n<p>启动图标的介绍到这里就结束了，新手该掌握的知识点并不多。无论是更好的字体、图案、插画，都已经进入 LOGO 设计的范畴。如果要在这个领域进一步提升，那么针对性训练的效果反而不理想，需要长期积累视觉、图形的整体设计能力。</p>\n",
      "date_published": "2020-09-14T00:00:00.000Z",
      "date_modified": "2022-08-20T08:54:00.000Z",
      "authors": [],
      "tags": [
        "设计"
      ]
    },
    {
      "title": "图标种类",
      "url": "https://github.com/MisterChen9527/design/icon/type.html",
      "id": "https://github.com/MisterChen9527/design/icon/type.html",
      "summary": "设计图标可以划分成三种大类:\n\n工具图标\n装饰图标\n主体图标\n\n下面将对它们分别进行介绍，以及展示相关的设计类型。\n",
      "content_html": "<p>设计图标可以划分成三种大类:</p>\n<ul>\n<li>工具图标</li>\n<li>装饰图标</li>\n<li>主体图标</li>\n</ul>\n<p>下面将对它们分别进行介绍，以及展示相关的设计类型。</p>\n\n<h2 id=\"工具图标\" tabindex=\"-1\"> 工具图标</h2>\n<p>工具图标是在日常讨论中提及最频繁的图标类型，即应用内有明确功能、提示含义的标识。</p>\n<p><img src=\"@source/design/icon/assets/tool-icon.jpg\" alt=\"常见的工具图标\"></p>\n<p>虽然理解起来容易，但是它所包含的设计样式却并不少，可以把它们归纳成线性、面性两个大类，再分别进行细分。</p>\n<h3 id=\"线性风格\" tabindex=\"-1\"> 线性风格</h3>\n<p>线性图标，即图形是通过线条的描边轮廓勾勒出来的。多数人对它样式认识的第一反应应该是使用纯色的闭合轮廓，比如上图案例，线性图标的创作空间看似不多，但实际上有非常多的调整空间。</p>\n<p>下面我们把它们罗列出来。</p>\n<p><img src=\"@source/design/icon/assets/icon-line.jpg\" alt=\"线性风格的工具图标\"></p>\n<h3 id=\"面性风格\" tabindex=\"-1\"> 面性风格</h3>\n<p>面性图标，即使用对内容区域进行色彩填充的图标样式。同样，在这类图标中，也不是只能应用纯色的方式进行填充，还有非常多的视觉表现类型。</p>\n<p><img src=\"@source/design/icon/assets/icon-face.jpg\" alt=\"面性风格的工具图标\"></p>\n<h3 id=\"混合风格\" tabindex=\"-1\"> 混合风格</h3>\n<p>当然，在设计图标类型的时候，也不一定非线性和面性不可，有一些热衷创造和尝试的设计师，还创作出了混合型的图标，既有线性描边的轮廓，又有色彩填充的区域。常见的样式类型如下:</p>\n<p><img src=\"@source/design/icon/assets/icon-mix.jpg\" alt=\"混合风格的工具图标\"></p>\n<h2 id=\"装饰图标\" tabindex=\"-1\"> 装饰图标</h2>\n<p>和工具图标比起来，装饰图标的视觉性作用更多。对于一些比较复杂的应用来说，过分的简约并不能弥补信息过多的信噪问题，那么要通过丰富视觉体验的方法来增加内容的观赏性，减少一屏内显示内容的数量。</p>\n<p>比如在分类列表里，是可以只使用线框和文字把大量内容浓缩到一屏以内，但实际浏览效率并不会增加，而且并不美观。</p>\n<p><img src=\"@source/design/icon/assets/icon-decorate.jpg\" alt=\"装饰图标在识别性上的作用\"></p>\n<p>还有就是国内的界面设计环境，会根据运营需求设计进行特殊化处理，尤其在电商领域，首屏的图标都会改成首页风格的样式，增加活动氛围。</p>\n<p><img src=\"@source/design/icon/assets/icon-festival.jpg\" alt=\"节日活动中的装饰图标\"></p>\n<p>装饰性的图标设计，虽然没有明确的规范该怎么做，效果怎么好怎么来，但最常见的类型有四种，下面分别进行介绍。</p>\n<h3 id=\"扁平风格\" tabindex=\"-1\"> 扁平风格</h3>\n<p>扁平风格的装饰图标，通常可以理解成是用扁平插画的方式画出来的图标，除了继承扁平的纯色填充特性以外，也比普通图标有更丰富的细节与趣味性。</p>\n<p><img src=\"@source/design/icon/assets/icon-flat.jpg\" alt=\"扁平风格的装饰图标\"></p>\n<h3 id=\"拟物风格\" tabindex=\"-1\"> 拟物风格</h3>\n<p>拟物风格的图标现在出现的频率越来越高，集中在大型的运营活动中，通常这些活动会通过拟物的方式将头部设计成有故事性的场景，所以自然顶部的相关图标使用拟物的设计形式会更贴合。</p>\n<p><img src=\"@source/design/icon/assets/icon-material.jpg\" alt=\"拟物风格的装饰图标\"></p>\n<h3 id=\"_2-5d-风格\" tabindex=\"-1\"> 2.5D 风格</h3>\n<p>2.5D 是一种偏卡通、像素画风格的扁平设计类型，在一些非必要的设计环境中，使用 2.5D 会比较容易搭配主流的界面设计风格，有更强的趣味性和层次感。</p>\n<p><img src=\"@source/design/icon/assets/icon-2.5D.jpg\" alt=\"2.5D风格的装饰图标\"></p>\n<h3 id=\"炫彩渐变\" tabindex=\"-1\"> 炫彩渐变</h3>\n<p>这是一个拗口的原创名词，找不到更合适的形容，还是觉得浮夸点符合它的气质。这种图标，就是通过一系列非常激进的渐变和撞色实现，通常还会使用彩色的阴影。</p>\n<p>使用这样图标的区域，通常都会呈现出一副五彩斑斓的景象，只有在内容非常丰富且用户偏向年轻化的产品中可以使用，是一种非常难驾驭的设计风格。</p>\n<p><img src=\"@source/design/icon/assets/icon-gradient.jpg\" alt=\"炫彩渐变风格的装饰图标\"></p>\n<h3 id=\"实物贴图\" tabindex=\"-1\"> 实物贴图</h3>\n<p>采用真实摄影物体的设计风格。它不完全依靠创作和绘制。</p>\n<p><img src=\"@source/design/icon/assets/icon-real.jpg\" alt=\"应用摄影实物的装饰图标\"></p>\n<h2 id=\"主体图标\" tabindex=\"-1\"> 主体图标</h2>\n<p>主体图标的设计比前面两种类型的图标说起来更难，因为它实际上就是把「LOGO 嵌套进系统图标模版」的图标。</p>\n<p>除了掌握必要的规范以外，主体图标的主体物设计就是 LOGO 的设计。</p>\n<h3 id=\"文字形式\" tabindex=\"-1\"> 文字形式</h3>\n<p>使用了文字作为图标主体物的类型，通常是这类应用本身的品牌 LOGO 就使用了文字，所以这里就把字体照搬过来。</p>\n<p><img src=\"@source/design/icon/assets/app-text.jpg\" alt=\"文字类的主体图标\"></p>\n<h3 id=\"图标形式\" tabindex=\"-1\"> 图标形式</h3>\n<p>对于一些偏工具，适合用简单图形传达应用功能的主体图标，就会采取使用工具图标的方式设计。</p>\n<p><img src=\"@source/design/icon/assets/app-icon.jpg\" alt=\"图标类的主体图标\"></p>\n<h3 id=\"图形图标\" tabindex=\"-1\"> 图形图标</h3>\n<p>图形形式看起来和图标形式很接近，但实际上完全不属于同一类型，之所以它不是图标，是因为这类图标的主体图形是一种经过高度抽象化的标识，传达的是品牌性，而不是图形的含义。</p>\n<p><img src=\"@source/design/icon/assets/app-shape.jpg\" alt=\"图形类的主体图标\"></p>\n<h3 id=\"插画形式\" tabindex=\"-1\"> 插画形式</h3>\n<p>对于一些比较纯粹的应用，如读本、漫画、幼儿类应用，就热衷于采用卡通形象作为图标的主体进行设计。</p>\n<p><img src=\"@source/design/icon/assets/app-paint.jpg\" alt=\"插画类的主体图标\"></p>\n<h3 id=\"拟物形式\" tabindex=\"-1\"> 拟物形式</h3>\n<p>虽然现在扁平化的设计占据主导地位，但依旧有很多应用的主体图标是通过拟物的方式设计的。因为对于这些应用来说，拟物设计所传递的信息往往更直观和准确。</p>\n<p><img src=\"@source/design/icon/assets/app-real.jpg\" alt=\"拟物类的主体图标\"></p>\n<hr>\n<p>当然，还有其它的数之不尽的主体图标设计方式，比如明星大头照、摄影图、游戏原画等，但理解上面这些类型就够了。</p>\n<p>前面介绍的三种图标，就是今后在进入 UI 行业设计的内容。虽然图标看起来简单，但可以玩出的花样不少。除了正确设计出图标以外，高低阶的 UI 设计师之间的区别也包含图标设计类型掌握的多寡。</p>\n<p>所以，在开始学习前，不要将设计图标的目标局限在最简单的图形绘制上，还有很多有趣的设计形式等待尝试。</p>\n<h2 id=\"总结\" tabindex=\"-1\"> 总结</h2>\n<p>UI 会涉及的图标类型主要有三种，工具图标、装饰图标、启动图标。</p>\n<ol>\n<li>工具图标，是界面中用来传递信息的图形符号，主要包含线性、面性、混合三种设计风格。</li>\n<li>装饰图标，是界面中用来提升视觉体验的图形，主要包含扁平、拟物、2.5D、渐变炫彩等设计风格。</li>\n<li>启动图标，是用来启动应用的图标，主要包含文字、图标、图形、插画、拟物等设计形式。</li>\n</ol>\n",
      "date_published": "2020-09-13T00:00:00.000Z",
      "date_modified": "2022-08-20T08:54:00.000Z",
      "authors": [],
      "tags": [
        "设计"
      ]
    },
    {
      "title": "交互设计",
      "url": "https://github.com/MisterChen9527/design/interact/",
      "id": "https://github.com/MisterChen9527/design/interact/",
      "content_html": "<h2 id=\"文章列表\" tabindex=\"-1\"> 文章列表</h2>\n<ul>\n<li>\n<p><a href=\"/design/interact/search.html\">搜索框</a></p>\n</li>\n<li>\n<p><a href=\"/design/interact/text-field.html\">文本框</a></p>\n</li>\n</ul>\n",
      "date_published": "2020-09-26T00:00:00.000Z",
      "date_modified": "2022-08-20T08:54:00.000Z",
      "authors": [],
      "tags": [
        "设计"
      ]
    },
    {
      "title": "搜索框设计",
      "url": "https://github.com/MisterChen9527/design/interact/search.html",
      "id": "https://github.com/MisterChen9527/design/interact/search.html",
      "content_html": "<p>搜索框是我们最常用到的 UI 控件之一，它几乎存在于所有的网站和 APP 当中。许多人认为搜索框不需要设计，因为它似乎就是由两个最简单的元素构成的。在以内容为导向的网站中，搜索框的重要性会相对更明显，用户需要快速又无痛地找到他们想要的内容。而对于设计相对负责的网站而言，这个需求尤其明显。搜索框的可用性设计，是整个设计的关键，也就是如何让用户尽量节省时间，搜到他们想要的内容。</p>\n<h2 id=\"使用放大镜图标\" tabindex=\"-1\"> 使用放大镜图标</h2>\n<p>时至今日，搜索的概念和放大镜图标之间的关系已经深入人心，根深蒂固了。在日常最常用、最易于识别的几个图标当中，放大镜所带代表的搜索图标就是其中之一。</p>\n<p><img src=\"@source/design/interact/assets/search-icon.png\" alt=\"放大镜图标\"></p>\n<p>即使在没有文本标签标识的情况下，用户也能轻松地识别图标的含义。</p>\n<div><p>提示</p>\n<p>使用最简略直观的放大镜图标，细节越少，越容易识别。</p>\n</div>\n<h2 id=\"显眼的搜索输入框\" tabindex=\"-1\"> 显眼的搜索输入框</h2>\n<p>如果搜索是您的网站或者 APP 的重要功能的话，您应当让搜索框足够显眼，这样的能设计让用户最快发现它的存在。</p>\n<p><img src=\"@source/design/interact/assets/search-eye-catching.png\" alt=\"显眼的搜索输入框\"></p>\n<p>左边: 搜索功能隐藏在图标之后</p>\n<p>显示完整的文本输入框是很重要的，隐藏在按钮背后的输入框会让用户觉得不是那么明显，不容易被快速发现。需要点击之后用户才能看到。</p>\n<p><img src=\"@source/design/interact/assets/search-using-icon.gif\" alt=\"使用图标的搜索框\"></p>\n<div><p>提示</p>\n<p>由于博客新用户通常会浏览博客的大致内容，而不会有目的性的搜索，所以移动视图下，博客的搜索也采用了这种设计</p>\n</div>\n<h2 id=\"提供搜索按钮\" tabindex=\"-1\"> 提供搜索按钮</h2>\n<p>按钮的存在让用户能够明白搜索的触发方式——也就是说通过触发按钮来完成这一操作。</p>\n<p><img src=\"@source/design/interact/assets/search-button.jpeg\" alt=\"3、提供搜索按钮\"></p>\n<div><p>有效的建议</p>\n<p>本博客由于采用了即时搜索，也就是会实时显示输入的搜索结果，所以并没有设置这个按钮</p>\n<ul>\n<li>控制搜索按钮的尺寸大小，让用户使用光标可以轻松找到并点击，让触发区域大小合适。</li>\n<li>让用户可以通过回车键提交搜索，许多用户仍然有通过点击键盘按键来触发搜索的习惯。</li>\n</ul>\n</div>\n<h2 id=\"每页都保留搜索输入框\" tabindex=\"-1\"> 每页都保留搜索输入框</h2>\n<p>您应该为用户拥有在每个页面都能立刻进行搜索的权限，如果您的用户在特定的页面找不到他们想要的内容，可以立刻通过搜索获取内容，无论他在网站的哪个地方。</p>\n<h2 id=\"让搜索框尽量简单\" tabindex=\"-1\"> 让搜索框尽量简单</h2>\n<p>在您设计搜索框的时候，请尽量让它看起来就是一个搜索框，并且简单易用。可用性研究表明，默认没有显示高级选项的搜索框看起来更加友好，所以，通常情况下给用户提供的搜索框最好不要提供进阶的搜索选项。</p>\n<p><img src=\"@source/design/interact/assets/advance-search.jpeg\" alt=\"这可能会让新用户很困扰\"></p>\n<h2 id=\"让搜索框处于用户预期的位置\" tabindex=\"-1\"> 让搜索框处于用户预期的位置</h2>\n<p>当用户想要搜索内容的时候还需要花费精力来寻找搜索框，这就非常尴尬了。这意味着搜索框本身就不容易被察觉。</p>\n<p>下面这个图表来自 A. Dawn Shaikh 和 Keisi Lenz 的一项研究，它展示出了 142 名被调查者对于网站的搜索框的预期的位置。这项研究表明，网站的左上角和右上角是用户所期待的搜索框的位置，用户在使用 F 型扫视法查看内容的时候，可以轻松找到搜索框。</p>\n<p><img src=\"@source/design/interact/assets/search-position.gif\" alt=\"搜索框位置\"></p>\n<p>这份研究还表明，右上角的区域是用户搜寻输入框的首选区域。</p>\n<p>因此，将输入框置于顶部靠右或者顶部居中的位置，用户会主动在这个地方寻找搜索框。</p>\n<div><p>提示</p>\n<p>本博客主题在 Desktop 模式下搜索栏即为居中设计，移动视图下置于右上角</p>\n<ul>\n<li>在理想情况下，搜索框的设计应当和整个网站的设计风格保持一致，同时在视觉上要略显突出，便于用户发觉它的存在。</li>\n<li>如果网站的内容足够多，搜索框在设计上显著程度应该越高，如果搜索功能对于您的网站至关重要，那么您应该采用较大的对比度，确保输入框和按钮从背景中脱颖而出。</li>\n</ul>\n</div>\n<h2 id=\"合理的输入框尺寸\" tabindex=\"-1\"> 合理的输入框尺寸</h2>\n<p>输入框太小是最常见的搜索框设计错素，虽然用户可以输入比输入框更长的内容，但是可见的部分往往无法完全可见，这种设计的可用性并不强。这样的输入框可能因为可视范围的限制，促使用户使用短的、不精确的查询方式，因为更长的内容并不适合阅读。如果输入框能够符合用户的常见输入内容的尺寸来进行匹配，那么它的可用性会更强。</p>\n<p>根据经验，输入框能够承载的最佳字符数量为 27 个，百分之 90 的搜索内容都在这个长度以内。</p>\n<p><img src=\"@source/design/interact/assets/search-size.png\" alt=\"合适的输入框长度\"></p>\n<p>小贴士: 建议考虑使用能根据输入长度增长而能变长的输入框，这不仅节省了屏幕空间，而且能够给予用户足够的视觉提示，并快速进入搜索环节。</p>\n<p><img src=\"@source/design/interact/assets/search-expand.png\" alt=\"长度增长的输入框\"></p>\n<h2 id=\"使用自动搜索建议机制\" tabindex=\"-1\"> 使用自动搜索建议机制</h2>\n<p>自动建议机制能够帮助用户在输入的过程中，动态地预测正确的查询方向。自动建议并不会加快搜索的过程，但是能够帮助用户构建正确的搜索关键词/内容。普通用户在第一次搜索结果不理想的情况下，很少会继续进行尝试，而自动建议运作顺利的情况下，将会帮助用户更好的搜索。</p>\n<p>谷歌搜索在这方面有着丰富的经验，自 2008 年开始，谷歌开始记录用户的搜索记录，并且通过这种方式节省时间，优化结果，创造更为优秀的体验。</p>\n<div><p>提示</p>\n<ul>\n<li>确保您的自动搜索建议是有用的。不当的搜索建议内容可能会混淆和分散用户的注意力。尽量帮助用户更正拼写，识别词根，预测文本，并改进您的工具。</li>\n<li>当用户开始输入之后，尽快开始给予用户建议，例如在第三个字符之后，为用户开始提供即时的、有价值的建议，降低用户的输入难度和工作量。</li>\n<li>尽量为用户提供少于 10 个搜索结果，避免信息过载。</li>\n<li>允许使用键盘进行交互，当用户使用方向键向下滚动到最后的条目之后，继续滚动会跳转到顶部的项目。允许用户使用 Esc 按键推出列表。</li>\n<li>突出显示输入的信息和建议的信息之间的差异。</li>\n</ul>\n</div>\n<p><img src=\"@source/design/interact/assets/auto-suggest.png\" alt=\"自动搜索建议\"></p>\n<h2 id=\"让用户明白哪些可以搜索到\" tabindex=\"-1\"> 让用户明白哪些可以搜索到</h2>\n<p>最好是在输入框中包含示例，这样可以向用户给予建议。如果用户可以输入多个关键词搜索，那么可以像下面的 IMDB 的网站一样给予建议。HTML5 可以轻松的实现在输入框内加入文本占位符。</p>\n<p><img src=\"@source/design/interact/assets/search-hint.png\" alt=\"搜索建议\"></p>\n<div><p>提示</p>\n<p>建议的内容不宜过多，否则施加太多认知负荷给用户。</p>\n</div>\n",
      "date_published": "2020-09-15T00:00:00.000Z",
      "date_modified": "2022-08-20T08:54:00.000Z",
      "authors": [],
      "tags": [
        "设计"
      ]
    },
    {
      "title": "文本框设计",
      "url": "https://github.com/MisterChen9527/design/interact/text-field.html",
      "id": "https://github.com/MisterChen9527/design/interact/text-field.html",
      "content_html": "<p>文本框的出现几乎可以追溯到可视化交互诞生的源头，是一个再经典不过的「鼻祖」控件了。我们每天都在和文本框打交道，不论您是产品设计者还是用户。</p>\n<h2 id=\"文本框的拆解\" tabindex=\"-1\"> 文本框的拆解</h2>\n<p>文本框(Text Fields)根据 Material Design 指导规范，被拆解为七个部分。分别是:</p>\n<p><img src=\"@source/design/interact/assets/text-field.jpg\" alt=\"文本框的拆解\"></p>\n<ul>\n<li>容器(Container)</li>\n<li>前导图标(Leading icon)</li>\n<li>标签文本(Label text)</li>\n<li>输入文本(Input text)</li>\n<li>尾随图标(Trailing icon)</li>\n<li>激活指示器(Activation indicator)</li>\n<li>帮助文本(Helper text)</li>\n</ul>\n<p>当然，MD 为我们展示的是已经经过其团队长期摸索之后，基于其平台规范下的标准样式。想要探索文本框的交互演变，我们还是要回溯到文本框最初的模样。</p>\n<p><img src=\"@source/design/interact/assets/text-field-original.jpg\" alt=\"文本框基础样式\"></p>\n<p>这就是一个文本框最基础的样式了， 一个标签文本+容器，已经基本可以确保向用户传递文本框最直观的信息。</p>\n<p>但如今的文本框已经演变出了形形色色的样式和交互形式，究竟 MD 的文本框是如何演变到今天这番样子?</p>\n<h2 id=\"基础的文本框布局方式\" tabindex=\"-1\"> 基础的文本框布局方式</h2>\n<p>激励设计师不停探索文本框新的交互形式的根本原因之一，一定包含总让人头疼的排版问题。在解决了基本视觉问题之后，才是思考如何设计文本框来 提升用户的填写和使用效率。</p>\n<p>例如前面我们所看到的最基础的文本框样式，如果简单地进行单列布局，自然而然会出现让众多设计师纠结的一个问题: 标签文本究竟应该如何对齐?</p>\n<p><img src=\"@source/design/interact/assets/text-field-align.jpg\" alt=\"文本框对齐\"></p>\n<p>如果标签文本采用右对齐，标签文本的长短问题容易导致左侧的视觉隐形边界错乱，用户的规律眼动容易被打乱；</p>\n<p>如果标签文本采用左对齐，文本的长短问题又会导致部分较短标签文本与容器间距增大，让用户从左至右浏览的效率降低，并且看起来不够协调。</p>\n<p>于是乎文本框的布局方式有了进一步的演变: 标签文本与容器顶端对齐。</p>\n<p><img src=\"@source/design/interact/assets/text-field-align2.jpg\" alt=\"文本框对齐\"></p>\n<p>顶端对齐的方式使得用户眼动变得十分规律，竖直向下浏览可以便捷地理解标签文本并进行填写，文本的长短问题不再成为干扰设计师进行排版的一个纠结点。</p>\n<p>但纵向布局的的方式只是把问题迁移到了另一个维度，那就是在表单数据量过多时，纵向布局会使得纵向空间耗损增加，用户需要不停地滑动页面才能实现表单的完整填写。</p>\n<p>所以，文本框的布局需要多方位评估标签文本长度、表单数据量等问题，才能对具体场景进行有效设计。</p>\n<h2 id=\"文本框的改良\" tabindex=\"-1\"> 文本框的改良</h2>\n<p>当文本框横向布局或是纵向布局都很难解决具体场景问题的时候，更新颖的文本框交互形式就出现了。</p>\n<p>最初的演变形式是众多的应用开始采用前导图标来替代标签文本，使用图标可以有效地解决标签文本导致的排版错落问题。</p>\n<p><img src=\"@source/design/interact/assets/text-field-icon.jpg\" alt=\"图标提示\"></p>\n<p>这种方案在轻量表单中较为常见，一般都是在表单内容少、用户对于场景的熟悉度较高的情景当中(例如登录场景)。</p>\n<p>因为每个用户对于图标的认知性存在差异，在生疏场景或表单内容过多的情况下，图标容易导致用户对文本框信息产生更多的认知成本。所以用图标来代替标签文本的普适性其实并不高。</p>\n<p>于是后来 iOS 人机交互规范 和 MD 规范 都给设计师提出了一条指导建议: 当占位符字段中不包含必要内容时，可以合理地使用占位符来承载标签文本。</p>\n<p>例如 iOS 通讯录新增联系人，就采用了占位符承载标签文本的方式。</p>\n<p><img src=\"@source/design/interact/assets/text-field-placeholder.jpg\" alt=\"iOS 占位符提示\"></p>\n<p>但这种形式同样也存在一个弊端: 用户一旦输入内容之后，占位符就被内容文本填充覆盖了，有时用户会忘记所填写的信息是关于什么内容，必须要清空文本进行重新确认。对于表单内容繁多或重要内容需要谨慎填写的场景，这样的交互其实还是有一些不妥。</p>\n<p>于是乎，类似 MD 的指导规范下这样普适性较高的文本框形式就诞生了。采用占位符承载标签文本，并且在用户填写信息时，标签文本始终可见，由占位符转移到文本框顶部。</p>\n<p><img src=\"@source/design/interact/assets/text-field-md.gif\" alt=\"MD 标签\"></p>\n<p>这一文本框交互形式的诞生，不论是对于排版空间的节省、遵循用户眼动习惯、微动效提升文本框趣味性等方面，都得到了一定提升。并且许多应用开始进行借鉴效仿。</p>\n<p>其实像以上这种巧用占位符的场景已经越来越常见了，占位符已经不再仅仅用来承载无用信息或提示性信息，也可以用于承载 默认值，帮助用户自动填充， 提高用户填写信息的效率(例如手游当中，创建账号时系统帮玩家默认填充一个可用昵称)。</p>\n<p>但填充默认值的手法也不仅仅局限于提升用户体验和填写效率，甚至也被运用到了一些商业场景中。</p>\n<p>例如淘宝、京东等电商平台，将商品名称作为占位符填充在搜索栏中，一方面给所推荐商品增加了曝光；另一方面，在用户直接点击搜索时，将会以当前占位符内容进行搜索，达到为所推荐商品引流的效果。</p>\n<p><img src=\"@source/design/interact/assets/text-field-placeholder-search.jpg\" alt=\"引流\"></p>\n<h2 id=\"合理的反馈\" tabindex=\"-1\"> 合理的反馈</h2>\n<p>合理的反馈机制对于提升用户填写文本框效率也起着重要的作用，MD 规范中的帮助文本不仅仅是告诉设计者可以用于指导用户该如何正确填写文本框信息，也为反馈提示提供了展示空间。</p>\n<p>MD 的反馈状态可以归纳为以下几种:</p>\n<p><img src=\"@source/design/interact/assets/text-field-feedback.jpg\" alt=\"反馈\"></p>\n<p>在这里我大概总结了一下文本框的负反馈提示信息，希望在您设计表单的时候，能够帮助到您对负反馈提示状态进行走查(可能不全，欢迎补充):</p>\n<ul>\n<li>内容是否为空(例: 必填项不能为空)</li>\n<li>二次确认内容是否一致(例: 确认密码与首次输入不一致)</li>\n<li>内容是否合规 (例: 昵称中包含不文明词语)</li>\n<li>内容格式是否合规(例: 昵称中不能包含特殊字符)</li>\n<li>内容长度是否合规(例: 手机号输入不足 11 位)</li>\n<li>内容的是否符合唯一性(例: 验证码输入错误)</li>\n</ul>\n<p>及时给予用户负反馈，可以让用户清晰地排查所发生的错误。但交互设计讲究「以人为本」，在某些场景中，当用户所填写的信息是合理的，及时地展示 正向反馈也是有必要的。</p>\n<p>例如，部分应用在用户创建账号的场景中，当用户输入账号信息后，系统将立刻检索用户的账号是否已存在在当前数据库中，避免用户忘记已创建过该账号而进行重复创建的徒劳步骤。</p>\n<p><img src=\"@source/design/interact/assets/text-field-feedback2.jpg\" alt=\"反馈\"></p>\n<p>所以不要狭隘地认为 MD 所给到的帮助文本只能用于「批评」用户(负反馈)， 当用户做了正确的事时，也应该适当地激励用户，这也正符合了尼尔森可见性原则。</p>\n",
      "date_published": "2020-09-26T00:00:00.000Z",
      "date_modified": "2022-08-20T08:54:00.000Z",
      "authors": [],
      "tags": [
        "设计"
      ]
    },
    {
      "title": "导航设计教程",
      "url": "https://github.com/MisterChen9527/design/navigation/",
      "id": "https://github.com/MisterChen9527/design/navigation/",
      "content_html": "<h2 id=\"目录\" tabindex=\"-1\"> 目录</h2>\n<ul>\n<li>\n<p><a href=\"/design/navigation/intro.html\">导航设计介绍</a></p>\n</li>\n<li>\n<p><a href=\"/design/navigation/navbar.html\">导航栏概述与设计方式</a></p>\n</li>\n<li>\n<p><a href=\"/design/navigation/navbar-design.html\">导航栏设计技巧</a></p>\n</li>\n<li>\n<p><a href=\"/design/navigation/sidebar-navigate.html\">侧边导航设计</a></p>\n</li>\n<li>\n<p><a href=\"/design/navigation/tabbar.html\">标签导航设计</a></p>\n</li>\n<li>\n<p><a href=\"/design/navigation/tabbar-design.html\">标签导航设计技巧</a></p>\n</li>\n</ul>\n",
      "date_published": "2020-09-15T00:00:00.000Z",
      "date_modified": "2022-08-20T08:54:00.000Z",
      "authors": [],
      "tags": [
        "设计"
      ]
    },
    {
      "title": "导航设计介绍",
      "url": "https://github.com/MisterChen9527/design/navigation/intro.html",
      "id": "https://github.com/MisterChen9527/design/navigation/intro.html",
      "content_html": "<p>其实网页或者 App 中的导航(Navigation)这个概念远不止我们熟悉的导航栏，而是一个更加广的交互概念: 引导用户和产品进行有效的交互，实现用户的目标。本文将详细地介绍界面的导航设计。</p>\n<p>一个网页或 App 产品要想有很好的可用性(usability)，需要做好的最基本的一点是导航的设计或者说引导用户的设计。如果用户在使用一个网站或者 App 的时候找不到自己的处在什么位置或者该怎么去到想要的页面，那么视觉效果再怎么有创意或者抓人眼球都无法弥补产品的缺陷。无论您的产品想满足用户什么需求，让用户知道产品当下的状态和每一步操作之后的结果是对用户最基本的尊重。</p>\n<h2 id=\"导航\" tabindex=\"-1\"> 导航</h2>\n<p>首先，让我们弄清楚导航这个概念。最基本的含义就是在我们的现实世界中，当我们从一个地方到另一个地方，需要一些引导和指示。英文中 Navigation 这个词来源于拉丁文，原意就是: 操纵船只在海上航行。所以导航就是能够帮助我们到达目的地的行为。导航的其他意思都是建立在这个原意的基础上。</p>\n<p>所以回到 UX／UI 设计上，导航毫无疑问是可用性的一个要点。它可以定义为一系列引导用户成功地与产品互动并且实现他们目标的动作组合或者技巧组合。用户带着他们的期望和目标来使用您的网站或者产品，作为设计师的您需要给他们提供实现他们目标的最好操作流程。因此当您的导航设计得非常高效，用户体验能得到极大的提升。</p>\n<p>界面的导航(Navigation)是用户体验设计的核心之一。毫无疑问，如果您看不到路, 您就去不了您的目的地。用户现在正面对着越来越多的网站和 APP 产品。越来越多的选择会让用户期望这些产品具备符合他们使用习惯的导航设计。</p>\n<p>在您刚开始设计您的界面时，就要思考怎么设计一个有效的无缝衔接的导航。通过一些可交互的元素，比如按钮(buttons)，开关(switches)，链接(links)，标签(tabs)，条(bas)，菜单(menus)，区域(fields)，让用户在不同的界面之间进行切换。</p>\n<p>工作室的设计思路是，在界面设计的早期就全面地思考导航的设计，包括界面的布局，页面间如何切换，导航元素的放置和具体功能。并且通过低保真原型来进行验证，保证用户能清楚地理解所有重要的操作。如果跳过这一步，设计将有巨大的风险，其他事情有可能到头来都白干了。所以无论，对用户还是客户还是设计团队来讲，做好这最基础的部分是非常有好处的。</p>\n<h2 id=\"菜单-menu\" tabindex=\"-1\"> 菜单(Menu)</h2>\n<p>菜单是我们最熟悉的具备导航功能的元素，它向用户展示了界面的所有重要选项。基本上，它可以是用动词命名的一系列指令，用户可以用它来指示系统做出动作，像保存，删除等；它也可以是一个用名词命名的目录，用来代表不同内容的集合。</p>\n<p>在界面设计中菜单可以放在不同的位置(侧边菜单，顶部菜单，底部菜单等)，拥有不同的交互和视觉形式(下拉菜单，上拉菜单，滑动菜单等)。要想设计好菜单的位置、交互和视觉形式，设计师需要经过全面的用户调查，包括目标用户的预期和要求、接受能力和使用情境。好的菜单设计能让用户更快地实现他们的目标，为用户体验打下坚实的基础。</p>\n<p>博客的界面设计，采用了侧边菜单以及目录的形式，文字直接说明内容，再加上图标来做为辅助的视觉说明。</p>\n<p><img src=\"@source/design/navigation/assets/color.jpg\" alt=\"颜色的设计\"></p>\n<p>这个 UI 概念设计的例子很好的运用了颜色作为标记，这是一种很有效的导航技巧: 每个分类的背景色使用了和目录相同的的颜色，这样目录和内容有着非常强的相关性，用户能自然地将他们联系起来。</p>\n<h2 id=\"行为召唤-cta\" tabindex=\"-1\"> 行为召唤(CTA)</h2>\n<p>CTA 是用户行为召唤的简称(call to action)。CTA 简单来说就是指设计师通过设计，刺激用户去做出一些行动。相应的，CTA 元素就是指那些能刺激用户做出行动的交互元素。典型的 CTA 元素是按钮，标签或者链接。</p>\n<p>不管在什么界面，CTA 元素都是高效的交互行为的核心，极大的关系到产品的可用性和导航有效性。如果 CTA 元素的设计不到位的话，用户会产生困惑并且得费劲地去尝试。产品的转化率和用户体验都会大打折扣。这就是为什么 CTA 元素特别值得注意。无论什么样的界面，它都必须是最瞩目的元素之一，用来直接地告诉用户怎么用这个产品。</p>\n<p><img src=\"@source/design/navigation/assets/CTA-example.gif\" alt=\"APP 案例\"></p>\n<p>一些 CTA 元素直接用图标形式而没有任何文字说明，但只适用于大家都熟知其含义的图标，比如听筒图标和信封图标。上图这个例子中，这个听筒图标就是这个界面中一个焦点，是一个典型的 CTA 元素，引导用户快速地实现他们的目标。不需要任何文字说明，用户也能懂点击这个图标的结果。</p>\n<p>但是，如果一个图标的含义不是那么明显或者可能造成误解，最好还是加上文字说明。</p>\n<p><img src=\"@source/design/navigation/assets/CTA-example.jpg\" alt=\"网站着陆页\"></p>\n<p>上面这个例子是一个关于制作海鲜的网站的着陆页(Landing page)。页面的标题 let’s cook 还有食材照片是一个 CTA，但不是一个可交互的 CTA。可交互的 CTA 是下面这个红色按钮，用户点击这个按钮能看到更多关于不同主题和菜谱的信息。抓人眼球的颜色强调了页面的视觉层级关系，把用户的注意力拉到关键的交互区域中。</p>\n<h2 id=\"条-bar\" tabindex=\"-1\"> 条(Bar)</h2>\n<p>条(Bar)指的是界面中一组用户可以点击的元素，用来快速与产品进行互动，或者还能让用户知道事件的进程。</p>\n<h3 id=\"标签条-bar\" tabindex=\"-1\"> 标签条(Bar)</h3>\n<p>最基本的条是标签条(Tab bars)，常出现在 APP 界面的底部，让用户能在 APP 的不同模块间快速切换。</p>\n<p><img src=\"@source/design/navigation/assets/tabbar.jpg\" alt=\"Tabbar\"></p>\n<h3 id=\"载入条-loading-bar\" tabindex=\"-1\"> 载入条(Loading bar)</h3>\n<p>载入条是用来告知某个动作的进展，用户可以通过时间、百分比或者其他信息了解整个过程。</p>\n<div><p>提示</p>\n<p>比如本博客在跳转新页面的时候导航栏下方就会出现载入条</p>\n</div>\n<h3 id=\"进度条-progress-bar\" tabindex=\"-1\"> 进度条(Progress bar)</h3>\n<p>给用户提供反馈，让他们了解事件的进度，比如说计划的事情完成了多少。</p>\n<div><p>提示</p>\n<p>最常见的就是音乐和视频 APP</p>\n</div>\n<h2 id=\"按钮-button\" tabindex=\"-1\"> 按钮(Button)</h2>\n<p>按钮应该是用得最多的元素了。按钮能让用户在对系统发出指令后得到恰当的反馈。用户通过按钮对系统下命令，跟系统进行交互从而实现他们某个目标，比如发送邮件，买一个东西，下载文件，播放音乐等等这样的指令。按钮之所以那么的常用和对用户那么友好，是因为按钮很好地模仿了人和真实世界里跟物品的交互。</p>\n<p>现如今的 UI 按钮有不计其数的设计样式，能满足很多的设计需求。按钮典型的用途是表明这个地方是可点击，因此需要具有非常高的视觉识别，有着特定的形状还有文字说明它能实现什么动作。设计师通常需要花不少时间好好考虑怎么让按钮很好地融合界面的风格，同时又能在视觉上跳脱出来。</p>\n<p><img src=\"@source/design/navigation/assets/404.jpg\" alt=\"404 页面\"></p>\n<hr>\n<p>以下是在 APP 和网页设计中常用的几种具备附加功能的按钮。</p>\n<h3 id=\"汉堡按钮\" tabindex=\"-1\"> 汉堡按钮</h3>\n<p>汉堡按钮隐藏着一个菜单。当用户点击他们的时候，能把菜单调出来。有这个名字是因为它是由三条水平线组成的，看起来就像是汉堡的形式。它是一个典型的交互元素，也是颇具争议的元素。</p>\n<p>大多数用户知道点击这个按钮能展开一个菜单，所以不需要额外的说明。汉堡菜单极大地节省了界面的空间，能让界面看起来更简洁，也为其他重要的界面元素腾出了必要的空间。它同时非常适合响应式设计，通过隐藏菜单让整个设计更统一，界面能在不同设备间保持一致。尽管它因为一些缺点而饱受争议，但因为这极大的好处，它目前仍然被广泛的使用。关于这个元素的主要诟病是，对于一些对界面不太熟悉的用户来说，这个比较抽象的设计元素可能会让他们产生困惑。所以，在决定使用汉堡菜单前，应该调查一下目标用户的接受程度和他们的需求。</p>\n<div><p>提示</p>\n<p>我的博客在移动视图下左上角就应用了汉堡按钮</p>\n</div>\n<h3 id=\"加号按钮-plus-button\" tabindex=\"-1\"> 加号按钮(Plus button)</h3>\n<p>一般通过这个按钮，用户可以实现添加某个内容的动作，比如添加新的联系人，状态，笔记，位置等所有用户在产品里能做的基本动作。有时候，点击这个按钮会出现新的窗口。有时候还会出现一些选项供用户进行选择添加什么内容，这取决于是什么产品。</p>\n<p><img src=\"@source/design/navigation/assets/plus-button.jpg\" alt=\"加号按钮\"></p>\n<p>上面这个例子就是用户在点击加号按钮后出现了可以选择添加的内容(图片，视频，文字)，在选择了之后才会弹出添加内容的窗口。尽管这个操作可能增加一些额外的交互动作，但因为给予了用户选择空间，所以还是对用户很友好的一种设计。</p>\n<h3 id=\"分享按钮-share-button\" tabindex=\"-1\"> 分享按钮(Share Button)</h3>\n<p>分享按钮顾名思义就是能让用户把内容分享到他们的社交平台账号上。大多数情况下，这个按钮都是用社交平台的 Logo 作为视觉形象，这样非常易于识别和认知。</p>\n<div><p>提示</p>\n<p>比如 in 东师小程序大部分页面都会在右下角展示分享浮窗</p>\n</div>\n<h2 id=\"开关-switch\" tabindex=\"-1\"> 开关(Switch)</h2>\n<p>同样，这也是一个用户非常好理解的元素，在界面中用得也非常多。因为它很好地模仿了现实世界里人们熟悉的开关概念。关于这个元素的设计，特别要注意的是开和关的状态在视觉上要差别非常明显。这样能避免用户花时间去研究怎样是开怎样是关。很多种的形式对比或者切换动画都可以解决这个问题，从而设计出很好的用户体验。</p>\n<p><img src=\"@source/design/navigation/assets/switch.gif\" alt=\"开关案例\"></p>\n<p>这个案例是来自一款闹钟应用 Toonie。动画效果让交互变得更流畅和自然，同时整个控件颜色的改变和滑动元素形态的变化让用户能够轻易地识别出开关的状态。如果您想了解整个 App 的案例研究，可以到来源查看。</p>\n<div><p>提示</p>\n<p>我的主题 vuepress-theme-hope 也有一款很棒的主题模式切换开关，需将 <code>darkmode</code> 设置为 <code>'switch'</code> 即可查看</p>\n</div>\n<h2 id=\"选择器-picker\" tabindex=\"-1\"> 选择器(Picker)</h2>\n<p>也很好理解，就是让用户在一些选项里选出目标选项。通常包含一个可滑动的列表，上面是一列数值，比如小时，分钟，日期，度量，币种等等。通过滑动列表，用户可以选定想要的数值。这个元素广泛地应用在有时间设定这个功能的界面设计上。</p>\n<p><img src=\"@source/design/navigation/assets/picker.gif\" alt=\"选择器案例\"></p>\n<h2 id=\"复选框-checkbox\" tabindex=\"-1\"> 复选框(Checkbox)</h2>\n<p>复选框是可以用来同时标记多个特定的内容。同样的，也是借用了我们在现实世界里熟悉的概念。我们在考试的时候，或者填调查问卷的时候会在选项前的小方框里涂上颜色作为选中的标记。和开关一样，复选框同样用得很多，主要在设置页面设计里。不过，复选框还有另外一个用得比较多的地方，那就是含有任务管理，待办事项，时间记录等类似功能的 App 或者网页。</p>\n<p><img src=\"@source/design/navigation/assets/checkbox.jpg\" alt=\"复选框\"></p>\n<p>上面这个是一个待办事项 App 的概念设计。用户点击复选框后，表示这个内容已经完成。字体变粗的同时颜色发生了改变，这样就非常明显地把这个已完成的任务和其他未完成的任务区分开来。</p>\n<h2 id=\"图标-icons\" tabindex=\"-1\"> 图标(Icons)</h2>\n<p>图标可以定义为一个象征着某个概念或物体的视觉形象，有着加强与受众沟通的目的。会和文字结合一起使用，将想要传达给受众的信息表现出来。在界面设计中，图标通常是象形符号或表意文字，对可用性和成功的人机交互有重要意义 。</p>\n<p>毫无疑问，图标的其中一个重要作用是可以有效地替代文字描述。因为比起文字，用户对图片的理解速度更快，所以这个特点能极大提升用户体验，增强产品的导航和对用户的引导。但是，需要注意，即使是轻微的歧义或者误解都会导致糟糕的用户体验。所以在设计图标的时候要做必要的测试，根据目标用户平衡好文字和图标的使用。最有效的方式是同时使用图标和文字，这样大部分用户都不会有问题。电商 APP 或者网站最常使用这样的形式来给用户足够的信息，让他们能轻松快速地浏览。</p>\n<hr>\n<p>根据图标的功能，我们可以将它们分为一下几类:</p>\n<h3 id=\"交互式图标-interactive-icons\" tabindex=\"-1\"> 交互式图标(interactive icons)</h3>\n<p>这类图标具备交互功能。他们是可点击的，能回应用户的要求，触发图标代表的动作。这种图标告知用户按钮、控件或者其他界面交互元素的功能或者特点。在大多数情况下，这类图标的意义明确，不需要文字辅助说明。</p>\n<h3 id=\"说明性图标-clarifying-icons\" tabindex=\"-1\"> 说明性图标(clarifying icons)</h3>\n<p>起到说明作用的图标，设计师用它来表示某一个特点或者内容的种类。它有时候不属于界面布局的元素或者并不具备直接的交互功能。经常和文字结合使用。</p>\n<h3 id=\"娱乐性和装饰性图标-entertaining-and-decorative-icons\" tabindex=\"-1\"> 娱乐性和装饰性图标(entertaining and decorative icons)</h3>\n<p>这类图标注重抓人眼球的视觉效果并非功能，通常用在节日或者特别款的场景。他们能有效地吸引用户的注意力，增强视觉冲击力。</p>\n<p>复活节和春天主题的图标:</p>\n<h3 id=\"app-图标-app-icons\" tabindex=\"-1\"> APP 图标(app icons)</h3>\n<p>在各个平台上可交互的品牌标志，展示品牌和产品的形象。最常见的就是我们手机界面上每一个 App 的图标，上面通常是品牌和产品的 Logo。</p>\n<h3 id=\"网页图标-favicons\" tabindex=\"-1\"> 网页图标(favicons)</h3>\n<p>就是我们经常在网址栏或者书签里看到的 URL 前面的那个小图标，也是代表着产品或者品牌的形象。能让用户在浏览网页时给他们快速的视觉提示。</p>\n<h2 id=\"搜索区域-search-field\" tabindex=\"-1\"> 搜索区域(Search Field)</h2>\n<p>搜索区域又常常被称作搜索框(search box)或者搜索条(search bar)，代表着用户可以在这个区域内输入想要搜索的内容。它是那些有着很多内容的网站或 APP 的核心导航元素，像博客，电商，新闻等产品。设计得好的搜索框能让用户轻松地找到想要的信息。因为它能帮助用户省去很多时间和精力，所以它是一个对用户特别友好的界面元素。</p>\n<p>它的设计形式有很多种，可以是标签的形态，也可以是引导输入的一条线或者简单的一个搜索图标。大多数情况下搜索框的图标是一个放大镜的样式。基本上所有的用户都懂得这个图标的含义，所以能实现非常直观的导航设计。想要在这个图标上做文章的话，要好好测试一下，因为改得不好的话会严重影响交互和界面的可用性。搜索框还可以加入提供候选项的下拉菜单或者自动填补内容的功能。</p>\n<p><img src=\"@source/design/navigation/assets/search.gif\" alt=\"十分有设计感的交互式设计\"></p>\n<p>另外需要注意的一点是搜索框控件在界面中的位置。在网页设计中，搜索框经常出现在网页的顶部。这是一个很恰当的设计，因为通常网页的顶部区域具有很高的可见性，用户打开网页就看到了，不需要再花时间去找到这个控件。举个反面例子，如果一个电商网站因为搜索框的设计有问题，导致用户没办法快速方便地找到想买的东西，网站销售表现会受到极大的影响。因为现在很多网站都将搜索框放在网页的顶部，所以用户也养成了在那里找到搜索框的习惯。</p>\n<p>至于 App 界面的话，要视具体情况而定，设计师可能面临更多的限制。如果是一个有着大量内容的 APP，而且搜索是核心功能之一的话，那么一般放在一个显眼的标签条(tab bar)上。如果搜索并不是核心功能，那么可以把它藏到菜单里或者只在需要的用到的地方显示或者时刻显示出来。</p>\n<h2 id=\"标签-tag\" tabindex=\"-1\"> 标签(Tag)</h2>\n<p>标签是一个标有关键词的可交互元素。标签其实是给用户提供快速通道的元数据，用户可以通过它快速导航到与关键词相关的所有内容。除了网页或者 App 本身带有的标签，在很多情况下用户也可以自己创建标签。</p>\n<p>标签这个界面元素被广泛地应用在用户原创内容平台(UGC)的界面设计里。当用户上传图片、状态到社交网络的时候，可以加上关键词作为标签。通过点击某个标签，能切换到带着这个标签的所有内容的页面。标签是友好的搜索引擎优化(SEO-friendly)技巧，能提高用户搜索内容的成功率。</p>\n<p>对于一些内容站点来说，当用户想要下载图片时，可以输入描述图片的关键词作为标签。通过这样的形式帮助用户有效地找到想要的图片。我们还可以注意到，输入框内加入了引导用户进行操作的说明，这样更进一步地提高了产品的可用性。设计的细节真的很重要。总而言之，标签是一种用户可以自行创造的导航元素，拉近了界面和目标用户之间的距离。</p>\n<h2 id=\"总结\" tabindex=\"-1\"> 总结</h2>\n<p>全面地设计好整个界面的导航不是一件容易的事，需要一些心理学、交互模式、用户测试的基础知识，还需要在项目的早期思考清楚网站或者 App 的信息架构。但是做好这一点的话，能够让您的产品很好地帮助用户解决他们的问题，给优秀的用户体验打下坚实的基础，让他们对您的产品产生越来越大的粘性。</p>\n",
      "date_published": "2020-09-15T00:00:00.000Z",
      "date_modified": "2022-08-20T08:54:00.000Z",
      "authors": [],
      "tags": [
        "设计"
      ]
    },
    {
      "title": "导航栏设计技巧",
      "url": "https://github.com/MisterChen9527/design/navigation/navbar-design.html",
      "id": "https://github.com/MisterChen9527/design/navigation/navbar-design.html",
      "content_html": "<p>评判导航菜单的设计好坏有多种不同的维度，由于它太过常用，它的好坏并没有得到更多重视。实际上，导航作为网站设计的一个基础组成部分，对于可用性的要求并不低。以下是一些常见的设计技巧。</p>\n<h2 id=\"超大菜单栏\" tabindex=\"-1\"> 超大菜单栏</h2>\n<p><img src=\"@source/design/navigation/assets/big-navbar.jpg\" alt=\"超大菜单栏\"></p>\n<p>即使许多设计师不喜欢这样的设计，而且从美学的角度上它也是反智的，但是对于许多客户而言，它依然是一个客户反响很好的设计方案。但是这样的设计对于用户可能还是有一些困扰，并且没有提供真正有用的功能。</p>\n<p>只有极少数的电商类网站能够真正适合使用超大导航栏的，因为他们确实需要足够的空间来承载大量的导航栏目。不过过大的导航栏可能还是存在一些可用性问题的。</p>\n<p>通常，超大的导航栏存在的主要原因在于，导航栏项目很多难以缩减。这真是一个艰难的决定。对于网站的运营者而言需要仔细考量这件事情，或者通过搜集来的数据来做设计决策的论据。对于特定的内容，许多用户还是倾向于使用搜索来获取，这是毋庸置疑的。</p>\n<h2 id=\"加入显眼的搜索框\" tabindex=\"-1\"> 加入显眼的搜索框</h2>\n<p><img src=\"@source/design/navigation/assets/navbar-with-search.jpg\" alt=\"加入显眼的搜索框\"></p>\n<p>用户常常使用搜索来筛选信息，更快更直接地获取重要的信息，所以，搜索框应该突出展示。它应该出现在每个页面上，应该和主导航栏一起存在，应该够大也易于访问。</p>\n<p>强大的搜索引擎是让用户留存的重要影响因素，当搜索引擎的可用性较差的时候，网站的可访问性会受到影响。网站的页面一次展示的内容是相当有限的，一旦用户在页面中无法直接获取想要的内容，下一步就是考虑借助搜索引擎来达成目标了。</p>\n<p>用户对于搜索的需求是刚性的，不要试图打破这种客观存在的规律，尽量让搜索融入到主导航当中来吧。(确保输入框足够大，可以输入，并且足以一次显示常见的搜索内容)</p>\n<h2 id=\"限制导航内条目数量\" tabindex=\"-1\"> 限制导航内条目数量</h2>\n<p>作为设计师，您需要预测用户经常访问的内容，将最重要、最常用到的条目置于导航栏当中。值得一提的是，几乎每个网站的导航中都会包含搜索、关于我们、首页，而电商类网站则通常会包含购物车、购买的按钮。</p>\n<p>但是无论如何，永远将最关键、最重要的导航类目让用户看到，才是导航所应该做到的事情，换句话来说，就是关键内容驱动导航分类。</p>\n<h2 id=\"更聪明的导航机制\" tabindex=\"-1\"> 更聪明的导航机制</h2>\n<p>好的导航设计，能让用户能在页面和页面之间合理快速切换，网站不同的内容和功能之间是有一定的自然逻辑的，这个自然逻辑可以作为导航设计的一个重要参考。</p>\n<p>在这个用户体验高度个性化的时代，网页导航的玩法可以更加多样。以 Amazon 为例，当您登录了之后，会发现导航开始围绕着您的信息进行了调整，导航栏从通用的条目变为更贴近您的个人情况的样式，其中包括最近的购买记录，信用额度和 Amazon 的服务信息等。</p>\n<h2 id=\"正确地排布导航内的条目\" tabindex=\"-1\"> 正确地排布导航内的条目</h2>\n<p>导航内的元素的排布顺序和条目内容同样重要。导航栏两头的条目是最引人注意的，并且也通常是用户点击最多的，所以作为设计者，您需要特别注意这些条目的设计。</p>\n<p>对于这一点，还有不少科学研究和理论支持。比如，序列位置效应指的就是人会更容易记住列表的开头和结尾的条目。新近效应说的是用户更容易记住最新看到的条目，而首位效应说的是，相比于列表中间的内容，用户更容易记住列表开头的几个条目。</p>\n<h2 id=\"长滚动页面上使用悬浮导航\" tabindex=\"-1\"> 长滚动页面上使用悬浮导航</h2>\n<p>对于长滚动页面而言，导航设计是否可靠是一件颇为重要的事情，无论导航是在顶部、侧边栏还是在底部，它最好能够悬浮置顶，不论用户滚动到哪个地方都时刻存在于界面上。让用户尽量轻松自然地同您的网站进行交互，而不需要费力。交互越是方便，用户便越是会在您的网站中四处探索，自然而然的，用户在网站中停留的时间就越长。</p>\n<div><p>提示</p>\n<p>比如我博客的导航栏就是一个悬浮导航，确保用户可以随时接触到菜单(移动端)和导航栏与搜索框(PC 端)。</p>\n</div>\n<h2 id=\"不要隐藏导航\" tabindex=\"-1\"> 不要隐藏导航</h2>\n<p>超小的汉堡图标，隐藏在页脚、不显眼的链接，或者在长滚动页面中时隐时现的悬浮菜单，都会让用户觉得难以掌控。这些“躲闪”的导航元素让用户难以与之进行交互。相反，时刻存在的导航让用户会更加安心，让用户时刻都拥有离开、跳转的安全通道。</p>\n<h2 id=\"使用描述性的标签文本\" tabindex=\"-1\"> 使用描述性的标签文本</h2>\n<p>从导航标签到图标，UI 界面中每个交互元素都应该明确的指引用户，告诉他们点击之后会发生什么。像放大镜、购物车这样的拥有普遍认知的图标，应该尽量多用。</p>\n<p>导航栏中每个条目都会有个文本标签，它们会告诉用户这个链接中所包含的内容。这个时候要尽量注意不要使用太过宽泛的描述，比如“服务”或者“产品”，尽量用更精准的描述。</p>\n<h2 id=\"尝试全页面导航\" tabindex=\"-1\"> 尝试全页面导航</h2>\n<p><img src=\"@source/design/navigation/assets/full-navigate.jpg\" alt=\"全页面导航\"></p>\n<p>导航这件事玩法有很多，如果您真的想做的更醒目一些，不妨采用全页面式的导航，绝对不会让用户错过。</p>\n<p>对于作品集和相对较小的实验性网站，这种非常规的设计有时候能出奇效。</p>\n<h2 id=\"垂直导航\" tabindex=\"-1\"> 垂直导航</h2>\n<p><img src=\"@source/design/navigation/assets/vertical-navbar.jpg\" alt=\"垂直导航\"></p>\n<p>垂直导航设计也是目前越来越流行的设计之一。最常见的是垂直导航，是侧边栏导航，它和许多软件的 UI 设计不谋而合。</p>\n<p>侧边栏导航对于如今的许多网站是个合理的选择，尤其是诸如长滚动式的页面。侧边栏导航通常为常驻式的，让用户可以随时定位，快速跳转，并且其中所能承载的元素相对比顶部导航更多。垂直导航尤其要注意条目之间的空间间隔。</p>\n",
      "date_published": "2020-09-15T00:00:00.000Z",
      "date_modified": "2022-08-20T08:54:00.000Z",
      "authors": [],
      "tags": [
        "设计"
      ]
    },
    {
      "title": "导航栏设计",
      "url": "https://github.com/MisterChen9527/design/navigation/navbar.html",
      "id": "https://github.com/MisterChen9527/design/navigation/navbar.html",
      "content_html": "<p>其实网页或者 App 中的导航(Navigation)这个概念远不止我们熟悉的导航栏，而是一个更加广的交互概念: 引导用户和产品进行有效的交互，实现用户的目标。</p>\n<h2 id=\"导航栏究竟在哪里\" tabindex=\"-1\"> 导航栏究竟在哪里</h2>\n<p>导航栏 Navigation Bar，也简称为 Navbar。一定会有不少刚入门的 UI 新人，在诸多的 Bar 控件中，难以区分它所指代的区域。</p>\n<p>在 iOS 上，导航栏是指显示在应用程序顶部，位于状态栏下方的容器区域，层级应高于当前页面内容。</p>\n<p>在安卓上，Google 公司在 Material Design 中也赋予了它同样的定义，但是却给了它另一个名称，顶部应用栏(Top App Bar)。</p>\n<p><img src=\"@source/design/navigation/assets/navbar-name.jpg\" alt=\"iOS 与安卓的规范与命名区别\"></p>\n<p>请务必要记住: 导航栏是用于构架当前屏幕的内容，阐述当前屏幕的状态，并且起到连接父子级页面层次结构的作用。所以回到开头的小故事，为什么标签栏不能叫做底部导航，因为标签栏是构架了多个屏幕之间平级页面的内容切换，和「导航」的定义没有关系。</p>\n<h2 id=\"规范里告诉我们该怎么做-vs-实际项目我们该怎么做\" tabindex=\"-1\"> 规范里告诉我们该怎么做 vs 实际项目我们该怎么做</h2>\n<p>一个基本的导航栏容器一般承载的信息可能会有: 标题、导航按钮、内容控件按钮、其他控件(比如搜索栏、分页标签或分页控件等)，千万别忘了还有分割线。(比如微信的导航栏)</p>\n<h3 id=\"导航栏标题\" tabindex=\"-1\"> 导航栏标题</h3>\n<p>时间倒退回 2017 年以前，这时候的移动端规范下的导航栏还是循规蹈矩的，样式单一。但随着 iPhone X 等一系列全面屏手机相继问世后，移动设备在屏幕高度上有了进一步的扩展，界面设计在一屏内的发挥空间也随之增加。iOS11 发布后，大标题导航栏设计风格兴起，随后被引入平台规范。</p>\n<p>于是现在 iOS 与 Material Design 在导航栏上也都定义了两种导航栏标题规范，常规标题与大标题。</p>\n<p>常规标题是指在高度为 88px(iOS@2x 下)的导航容器中，居中放置一个当前页面的标题。标题字号一般为 34px-38px(34px 为 iOS 标准规范，但实际项目中可以尽量在不小于 34px 标准的情况下根据设计需求确定)。</p>\n<p><img src=\"@source/design/navigation/assets/ios-navbar.jpg\" alt=\"常规导航不同标题字号的案例及视觉效果\"></p>\n<p>大标题是将导航栏高增加到 192px(iOS@2x)，保留高度为 88px 的导航容器来承载内容控件按钮，将标题下坠居左。iOS 的标准规范定义大标题的字号为 68px。但由于英文有大小写区分，在视觉上有一定的层次表现，而中文因为缺少一定的层次结构，并且相同字号的中文视觉大小大于英文，所以大多数时候我们在进行大标题设计时，会适当缩小，一般为 56px-64px 居多。</p>\n<p><img src=\"@source/design/navigation/assets/ios-navbar-big.jpg\" alt=\"大标题不同标题字号的案例及视觉效果\"></p>\n<p>大标题导航栏的优点毋庸置疑，页面留白更多，呼吸感更强，大气现代、格调更高，因为页面标题巨大，能够帮助用户快速确认当前所处位置。采用统一的大标题，让页面布局风格快速统一。但缺点也显而易见，因为增加了导航栏的高度，导致屏幕利用率降低，一些通过广告变现或更加注重一屏内内容呈现的应用便中和了常规导航与大标题导航的优缺点，进行了风格改进。</p>\n<p><img src=\"@source/design/navigation/assets/navbar-big-improve.jpg\" alt=\"改进的大标题案例\"></p>\n<p>那我们如何在常规标题和大标题之间抉择呢? 这可不单单是设计风格的问题，还受产品定位与功能的影响。苹果的设计师在 Apple Music 中实验并验证了一条结论——在内容非常丰富、层级结构较深的产品当中，大标题能够帮用户快速确认自己的位置。</p>\n<p>所以我理解的适合使用大标题风格的产品一定是: 突出内容呈现而不是功能繁琐的；产品定位更偏向于现代或文艺艺术的；需要快速统一界面风格的。而层级结构需不需要很深，这并不一定，我反而觉得功能越单一、产品体量级越轻的应用，越适合大标题。</p>\n<p>所以如此看来，国内使用大标题成功的案例就为数不多了，这可能与中文字体还有国内 app 产品功能都比较繁琐的原因有关，真正做到了使用大标题快速帮助用户确认自己位置，并且结合了产品特性与风格的，我认为人人都是产品经理的移动端在这方面做得非常棒。</p>\n<h3 id=\"导航按钮及内容控件按钮\" tabindex=\"-1\"> 导航按钮及内容控件按钮</h3>\n<p>iOS 规定导航按钮位置仅能用于放置返回按钮，可以添加一个层级的面包屑，帮助用户有效地明确当前页面层级；Material Design 中，不仅可以放置返回按钮，还另有作用，菜单图标-用于打开导航抽屉或者关闭图标-关闭工具栏。</p>\n<p><img src=\"@source/design/navigation/assets/ios-nav-back.jpg\" alt=\"iOS 与安卓的导航按钮区域区别\"></p>\n<p><img src=\"@source/design/navigation/assets/android-nav-back.gif\" alt=\"iOS 与安卓的导航按钮区域区别\"></p>\n<p>这一点与 iOS 的定义有着天壤之别，iOS 非常明确地赋予了工具栏的定义，并且将导航栏和工具栏(Toolbars)彻底地分离开，典型案例就是 Safari。</p>\n<p><img src=\"@source/design/navigation/assets/safari.jpg\" alt=\"iOS 明确地将导航栏与工具栏分离开\"></p>\n<p>在内容控件上 iOS 与 Material Design 也大相径庭，Material Design 不去限制您的内容控件多少，因为它提供了溢出菜单，并可以根据屏宽的变化，自适应释出和收纳溢出菜单中的控件。</p>\n<p><img src=\"@source/design/navigation/assets/android-size-adjust.gif\" alt=\"安卓动态调整\"></p>\n<p>而 iOS 则规定我们，要给内容控件按钮足够多的空间，必要的时候，隐藏导航栏标题也未尝不可。</p>\n<p><img src=\"@source/design/navigation/assets/ios-nav-space.jpg\" alt=\"iOS 导航栏空间\"></p>\n<p>那么真实的项目中，我们往往为了快速落地，会存在一稿适配双平台的情况。这时候我们应该遵从哪一个平台的规范呢? 答案是: 许多大厂的做法已经向我们验证，规范不分家。</p>\n<p>在 iOS 诸多的应用中溢出菜单早已普及，尽管这是 Material Design 提出的设计理念。</p>\n<p><img src=\"@source/design/navigation/assets/ios-callout.jpg\" alt=\"Material Design的溢出菜单也被运用在iOS端\"></p>\n<p>虽然国内遵从 Material Design 进行 Android 应用设计的情况相对较少，但它提供的设计理念与方案却并不局限在安卓平台。</p>\n<h3 id=\"分割线\" tabindex=\"-1\"> 分割线</h3>\n<p>分割线只是一种体现形式，我想要表达的是，别忘记区分导航栏与内容界面的视觉层级关系。Matetial Design 提醒我们，顶部应用栏可以与内容位于同一高度，但滚动时，请增加导航栏的视觉高度，让内容在其后方滚动。而 iOS 则默认采用了背景模糊的方式区分了导航栏与内容区域的层级关系。</p>\n<p><img src=\"@source/design/navigation/assets/android-shadow.gif\" alt=\"区分导航栏与内容区域的层级关系\"></p>\n<p><img src=\"@source/design/navigation/assets/ios-divide.jpg\" alt=\"区分导航栏与内容区域的层级关系\"></p>\n<p>缺少视觉分割会让用户分不清导航栏与内容界面，它们看起来会更像一个平级。对用户视觉区分内容主次其实是极不友好的。</p>\n<h3 id=\"其他控件\" tabindex=\"-1\"> 其他控件</h3>\n<p>关于其他控件，iOS 只在规范中提及到了分页控件。苹果设计师考虑到部分场景在当前页面中还存在信息层级结构划分，此时建议可以在导航栏中使用分段控件。</p>\n<p>但国内的应用程序早已将导航栏容器的作用发挥到极致，基于导航栏层级始终高于内容区域的特性，我们通常可以将分段控件、分页标签、搜索栏等等用户可能随时使用的工具放在导航栏中。</p>\n<p><img src=\"@source/design/navigation/assets/nav-control.jpg\" alt=\"导航栏通常会承载的其他控件\"></p>\n<h2 id=\"总结\" tabindex=\"-1\"> 总结</h2>\n<p>导航栏是几乎每一个界面都必定存在的控件，正因为无法轻易删减，逃不掉就必须用好它，不然很容易沦为页面的减分项。</p>\n<p>设计好导航栏不仅仅是视觉上的工作，表现的方式、承载的按钮与组件、滚屏时的组合操作还能给用户带来极大的体验增益。</p>\n",
      "date_published": "2020-09-15T00:00:00.000Z",
      "date_modified": "2022-08-20T08:54:00.000Z",
      "authors": [],
      "tags": [
        "设计"
      ]
    },
    {
      "title": "侧边栏导航",
      "url": "https://github.com/MisterChen9527/design/navigation/sidebar-navigate.html",
      "id": "https://github.com/MisterChen9527/design/navigation/sidebar-navigate.html",
      "content_html": "<p>厌倦了传统顶部导航的设计师，越来越偏爱侧边栏导航了。这种常见于页面左侧的侧边栏设计，已经成了许多独树一帜的设计师的选择了。</p>\n<h2 id=\"无处不在的侧边栏导航\" tabindex=\"-1\"> 无处不在的侧边栏导航</h2>\n<p>侧边栏导航和菜单设计的演变有着密不可分的关系。响应式设计的流行使得向移动端偏移的网页设计，不得不采用菜单栏来替代传统的导航模式，其直接的影响就是催生了汉堡图标。</p>\n<p><img src=\"@source/design/navigation/assets/sidebar-navigate1.jpg\" alt=\"侧边栏导航\"></p>\n<p>随着汉堡图标的流行，弹出式的菜单也越发的常见。其中有些菜单是完全开放式的，而有的菜单则带着下拉框，还有一部分直接是弹出的菜单界面。而为了兼容大量的移动端界面，下拉和弹出式的菜单大多采用的是纵向布局——而这和侧边栏的设计，是如此的相似。换句话来说，这种垂直的导航就是一种弹出式的侧边栏导航。</p>\n<p>目前，这种左侧侧边栏导航的设计已经成为一种持续迭代中的设计趋势了。现在我们看到的侧边栏设计，常常使用单一的纯色打底，包含较少(但是重要或常用的)选项，导航栏顶端通常会包含有品牌或者网站 LOGO，文字链接，以及带有小图标的社交媒体帐号的链接。</p>\n<p>想要这种侧边栏设计能够最大化的发挥作用，诀窍在于控制好侧边栏本身和右侧网站内容的对比度，它要包含足够清晰可见的导航条目，还要能在移动端上良好地运作。</p>\n<p>还有一点值得一提: 不要因为屏幕侧边够长，就试图用链接和内容将侧边栏填满。留白是完全可以接受的，在简约之风大行其道的今天，尽量只保留必须的内容，让留白来凸显它们，才是合乎道理又符合趋势的设计。今天的文章中的许多优质案例，都遵循着这样的设计逻辑。</p>\n<h2 id=\"侧边栏导航的优点\" tabindex=\"-1\"> 侧边栏导航的优点</h2>\n<p>侧边栏导航的美学特征是毋庸置疑的。它在互联网存在的早期就已经存在，在软件的 GUI 设计中常常可以看到，但是在今天它仍然以一种时尚而前卫的姿态出现。</p>\n<p><img src=\"@source/design/navigation/assets/sidebar-navigate2.jpg\" alt=\"侧边栏导航示意图\"></p>\n<div><p>侧边栏导航的优点</p>\n<ul>\n<li>侧边栏导航通常位于左侧，它位于 F 式布局的最左侧，作为信息主干，也符合用户的浏览习惯</li>\n<li>侧边栏导航不会像汉堡菜单一样一开始就隐藏其中的条目</li>\n<li>侧边栏中的条目优先级基本一致</li>\n<li>当间距足够的时候，侧边栏中的条目会非常的一目了然</li>\n<li>今天的侧边栏通常会留有足够的空间，让后续的条目能够加入进去</li>\n<li>侧边栏让右侧的画板形状尺寸不尽相同，设计师可以以非常规的方式来展现视频和图片，创造更独特的视觉体验</li>\n<li>侧边栏导航以更加干净优雅的方式呈现更多的链接</li>\n</ul>\n</div>\n<h2 id=\"侧边栏导航的缺点\" tabindex=\"-1\"> 侧边栏导航的缺点</h2>\n<p>不喜欢侧边栏导航的人也很多，有些争论是关于导航栏放在右侧会不会更好，还有人则觉得侧边栏导航本身就是个麻烦，一方面让用户面对更复杂的布局，另一方面还增加了开发的难度。</p>\n<p><img src=\"@source/design/navigation/assets/sidebar-navigate3.jpg\" alt=\"侧边栏导航示意图\"></p>\n<div><p>使用垂直导航存在的问题</p>\n<ul>\n<li>垂直式的导航在响应式布局当中很难正常工作</li>\n<li>导航中的词汇必须足够简短，否则导航栏会设计的很宽，或者部分内容无法显示</li>\n<li>垂直导航所占据的空间，可能会挤压其他更有价值的内容</li>\n<li>在同等内容量之下，侧边栏导航会让用户滚动页面的时间更长</li>\n<li>顶部导航通常只能放四五个链接，而侧边栏导航无疑能放更多，这可能会促使部分设计师，在导航栏中塞入过多导航条目</li>\n<li>绝大多数用户是右撇子，这些用户需要横快整个屏幕去点击导航</li>\n<li>垂直导航通常在单页式页面上非常好用，但是其他类型的网页上则没有想象中那么好使</li>\n</ul>\n</div>\n<h2 id=\"侧边栏导航是否好用\" tabindex=\"-1\"> 侧边栏导航是否好用</h2>\n<p><img src=\"@source/design/navigation/assets/sidebar-navigate4.jpg\" alt=\"侧边栏导航示意图\"></p>\n<p>说真的，讨论很多，结论并不那么明朗。</p>\n<p>作为一种设计趋势，侧边栏导航是引人注意的，作为导航栏，它常驻式的设计，让它的功能性更强。如果您的导航是用户流程中非常重要的存在，那么侧边栏导航是个不错的选择。</p>\n<p>总而言之，这种导航设计对于较少的导航内容的小型网站而言，颇为有用，尤其是对于产品展示型的网站而言。</p>\n<h2 id=\"其他的导航模式\" tabindex=\"-1\"> 其他的导航模式</h2>\n<p>非常规的导航模式是打破了旧有的常规导航模式的有趣尝试，除了侧边栏导航之外，还有一些其他的有趣的导航设计。</p>\n<p>当然，非常规的导航设计最主要的问题在于，用户不熟悉，容易混淆，迷惑。对于小型站点，适当的尝试还好，对于复杂的大型网站，这样的尝试就有点得不偿失了。</p>\n<p>在这里另外介绍两种有趣的导航设计。Aurora 所采用的是隐藏式的导航，点击 LOGO 旁边的菜单按钮能够显示，而 AndCulture 则直接将顶部导航旋转了 90 度直接放到侧面。</p>\n<p><img src=\"@source/design/navigation/assets/sidebar-navigate5.gif\" alt=\"侧边栏导航示意图\"></p>\n<p><img src=\"@source/design/navigation/assets/sidebar-navigate6.jpg\" alt=\"侧边栏导航示意图\"></p>\n<p>两种设计虽然都有人让人意想不到，但是都在各自的网站中良好的运行。当然，不管您要做多么奇怪的尝试，在真正决定投入使用之前，尽量多做用户测试，确保它们是有效的。</p>\n",
      "date_published": "2020-09-15T00:00:00.000Z",
      "date_modified": "2022-08-20T08:54:00.000Z",
      "authors": [],
      "tags": [
        "设计"
      ]
    },
    {
      "title": "标签导航设计技巧",
      "url": "https://github.com/MisterChen9527/design/navigation/tabbar-design.html",
      "id": "https://github.com/MisterChen9527/design/navigation/tabbar-design.html",
      "content_html": "<h2 id=\"底部导航栏图标重要性及维度\" tabindex=\"-1\"> 底部导航栏图标重要性及维度</h2>\n<h3 id=\"重要性\" tabindex=\"-1\"> 重要性</h3>\n<p>底部导航栏的图标是路牌，承担着指路的作用，给用户指明进入产品后可以分别通往什么页面。早期的底部导航栏是单一的指路功能，经过多年的交互设计迭代后，附加了「信息展示」和「引导操作」的作用，这点会在下文中详细阐述。</p>\n<h3 id=\"三个重要评估维度\" tabindex=\"-1\"> 三个重要评估维度</h3>\n<h4 id=\"品牌调性\" tabindex=\"-1\"> 品牌调性</h4>\n<p>品牌调性决定了图标的体量感、差异化和创意延展。怎样评估图标设计能够体现出品牌调性呢? 最简单直接的方法: 截屏首页，不看顶部栏，仅从底部导航栏能看出来这是什么产品，就算成功体现了品牌调性。</p>\n<p><img src=\"@source/design/navigation/assets/tabbar-style.jpg\" alt=\"品牌调性\"></p>\n<h4 id=\"识别度\" tabindex=\"-1\"> 识别度</h4>\n<p>识别度决定了用户辨识其它页面功能的速度。高识别度的图标能协助用户辨识，低识别度的图标会阻碍用户辨识。在选择做这部分图标的时候，一定要考虑识别度的问题，进行创新要建立在高识别度的基础上。</p>\n<h4 id=\"美观\" tabindex=\"-1\"> 美观</h4>\n<p>导航栏图标美观的要义是: 统一、精致。统一不代表绝对统一，精致不代表过于精细。要做到美观，可以遵循以下几点: 大小统一和谐、线条粗细一致、圆角视觉统一、内容繁简平衡。</p>\n<p>将三个维度按重要程度来排序，是品牌调性&gt;识别度&gt;美观。有的设计师会选择以美观度作为优先标准。但站在产品的角度来说，应该以体现品牌调性和识别度为重要标准，在这基础上再进行美观设计。下图中，新华书店 APP 的底部导航栏图标略显年代感，图标细节表现不一显得不够统一和精致，然而用户还是能够根据图标一眼区分各个导航入口的功能。它们可能不是设计师眼中好看的图标，但它们是用户眼中好用的图标。</p>\n<p><img src=\"@source/design/navigation/assets/xinhua.jpg\" alt=\"新华书店 APP\"></p>\n<h2 id=\"底部导航入口的数量\" tabindex=\"-1\"> 底部导航入口的数量</h2>\n<p>底部导航入口一般在 3-5 个，最常见的是 4-5 个。这个数量由什么决定呢?</p>\n<h3 id=\"最高数值由认知心理学决定\" tabindex=\"-1\"> 最高数值由认知心理学决定</h3>\n<div><p>相关信息</p>\n<p>在认知心理学理论中，人的记忆系统由三个储存器组成: 感觉寄存器，短时记忆和长时记忆。来自环境的刺激经过过滤首先进入感觉寄存器，通过选择性直觉，信息被临时传入短时记忆(STM)。它是一个过渡性的记忆缓冲期，容量有限，只能记录 7+-2 个信息组块，且只能保持大约 15-30 秒。</p>\n</div>\n<p>在使用 APP 的时候，底部导航栏使用到的是人记忆系统中的感觉寄存器和短时记忆。考虑到 APP 面对的人群非常广，短时记忆容量不一，选择了 7-2(也就是 5)作为底部导航入口的最高数值。</p>\n<h3 id=\"具体数值由产品的框架决定\" tabindex=\"-1\"> 具体数值由产品的框架决定</h3>\n<p>产品经理会通过项目背景和用户调研，决定产品的功能结构。而功能结构图划分的类别决定了底部导航入口数量。有的产品功能非常单一，结构也单一，三个导航入口已经能够满足需求；有的产品功能复杂，则需要更多的导航入口，用以划分 APP 功能，帮助用户快速识别。</p>\n<p><img src=\"@source/design/navigation/assets/tabbar-needs.jpg\" alt=\"产品需求\"></p>\n<h2 id=\"底部导航栏模式\" tabindex=\"-1\"> 底部导航栏模式</h2>\n<p>底部导航栏有权重平分、强调信息、引导操作这三种模式。本次深度分析采用了 30 个产品作为对象进行研究，其中大部分为知名社交电商类产品。因为这类型的产品比较多，迭代完善，可参考性强。</p>\n<h3 id=\"权重平分\" tabindex=\"-1\"> 权重平分</h3>\n<p>当产品的功能结构权重比较平均，不希望突出其中某个结构时，一般采用权重平分的模式，即每个底部入口的分量都是平均的。常规产品会采用这样的形式。</p>\n<p><img src=\"@source/design/navigation/assets/tabbar-same-weight.jpg\" alt=\"权重平分\"></p>\n<h3 id=\"强调信息\" tabindex=\"-1\"> 强调信息</h3>\n<p>当产品需要强调某些信息引起用户注意或同一个按钮承担两个功能时，设计便可以选择在某个入口添加明显的信息指示或功能。增加功能的底部导航入口不一定是首页，也可以是其它入口。</p>\n<div><p>相关信息</p>\n<p>严选的首页按钮承担着「回到顶部/快速定位推荐模块/品牌展示」的功能；淘宝、飞猪的首页按钮承担着「回到顶部/品牌展示」的功能；微博的视频按钮承担着「视频/关注的人更新内容提示」的功能。</p>\n</div>\n<p><img src=\"@source/design/navigation/assets/tabbar-yanxuan.jpg\" alt=\"强调信息\"></p>\n<h3 id=\"引导操作\" tabindex=\"-1\"> 引导操作</h3>\n<p>当产品希望用户能够进行某个操作，需要进行强操作提醒时，可以选择引导操作的导航栏模式，在中心突出操作按钮。大众点评、百果园、转转、星巴克、闲鱼等都是采用这种模式。</p>\n<p><img src=\"@source/design/navigation/assets/tabbar-guide.jpg\" alt=\"引导操作\"></p>\n<h2 id=\"底部导航栏图标表现形式\" tabindex=\"-1\"> 底部导航栏图标表现形式</h2>\n<h3 id=\"线性图标的优势\" tabindex=\"-1\"> 线性图标的优势</h3>\n<p>从大多数 APP 设计来看，未选中状态下，线性图标占有优势。相对面性图标来说，线性图标有更多可能性，且选中与未选中的区分落差较大，对比明显。</p>\n<p><img src=\"@source/design/navigation/assets/tabbar-icon-style.jpg\" alt=\"两种设计方式对比\"></p>\n<h3 id=\"其它图标趋势\" tabindex=\"-1\"> 其它图标趋势</h3>\n<p>未选中状态的图标常用线性方式，目前的主要趋势还是在图标表意上下功夫；选中状态的图标常用面性、微质感、立体、插画等方式。</p>\n<h2 id=\"图标设计思路与创意\" tabindex=\"-1\"> 图标设计思路与创意</h2>\n<p>为了直观表现图标设计的思路，我为权重平分模式、强调信息模式、引导操作模式分别设定不同的产品背景，把图标设计的过程写下来供大家参考。</p>\n<ol>\n<li>\n<p>权重平分模式示例</p>\n<p><img src=\"@source/design/navigation/assets/tenghe.jpg\" alt=\"权重平分模式示例\"></p>\n</li>\n<li>\n<p>强调信息模式示例</p>\n<p><img src=\"@source/design/navigation/assets/zizaixiong.jpg\" alt=\"强调信息模式示例\"></p>\n</li>\n<li>\n<p>引导操作模式示例</p>\n<p><img src=\"@source/design/navigation/assets/yuyou.jpg\" alt=\"引导操作模式示例\"></p>\n</li>\n</ol>\n",
      "date_published": "2020-09-15T00:00:00.000Z",
      "date_modified": "2022-08-20T08:54:00.000Z",
      "authors": [],
      "tags": [
        "设计"
      ]
    },
    {
      "title": "标签导航设计",
      "url": "https://github.com/MisterChen9527/design/navigation/tabbar.html",
      "id": "https://github.com/MisterChen9527/design/navigation/tabbar.html",
      "content_html": "<p>导航分很多类别，如标签导航、抽屉式导航、九宫格导航、混合组合导航、列表式导航、Tab 导航、平铺导航等等。</p>\n<p>现在用到更多的导航其实是标签导航(tabbar)，它随处可见，相信目前大部分的 App 用的导航都是标签形式的。</p>\n<h2 id=\"理清产品框架\" tabindex=\"-1\"> 理清产品框架</h2>\n<p>相信很多设计师在设计导航时，一上来就开始 YY 自己的导航要放什么，因为这个时候他已经被标签形式的导航洗脑了，认为自己的 App 就应该用标签导航。然后继续 YY 产品的功能，自己理出个最适合的，放上去就好了。</p>\n<p>其实不然。做好一个导航要考虑的问题其实非常多，还要考虑产品后期发展的延展性。必须定好整个产品的框架，把最核心的功能放在第一层页面，再根据产品的深度来设计导航的模式。</p>\n<h2 id=\"标签导航的优劣势\" tabindex=\"-1\"> 标签导航的优劣势</h2>\n<p>先来看个图:</p>\n<p><img src=\"@source/design/navigation/assets/wechat.png\" alt=\"微信页面\"></p>\n<p>不要看上面的列表，就看下面的标签。是不是特别熟悉? 很多 App 都是用这类标签式导航来引导用户切换功能。</p>\n<h3 id=\"优势\" tabindex=\"-1\"> 优势</h3>\n<ol>\n<li>\n<p>简单高效，操作方便</p>\n<p>下面的四个功能可以快速切换，用户在使用的过程中不会迷失方向，且简单清晰，层级明确。</p>\n</li>\n<li>\n<p>更好的用户体验</p>\n<p>试想一下，一般在使用 App 时，用户更多的会怎么使用手机? 双手还是单手呢? 肯定都有。所以单手使用手机的用户碰到的 App 是标签导航时，可以更方便的操作，不需要一定得使用另一只手。而某些导航如果不用两只手是没办法操作的。</p>\n</li>\n<li>\n<p>快速了解 App 主要功能</p>\n<p>一般来说，用户第一次使用产品，会关注这个 App 有什么功能，它能帮助自己完成什么任务。所以标签导航可以很好地帮助用户了解产品的主要功能，让用户看到的第一眼就知道自己能做什么。</p>\n</li>\n</ol>\n<h3 id=\"劣势\" tabindex=\"-1\"> 劣势</h3>\n<ol>\n<li>\n<p>功能不能过多</p>\n<p>有些产品功能过多，但是却又都是必要的，不能做删减。而一旦超过五个，就不适合用标签导航。因为标签导航不适合做滑动，所以功能多了可点击区域(热区)就变小了，操作上会有一定影响。</p>\n</li>\n<li>\n<p>占用一定屏幕尺寸</p>\n<p>标签导航占用了屏幕下方不少的位置。</p>\n<div><p>相关信息</p>\n<p>不过也正是因为顶部和底部的 navbar 与 tabbar 会占据太多的屏幕空间，所以现在屏幕尺寸普遍改为了 2:1 而不是原来的 16:9。</p>\n</div>\n</li>\n</ol>\n<h2 id=\"标签导航的延展\" tabindex=\"-1\"> 标签导航的延展</h2>\n<p>有的人会问，如果我的产品很想用标签导航，但是又超过了 5 个功能，那有办法解决么?</p>\n<p><img src=\"@source/design/navigation/assets/zhihu.png\" alt=\"知乎页面\"></p>\n<p>当然有，当您的主功能超过 5 个又一定要使用标签导航的话，那知乎的这个解决方案很适合您(最右边的功能是“更多”)。</p>\n<p>还有一类情况是:主功能是标签导航，次要功能也是标签导航。这些在资讯 APP 是很常见的，比如主功能是“新闻”，次要功能是顶部的“要闻”、“NBA”等等，如果在某个主功能中，次要功能很多，就可以使用这类方式来解决这个问题。</p>\n",
      "date_published": "2020-09-15T00:00:00.000Z",
      "date_modified": "2022-08-20T08:54:00.000Z",
      "authors": [],
      "tags": [
        "设计"
      ]
    },
    {
      "title": "Bash 教程",
      "url": "https://github.com/MisterChen9527/linux/bash/",
      "id": "https://github.com/MisterChen9527/linux/bash/",
      "content_html": "<h2 id=\"目录\" tabindex=\"-1\"> 目录</h2>\n<ul>\n<li>\n<p><a href=\"/linux/bash/intro.html\">简介</a></p>\n</li>\n<li>\n<p><a href=\"/linux/bash/grammar.html\">基本语法</a></p>\n</li>\n<li>\n<p><a href=\"/linux/bash/expansion.html\">模式扩展</a></p>\n</li>\n<li>\n<p><a href=\"/linux/bash/quotation.html\">引号和转义</a></p>\n</li>\n<li>\n<p><a href=\"/linux/bash/variable.html\">变量</a></p>\n</li>\n<li>\n<p><a href=\"/linux/bash/string.html\">字符串操作</a></p>\n</li>\n<li>\n<p><a href=\"/linux/bash/arithmetic.html\">算术运算</a></p>\n</li>\n<li>\n<p><a href=\"/linux/bash/readline.html\">行操作</a></p>\n</li>\n<li>\n<p><a href=\"/linux/bash/stack.html\">目录堆栈</a></p>\n</li>\n<li>\n<p><a href=\"/linux/bash/script.html\">脚本入门</a></p>\n</li>\n<li>\n<p><a href=\"/linux/bash/read.html\">read 命令</a></p>\n</li>\n<li>\n<p><a href=\"/linux/bash/condition.html\">条件判断</a></p>\n</li>\n<li>\n<p><a href=\"/linux/bash/loop.html\">循环</a></p>\n</li>\n<li>\n<p><a href=\"/linux/bash/function.html\">函数</a></p>\n</li>\n<li>\n<p><a href=\"/linux/bash/array.html\">数组</a></p>\n</li>\n<li>\n<p><a href=\"/linux/bash/set.html\">set 命令</a></p>\n</li>\n<li>\n<p><a href=\"/linux/bash/debug.html\">脚本除错</a></p>\n</li>\n<li>\n<p><a href=\"/linux/bash/mktemp.html\">mktemp 命令，trap 命令</a></p>\n</li>\n<li>\n<p><a href=\"/linux/bash/startup.html\">启动环境</a></p>\n</li>\n<li>\n<p><a href=\"/linux/bash/prompt.html\">命令提示符</a></p>\n</li>\n</ul>\n",
      "date_published": "2022-08-20T08:54:00.000Z",
      "date_modified": "2022-08-20T08:54:00.000Z",
      "authors": [
        {
          "name": "阮一峰"
        }
      ],
      "tags": [
        "Linux"
      ]
    },
    {
      "title": "Bash 的算术运算",
      "url": "https://github.com/MisterChen9527/linux/bash/arithmetic.html",
      "id": "https://github.com/MisterChen9527/linux/bash/arithmetic.html",
      "content_html": "<h2 id=\"算术表达式\" tabindex=\"-1\"> 算术表达式</h2>\n<p><code>((...))</code> 语法可以进行整数的算术运算。</p>\n<div><pre><code>$ <span><span>((</span>foo <span>=</span> <span>5</span> <span>+</span> <span>5</span><span>))</span></span>\n$ <span>echo</span> <span>$foo</span>\n<span>10</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div></div></div><p><code>((...))</code> 会自动忽略内部的空格，所以下面的写法都正确，得到同样的结果。</p>\n<div><pre><code><span><span>((</span><span>2</span><span>+</span><span>2</span><span>))</span></span>\n<span><span>((</span> <span>2</span><span>+</span><span>2</span> <span>))</span></span>\n<span><span>((</span> <span>2</span> <span>+</span> <span>2</span> <span>))</span></span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div></div></div><p>这个语法不返回值，命令执行的结果根据算术运算的结果而定。只要算术结果不是 <code>0</code>，命令就算执行成功。</p>\n<div><pre><code>$ <span><span>((</span> <span>3</span> <span>+</span> <span>2</span> <span>))</span></span>\n$ <span>echo</span> <span>$?</span>\n<span>0</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div></div></div><p>上面例子中，<code>3 + 2</code> 的结果是 5，命令就算执行成功，环境变量 <code>$?</code> 为 <code>0</code>。</p>\n<p>如果算术结果为 <code>0</code>，命令就算执行失败。</p>\n<div><pre><code>$ <span><span>((</span> <span>3</span> <span>-</span> <span>3</span> <span>))</span></span>\n$ <span>echo</span> <span>$?</span>\n<span>1</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div></div></div><p>上面例子中，<code>3 - 3</code> 的结果是 <code>0</code>，环境变量 <code>$?</code> 为 <code>1</code>，表示命令执行失败。</p>\n<p>如果要读取算术运算的结果，需要在 <code>((...))</code> 前面加上美元符号 <code>$((...))</code>，使其变成算术表达式，返回算术运算的值。</p>\n<div><pre><code>$ <span>echo</span> <span><span>$((</span><span>2</span> <span>+</span> <span>2</span><span>))</span></span>\n<span>4</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div></div></div><p><code>((...))</code> 语法支持的算术运算符如下。</p>\n<ul>\n<li><code>+</code>: 加法</li>\n<li><code>-</code>: 减法</li>\n<li><code>*</code>: 乘法</li>\n<li><code>/</code>: 除法(整除)</li>\n<li><code>%</code>: 余数</li>\n<li><code>**</code>: 指数</li>\n<li><code>++</code>: 自增运算(前缀或后缀)</li>\n<li><code>--</code>: 自减运算(前缀或后缀)</li>\n</ul>\n<p>注意，除法运算符的返回结果总是整数，比如 <code>5</code> 除以 <code>2</code>，得到的结果是 <code>2</code>，而不是 <code>2.5</code>。</p>\n<div><pre><code>$ <span>echo</span> <span><span>$((</span><span>5</span> <span>/</span> <span>2</span><span>))</span></span>\n<span>2</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div></div></div><p><code>++</code> 和 <code>--</code> 这两个运算符有前缀和后缀的区别。作为前缀是先运算后返回值，作为后缀是先返回值后运算。</p>\n<div><pre><code>$ <span>i</span><span>=</span><span>0</span>\n$ <span>echo</span> <span>$i</span>\n<span>0</span>\n$ <span>echo</span> <span><span>$((</span>i<span>++</span><span>))</span></span>\n<span>0</span>\n$ <span>echo</span> <span>$i</span>\n<span>1</span>\n$ <span>echo</span> <span><span>$((</span><span>++</span>i<span>))</span></span>\n<span>2</span>\n$ <span>echo</span> <span>$i</span>\n<span>2</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面例子中，<code>++</code> 作为后缀是先返回值，执行 <code>echo</code> 命令，再进行自增运算；作为前缀则是先进行自增运算，再返回值执行 <code>echo</code> 命令。</p>\n<p><code>$((...))</code> 内部可以用圆括号改变运算顺序。</p>\n<div><pre><code>$ <span>echo</span> <span><span>$((</span> <span>(</span><span>2</span> <span>+</span> <span>3</span><span>)</span> <span>*</span> <span>4</span> <span>))</span></span>\n<span>20</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div></div></div><p>上面例子中，内部的圆括号让加法先于乘法执行。</p>\n<p><code>$((...))</code> 结构可以嵌套。</p>\n<div><pre><code>$ <span>echo</span> <span><span>$((</span><span>(</span><span>5</span><span>**</span><span>2</span><span>)</span> <span>*</span> <span>3</span><span>))</span></span>\n<span>75</span>\n<span># 等同于</span>\n$ <span>echo</span> <span><span>$((</span><span>$((</span><span>5</span><span>**</span><span>2</span><span>))</span></span> * <span>3</span><span>))</span>\n<span>75</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div></div></div><p>这个语法只能计算整数，否则会报错。</p>\n<div><pre><code><span># 报错</span>\n$ <span>echo</span> <span><span>$((</span><span>1.5</span> <span>+</span> <span>1</span><span>))</span></span>\nbash: 语法错误\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div></div></div><p><code>$((...))</code> 的圆括号之中，不需要在变量名之前加上 <code>$</code>，不过加上也不报错。</p>\n<div><pre><code>$ <span>number</span><span>=</span><span>2</span>\n$ <span>echo</span> <span><span>$((</span>$number <span>+</span> <span>1</span><span>))</span></span>\n<span>3</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div></div></div><p>上面例子中，变量 <code>number</code> 前面有没有美元符号，结果都是一样的。</p>\n<p>如果在 <code>$((...))</code> 里面使用字符串，Bash 会认为那是一个变量名。如果不存在同名变量，Bash 就会将其作为空值，因此不会报错。</p>\n<div><pre><code>$ <span>echo</span> <span><span>$((</span> \"hello\" <span>+</span> <span>2</span><span>))</span></span>\n<span>2</span>\n$ <span>echo</span> <span><span>$((</span> \"hello\" <span>*</span> <span>2</span><span>))</span></span>\n<span>0</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div></div></div><p>上面例子中，<code>&quot;hello&quot;</code> 会被当作变量名，返回空值，而 <code>$((...))</code> 会将空值当作 <code>0</code>，所以乘法的运算结果就是 <code>0</code>。同理，如果 <code>$((...))</code> 里面使用不存在的变量，也会当作 <code>0</code> 处理。</p>\n<p>如果一个变量的值为字符串，跟上面的处理逻辑是一样的。即该字符串如果不对应已存在的变量，在 <code>$((...))</code> 里面会被当作空值。</p>\n<div><pre><code>$ <span>foo</span><span>=</span>hello\n$ <span>echo</span> <span><span>$((</span> foo <span>+</span> <span>2</span><span>))</span></span>\n<span>2</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div></div></div><p>上面例子中，变量 <code>foo</code> 的值是 <code>hello</code>，而 <code>hello</code> 也会被看作变量名。这使得有可能写出动态替换的代码。</p>\n<div><pre><code>$ <span>foo</span><span>=</span>hello\n$ <span>hello</span><span>=</span><span>3</span>\n$ <span>echo</span> <span><span>$((</span> foo <span>+</span> <span>2</span> <span>))</span></span>\n<span>5</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div></div></div><p>上面代码中，<code>foo + 2</code> 取决于变量 <code>hello</code> 的值。</p>\n<p>最后，<code>$[...]</code> 是以前的语法，也可以做整数运算，不建议使用。</p>\n<div><pre><code>$ <span>echo</span> $<span>[</span><span>2</span>+2<span>]</span>\n<span>4</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div></div></div><h2 id=\"数值的进制\" tabindex=\"-1\"> 数值的进制</h2>\n<p>Bash 的数值默认都是十进制，但是在算术表达式中，也可以使用其他进制。</p>\n<ul>\n<li><code>number</code>: 没有任何特殊表示法的数字是十进制数(以 10 为底)。</li>\n<li><code>0number</code>: 八进制数。</li>\n<li><code>0xnumber</code>: 十六进制数。</li>\n<li><code>base#number</code>: <code>base</code> 进制的数。</li>\n</ul>\n<p>下面是一些例子。</p>\n<div><pre><code>$ <span>echo</span> <span><span>$((</span><span>0xff</span><span>))</span></span>\n<span>255</span>\n$ <span>echo</span> <span><span>$((</span><span>2</span>#<span>11111111</span><span>))</span></span>\n<span>255</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div></div></div><p>上面例子中，<code>0xff</code> 是十六进制数，<code>2#11111111</code> 是二进制数。</p>\n<h2 id=\"位运算\" tabindex=\"-1\"> 位运算</h2>\n<p><code>$((...))</code> 支持以下的二进制位运算符。</p>\n<ul>\n<li><code>&lt;&lt;</code>: 位左移运算，把一个数字的所有位向左移动指定的位。</li>\n<li><code>&gt;&gt;</code>: 位右移运算，把一个数字的所有位向右移动指定的位。</li>\n<li><code>&amp;</code>: 位的“与”运算，对两个数字的所有位执行一个 <code>AND</code> 操作。</li>\n<li><code>|</code>: 位的“或”运算，对两个数字的所有位执行一个 <code>OR</code> 操作。</li>\n<li><code>~</code>: 位的“否”运算，对一个数字的所有位取反。</li>\n<li><code>^</code>: 位的异或运算(exclusive or)，对两个数字的所有位执行一个异或操作。</li>\n</ul>\n<p>下面是右移运算符 <code>&gt;&gt;</code> 的例子。</p>\n<div><pre><code>$ <span>echo</span> <span><span>$((</span><span>16</span><span>>></span><span>2</span><span>))</span></span>\n<span>4</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div></div></div><p>下面是左移运算符 <code>&lt;&lt;</code> 的例子。</p>\n<div><pre><code>$ <span>echo</span> <span><span>$((</span><span>16</span><span>&lt;&lt;</span><span>2</span><span>))</span></span>\n<span>64</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div></div></div><p>下面是 <code>17</code> (二进制 <code>10001</code>)和 <code>3</code> (二进制 <code>11</code>)的各种二进制运算的结果。</p>\n<div><pre><code>$ <span>echo</span> <span><span>$((</span><span>17</span><span>&amp;</span><span>3</span><span>))</span></span>\n<span>1</span>\n$ <span>echo</span> <span><span>$((</span><span>17</span><span>|</span><span>3</span><span>))</span></span>\n<span>19</span>\n$ <span>echo</span> <span><span>$((</span><span>17</span><span>^</span><span>3</span><span>))</span></span>\n<span>18</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id=\"逻辑运算\" tabindex=\"-1\"> 逻辑运算</h2>\n<p><code>$((...))</code> 支持以下的逻辑运算符。</p>\n<ul>\n<li><code>&lt;</code>: 小于</li>\n<li><code>&gt;</code>: 大于</li>\n<li><code>&lt;=</code>: 小于或相等</li>\n<li><code>&gt;=</code>: 大于或相等</li>\n<li><code>==</code>: 相等</li>\n<li><code>!=</code>: 不相等</li>\n<li><code>&amp;&amp;</code>: 逻辑与</li>\n<li><code>||</code>: 逻辑或</li>\n<li><code>!</code>: 逻辑否</li>\n<li><code>expr1?expr2:expr3</code>: 三元条件运算符。若表达式 <code>expr1</code> 的计算结果为非零值(算术真)，则执行表达式 <code>expr2</code>，否则执行表达式 <code>expr3</code>。</li>\n</ul>\n<p>如果逻辑表达式为真，返回 <code>1</code>，否则返回 <code>0</code>。</p>\n<div><pre><code>$ <span>echo</span> <span><span>$((</span><span>3</span> <span>></span> <span>2</span><span>))</span></span>\n<span>1</span>\n$ <span>echo</span> <span><span>$((</span> <span>(</span><span>3</span> <span>></span> <span>2</span><span>)</span> <span>||</span> <span>(</span><span>4</span> <span>&lt;=</span> <span>1</span><span>)</span> <span>))</span></span>\n<span>1</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div></div></div><p>三元运算符执行一个单独的逻辑测试。它用起来类似于 <code>if/then/else</code> 语句。</p>\n<div><pre><code>$ <span>a</span><span>=</span><span>0</span>\n$ <span>echo</span> <span><span>$((</span>a<span>&lt;</span><span>1</span> <span>?</span> <span>1</span> <span>:</span> <span>0</span><span>))</span></span>\n<span>1</span>\n$ <span>echo</span> <span><span>$((</span>a<span>></span><span>1</span> <span>?</span> <span>1</span> <span>:</span> <span>0</span><span>))</span></span>\n<span>0</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div></div></div><p>上面例子中，第一个表达式为真时，返回第二个表达式的值，否则返回第三个表达式的值。</p>\n<h2 id=\"赋值运算\" tabindex=\"-1\"> 赋值运算</h2>\n<p>算术表达式 <code>$((...))</code> 可以执行赋值运算。</p>\n<div><pre><code>$ <span>echo</span> <span><span>$((</span>a<span>=</span><span>1</span><span>))</span></span>\n<span>1</span>\n$ <span>echo</span> <span>$a</span>\n<span>1</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div></div></div><p>上面例子中，<code>a=1</code> 对变量 <code>a</code> 进行赋值。这个式子本身也是一个表达式，返回值就是等号右边的值。</p>\n<p><code>$((...))</code> 支持的赋值运算符，有以下这些。</p>\n<ul>\n<li><code>parameter = value</code>: 简单赋值。</li>\n<li><code>parameter += value</code>: 等价于 <code>parameter = parameter + value</code>。</li>\n<li><code>parameter -= value</code>: 等价于 <code>parameter = parameter – value</code>。</li>\n<li><code>parameter *= value</code>: 等价于 <code>parameter = parameter * value</code>。</li>\n<li><code>parameter /= value</code>: 等价于 <code>parameter = parameter / value</code>。</li>\n<li><code>parameter %= value</code>: 等价于 <code>parameter = parameter % value</code>。</li>\n<li><code>parameter &lt;&lt;= value</code>: 等价于 <code>parameter = parameter &lt;&lt; value</code>。</li>\n<li><code>parameter &gt;&gt;= value</code>: 等价于 <code>parameter = parameter &gt;&gt; value</code>。</li>\n<li><code>parameter &amp;= value</code>: 等价于 <code>parameter = parameter &amp; value</code>。</li>\n<li><code>parameter |= value</code>: 等价于 <code>parameter = parameter | value</code>。</li>\n<li><code>parameter ^= value</code>: 等价于 <code>parameter = parameter ^ value</code>。</li>\n</ul>\n<p>下面是一个例子。</p>\n<div><pre><code>$ <span>foo</span><span>=</span><span>5</span>\n$ <span>echo</span> <span><span>$((</span>foo<span>*=</span><span>2</span><span>))</span></span>\n<span>10</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div></div></div><p>如果在表达式内部赋值，可以放在圆括号中，否则会报错。</p>\n<div><pre><code><span>echo</span> <span><span>$((</span> a<span>&lt;</span><span>1</span> <span>?</span> <span>(</span>a<span>+=</span><span>1</span><span>)</span> <span>:</span> <span>(</span>a<span>-=</span><span>1</span><span>)</span> <span>))</span></span>\n</code></pre><div aria-hidden=\"true\"><div></div></div></div><h2 id=\"求值运算\" tabindex=\"-1\"> 求值运算</h2>\n<p>逗号 <code>,</code> 在 <code>$((...))</code> 内部是求值运算符，执行前后两个表达式，并返回后一个表达式的值。</p>\n<div><pre><code>$ <span>echo</span> <span><span>$((</span>foo <span>=</span> <span>1</span> <span>+</span> <span>2</span><span>,</span> <span>3</span> <span>*</span> <span>4</span><span>))</span></span>\n<span>12</span>\n$ <span>echo</span> <span>$foo</span>\n<span>3</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div></div></div><p>上面例子中，逗号前后两个表达式都会执行，然后返回后一个表达式的值 <code>12</code>。</p>\n<h2 id=\"expr-命令\" tabindex=\"-1\"> expr 命令</h2>\n<p><code>expr</code> 命令支持算术运算，可以不使用 <code>((...))</code> 语法。</p>\n<div><pre><code>$ <span>expr</span> <span>3</span> + <span>2</span>\n<span>5</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div></div></div><p><code>expr</code> 命令支持变量替换。</p>\n<div><pre><code>$ <span>foo</span><span>=</span><span>3</span>\n$ <span>expr</span> <span>$foo</span> + <span>2</span>\n<span>5</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div></div></div><p><code>expr</code> 命令也不支持非整数参数。</p>\n<div><pre><code>$ <span>expr</span> <span>3.5</span> + <span>2</span>\nexpr: 非整数参数\n</code></pre><div aria-hidden=\"true\"><div></div><div></div></div></div><p>上面例子中，如果有非整数的运算，<code>expr</code> 命令就报错了。</p>\n",
      "date_published": "2022-08-20T08:54:00.000Z",
      "date_modified": "2022-08-20T08:54:00.000Z",
      "authors": [
        {
          "name": "阮一峰"
        }
      ],
      "tags": [
        "Linux"
      ]
    },
    {
      "title": "数组",
      "url": "https://github.com/MisterChen9527/linux/bash/array.html",
      "id": "https://github.com/MisterChen9527/linux/bash/array.html",
      "summary": "数组(array)是一个包含多个值的变量。成员的编号从 0 开始，数量没有上限，也没有要求成员被连续索引。\n",
      "content_html": "<p>数组(array)是一个包含多个值的变量。成员的编号从 0 开始，数量没有上限，也没有要求成员被连续索引。</p>\n\n<h2 id=\"创建数组\" tabindex=\"-1\"> 创建数组</h2>\n<p>数组可以采用逐个赋值的方法创建。</p>\n<div><pre><code>ARRAY<span>[</span>INDEX<span>]</span><span>=</span>value\n</code></pre><div aria-hidden=\"true\"><div></div></div></div><p>上面语法中，<code>ARRAY</code> 是数组的名字，可以是任意合法的变量名。<code>INDEX</code> 是一个大于或等于零的整数，也可以是算术表达式。注意数组第一个元素的下标是 0， 而不是 1。</p>\n<p>下面创建一个三个成员的数组。</p>\n<div><pre><code>array<span>[</span><span>0</span><span>]</span><span>=</span>val\narray<span>[</span><span>1</span><span>]</span><span>=</span>val\narray<span>[</span><span>2</span><span>]</span><span>=</span>val\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div></div></div><p>数组也可以采用一次性赋值的方式创建。</p>\n<div><pre><code><span>ARRAY</span><span>=</span><span>(</span>value1 value2 <span>..</span>. valueN<span>)</span>\n\n<span># 等同于</span>\n\n<span>ARRAY</span><span>=</span><span>(</span>\n  value1\n  value2\n  value3\n<span>)</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>采用上面方式创建数组时，可以按照默认顺序赋值，也可以在每个值前面指定位置。</p>\n<div><pre><code><span>array</span><span>=</span><span>(</span>a b c<span>)</span>\n<span>array</span><span>=</span><span>(</span><span>[</span><span>2</span><span>]</span><span>=</span>c <span>[</span><span>0</span><span>]</span><span>=</span>a <span>[</span><span>1</span><span>]</span><span>=</span>b<span>)</span>\n\n<span>days</span><span>=</span><span>(</span>Sun Mon Tue Wed Thu Fri Sat<span>)</span>\n<span>days</span><span>=</span><span>(</span><span>[</span><span>0</span><span>]</span><span>=</span>Sun <span>[</span><span>1</span><span>]</span><span>=</span>Mon <span>[</span><span>2</span><span>]</span><span>=</span>Tue <span>[</span><span>3</span><span>]</span><span>=</span>Wed <span>[</span><span>4</span><span>]</span><span>=</span>Thu <span>[</span><span>5</span><span>]</span><span>=</span>Fri <span>[</span><span>6</span><span>]</span><span>=</span>Sat<span>)</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div></div></div><p>只为某些值指定位置，也是可以的。</p>\n<div><pre><code><span>names</span><span>=</span><span>(</span>hatter <span>[</span><span>5</span><span>]</span><span>=</span>duchess alice<span>)</span>\n</code></pre><div aria-hidden=\"true\"><div></div></div></div><p>上面例子中，<code>hatter</code> 是数组的 0 号位置，<code>duchess</code> 是 5 号位置，<code>alice</code> 是 6 号位置。</p>\n<p>没有赋值的数组元素的默认值是空字符串。</p>\n<p>定义数组的时候，可以使用通配符。</p>\n<div><pre><code><span>mp3s</span><span>=</span><span>(</span> *.mp3 <span>)</span>\n</code></pre><div aria-hidden=\"true\"><div></div></div></div><p>上面例子中，将当前目录的所有 MP3 文件，放进一个数组。</p>\n<p>先用 <code>declare -a</code> 命令声明一个数组，也是可以的。</p>\n<div><pre><code><span>declare</span> -a ARRAYNAME\n</code></pre><div aria-hidden=\"true\"><div></div></div></div><p><code>read -a</code> 命令则是将用户的命令行输入，读入一个数组。</p>\n<div><pre><code><span>read</span> -a dice\n</code></pre><div aria-hidden=\"true\"><div></div></div></div><p>上面命令将用户的命令行输入，读入数组 <code>dice</code>。</p>\n<h2 id=\"读取数组\" tabindex=\"-1\"> 读取数组</h2>\n<h3 id=\"读取单个元素\" tabindex=\"-1\"> 读取单个元素</h3>\n<p>读取数组指定位置的成员，要使用下面的语法。</p>\n<div><pre><code><span>echo</span> <span>${array<span>[</span>i<span>]</span>}</span>     <span># i 是索引</span>\n</code></pre><div aria-hidden=\"true\"><div></div></div></div><p>上面语法里面的大括号是必不可少的，否则 Bash 会把索引部分 <code>[i]</code> 按照原样输出。</p>\n<div><pre><code>$ array<span>[</span><span>0</span><span>]</span><span>=</span>a\n\n$ <span>echo</span> <span>${array<span>[</span>0<span>]</span>}</span>\na\n\n$ <span>echo</span> <span>$array</span><span>[</span><span>0</span><span>]</span>\na<span>[</span><span>0</span><span>]</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面例子中，数组的第一个元素是 <code>a</code>。如果不加大括号，Bash 会直接读取 <code>$array</code> 首成员的值，然后将 <code>[0]</code> 按照原样输出。</p>\n<h3 id=\"读取所有成员\" tabindex=\"-1\"> 读取所有成员</h3>\n<p><code>@</code> 和 <code>*</code> 是数组的特殊索引，表示返回数组的所有成员。</p>\n<div><pre><code>$ <span>foo</span><span>=</span><span>(</span>a b c d e f<span>)</span>\n$ <span>echo</span> <span>${foo<span>[</span>@<span>]</span>}</span>\na b c d e f\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div></div></div><p>这两个特殊索引配合 <code>for</code> 循环，就可以用来遍历数组。</p>\n<div><pre><code><span>for</span> <span>i</span> <span>in</span> <span>\"<span>${names<span>[</span>@<span>]</span>}</span>\"</span><span>;</span> <span>do</span>\n  <span>echo</span> <span>$i</span>\n<span>done</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div></div></div><p><code>@</code> 和 <code>*</code> 放不放在双引号之中，是有差别的。</p>\n<div><pre><code>$ <span>activities</span><span>=</span><span>(</span> swimming <span>\"water skiing\"</span> canoeing <span>\"white-water rafting\"</span> surfing <span>)</span>\n$ <span>for</span> <span>act</span> <span>in</span> <span>${activities<span>[</span>@<span>]</span>}</span><span>;</span> <span>\\</span>\n<span>do</span> <span>\\</span>\n<span>echo</span> <span>\"Activity: <span>$act</span>\"</span><span>;</span> <span>\\</span>\n<span>done</span>\n\nActivity: swimming\nActivity: water\nActivity: skiing\nActivity: canoeing\nActivity: white-water\nActivity: rafting\nActivity: surfing\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面的例子中，数组 <code>activities</code> 实际包含 5 个元素，但是 <code>for...in</code> 循环直接遍历 <code>${activities[@]}</code>，会导致返回 7 个结果。为了避免这种情况，一般把 <code>${activities[@]}</code> 放在双引号之中。</p>\n<div><pre><code>$ <span>for</span> <span>act</span> <span>in</span> <span>\"<span>${activities<span>[</span>@<span>]</span>}</span>\"</span><span>;</span> <span>\\</span>\n<span>do</span> <span>\\</span>\n<span>echo</span> <span>\"Activity: <span>$act</span>\"</span><span>;</span> <span>\\</span>\n<span>done</span>\n\nActivity: swimming\nActivity: water skiing\nActivity: canoeing\nActivity: white-water rafting\nActivity: surfing\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面例子中，<code>${activities[@]}</code> 放在双引号之中，遍历就会返回正确的结果。</p>\n<p><code>${activities[*]}</code> 不放在双引号之中，跟 <code>${activities[@]}</code> 不放在双引号之中是一样的。</p>\n<div><pre><code>$ <span>for</span> <span>act</span> <span>in</span> <span>${activities<span>[</span>*<span>]</span>}</span><span>;</span> <span>\\</span>\n<span>do</span> <span>\\</span>\n<span>echo</span> <span>\"Activity: <span>$act</span>\"</span><span>;</span> <span>\\</span>\n<span>done</span>\n\nActivity: swimming\nActivity: water\nActivity: skiing\nActivity: canoeing\nActivity: white-water\nActivity: rafting\nActivity: surfing\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><code>${activities[*]}</code> 放在双引号之中，所有元素就会变成单个字符串返回。</p>\n<div><pre><code>$ <span>for</span> <span>act</span> <span>in</span> <span>\"<span>${activities<span>[</span>*<span>]</span>}</span>\"</span><span>;</span> <span>\\</span>\n<span>do</span> <span>\\</span>\n<span>echo</span> <span>\"Activity: <span>$act</span>\"</span><span>;</span> <span>\\</span>\n<span>done</span>\n\nActivity: swimming water skiing canoeing white-water rafting surfing\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>所以，拷贝一个数组的最方便方法，就是写成下面这样。</p>\n<div><pre><code><span>hobbies</span><span>=</span><span>(</span> <span>\"<span>${activities<span>[</span>@<span>]</span>}</span>\"</span> <span>)</span>\n</code></pre><div aria-hidden=\"true\"><div></div></div></div><p>上面例子中，数组 <code>activities</code> 被拷贝给了另一个数组 <code>hobbies</code>。</p>\n<p>这种写法也可以用来为新数组添加成员。</p>\n<div><pre><code><span>hobbies</span><span>=</span><span>(</span> <span>\"${activities[@]\"</span> diving <span>)</span>\n</code></pre><div aria-hidden=\"true\"><div></div></div></div><p>上面例子中，新数组 <code>hobbies</code> 在数组 <code>activities</code> 的所有成员之后，又添加了一个成员。</p>\n<h3 id=\"默认位置\" tabindex=\"-1\"> 默认位置</h3>\n<p>如果读取数组成员时，没有读取指定哪一个位置的成员，默认使用 <code>0</code> 号位置。</p>\n<div><pre><code>$ <span>declare</span> -a foo\n$ <span>foo</span><span>=</span>A\n$ <span>echo</span> <span>${foo<span>[</span>0<span>]</span>}</span>\nA\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div></div></div><p>上面例子中，<code>foo</code> 是一个数组，赋值的时候不指定位置，实际上是给 <code>foo[0]</code> 赋值。</p>\n<p>引用一个不带下标的数组变量，则引用的是 <code>0</code> 号位置的数组元素。</p>\n<div><pre><code>$ <span>foo</span><span>=</span><span>(</span>a b c d e f<span>)</span>\n$ <span>echo</span> <span>${foo}</span>\na\n$ <span>echo</span> <span>$foo</span>\na\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div></div></div><p>上面例子中，引用数组元素的时候，没有指定位置，结果返回的是 <code>0</code> 号位置。</p>\n<h2 id=\"数组的长度\" tabindex=\"-1\"> 数组的长度</h2>\n<p>要想知道数组的长度(即一共包含多少成员)，可以使用下面两种语法。</p>\n<div><pre><code><span>${<span>#</span>array<span>[</span>*<span>]</span>}</span>\n<span>${<span>#</span>array<span>[</span>@<span>]</span>}</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div></div></div><p>下面是一个例子。</p>\n<div><pre><code>$ a<span>[</span><span>100</span><span>]</span><span>=</span>foo\n\n$ <span>echo</span> <span>${<span>#</span>a<span>[</span>*<span>]</span>}</span>\n<span>1</span>\n\n$ <span>echo</span> <span>${<span>#</span>a<span>[</span>@<span>]</span>}</span>\n<span>1</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面例子中，把字符串赋值给 <code>100</code> 位置的数组元素，这时的数组只有一个元素。</p>\n<p>注意，如果用这种语法去读取具体的数组成员，就会返回该成员的字符串长度。这一点必须小心。</p>\n<div><pre><code>$ a<span>[</span><span>100</span><span>]</span><span>=</span>foo\n$ <span>echo</span> <span>${<span>#</span>a<span>[</span>100<span>]</span>}</span>\n<span>3</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div></div></div><p>上面例子中，<code>${#a[100]}</code> 实际上是返回数组第 100 号成员 <code>a[100]</code> 的值(<code>foo</code>)的字符串长度。</p>\n<h2 id=\"提取数组序号\" tabindex=\"-1\"> 提取数组序号</h2>\n<p><code>${!array[@]}</code> 或 <code>${!array[*]}</code>，可以返回数组的成员序号，即哪些位置是有值的。</p>\n<div><pre><code>$ <span>arr</span><span>=</span><span>(</span><span>[</span><span>5</span><span>]</span><span>=</span>a <span>[</span><span>9</span><span>]</span><span>=</span>b <span>[</span><span>23</span><span>]</span><span>=</span>c<span>)</span>\n$ <span>echo</span> <span>${<span>!</span>arr<span>[</span>@<span>]</span>}</span>\n<span>5</span> <span>9</span> <span>23</span>\n$ <span>echo</span> <span>${<span>!</span>arr<span>[</span>*<span>]</span>}</span>\n<span>5</span> <span>9</span> <span>23</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div></div></div><p>上面例子中，数组的 5、9、23 号位置有值。</p>\n<p>利用这个语法，也可以通过 <code>for</code> 循环遍历数组。</p>\n<div><pre><code><span>arr</span><span>=</span><span>(</span>a b c d<span>)</span>\n\n<span>for</span> <span>i</span> <span>in</span> <span>${<span>!</span>arr<span>[</span>@<span>]</span>}</span><span>;</span><span>do</span>\n  <span>echo</span> <span>${arr<span>[</span>i<span>]</span>}</span>\n<span>done</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div></div></div><h2 id=\"提取数组成员\" tabindex=\"-1\"> 提取数组成员</h2>\n<p><code>${array[@]:position:length}</code> 的语法可以提取数组成员。</p>\n<div><pre><code>$ <span>food</span><span>=</span><span>(</span> apples bananas cucumbers dates eggs fajitas grapes <span>)</span>\n$ <span>echo</span> <span>${food<span>[</span>@<span>]</span><span>:</span>1<span>:</span>1}</span>\nbananas\n$ <span>echo</span> <span>${food<span>[</span>@<span>]</span><span>:</span>1<span>:</span>3}</span>\nbananas cucumbers dates\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div></div></div><p>上面例子中，<code>${food[@]:1:1}</code> 返回从数组 1 号位置开始的 1 个成员，<code>${food[@]:1:3}</code> 返回从 1 号位置开始的 3 个成员。</p>\n<p>如果省略长度参数 <code>length</code>，则返回从指定位置开始的所有成员。</p>\n<div><pre><code>$ <span>echo</span> <span>${food<span>[</span>@<span>]</span><span>:</span>4}</span>\neggs fajitas grapes\n</code></pre><div aria-hidden=\"true\"><div></div><div></div></div></div><p>上面例子返回从 4 号位置开始到结束的所有成员。</p>\n<h2 id=\"追加数组成员\" tabindex=\"-1\"> 追加数组成员</h2>\n<p>数组末尾追加成员，可以使用 <code>+=</code> 赋值运算符。它能够自动地把值追加到数组末尾。否则，就需要知道数组的最大序号，比较麻烦。</p>\n<div><pre><code>$ <span>foo</span><span>=</span><span>(</span>a b c<span>)</span>\n$ <span>echo</span> <span>${foo<span>[</span>@<span>]</span>}</span>\na b c\n\n$ <span>foo</span><span>+=</span><span>(</span>d e f<span>)</span>\n$ <span>echo</span> <span>${foo<span>[</span>@<span>]</span>}</span>\na b c d e f\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id=\"删除数组\" tabindex=\"-1\"> 删除数组</h2>\n<p>删除一个数组成员，使用 <code>unset</code> 命令。</p>\n<div><pre><code>$ <span>foo</span><span>=</span><span>(</span>a b c d e f<span>)</span>\n$ <span>echo</span> <span>${foo<span>[</span>@<span>]</span>}</span>\na b c d e f\n\n$ <span>unset</span> foo<span>[</span><span>2</span><span>]</span>\n$ <span>echo</span> <span>${foo<span>[</span>@<span>]</span>}</span>\na b d e f\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面例子中，删除了数组中的第三个元素，下标为 2。</p>\n<p>删除成员也可以将这个成员设为空值。</p>\n<div><pre><code>$ <span>foo</span><span>=</span><span>(</span>a b c d e f<span>)</span>\n$ foo<span>[</span><span>1</span><span>]</span><span>=</span><span>''</span>\n$ <span>echo</span> <span>${foo<span>[</span>@<span>]</span>}</span>\na c d e f\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div></div></div><p>上面例子中，将数组的第二个成员设为空字符串，就删除了这个成员。</p>\n<p>由于空值就是空字符串，所以下面这样写也可以，但是不建议这种写法。</p>\n<div><pre><code>foo<span>[</span><span>1</span><span>]</span><span>=</span>\n</code></pre><div aria-hidden=\"true\"><div></div></div></div><p>上面的写法也相当于删除了数组的第二个成员。</p>\n<p>直接将数组变量赋值为空字符串，相当于删除数组的第一个成员。</p>\n<div><pre><code>$ <span>foo</span><span>=</span><span>(</span>a b c d e f<span>)</span>\n$ <span>foo</span><span>=</span><span>''</span>\n$ <span>echo</span> <span>${foo<span>[</span>@<span>]</span>}</span>\nb c d e f\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div></div></div><p>上面的写法相当于删除了数组的第一个成员。</p>\n<p><code>unset ArrayName</code> 可以清空整个数组。</p>\n<div><pre><code>$ <span>unset</span> ARRAY\n\n$ <span>echo</span> <span>${ARRAY<span>[</span>*<span>]</span>}</span>\n<span>&lt;</span>--no output--<span>></span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div></div></div><h2 id=\"关联数组\" tabindex=\"-1\"> 关联数组</h2>\n<p>Bash 的新版本支持关联数组。关联数组使用字符串而不是整数作为数组索引。</p>\n<p><code>declare -A</code> 可以声明关联数组。</p>\n<div><pre><code><span>declare</span> -A colors\ncolors<span>[</span><span>\"red\"</span><span>]</span><span>=</span><span>\"#ff0000\"</span>\ncolors<span>[</span><span>\"green\"</span><span>]</span><span>=</span><span>\"#00ff00\"</span>\ncolors<span>[</span><span>\"blue\"</span><span>]</span><span>=</span><span>\"#0000ff\"</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div></div></div><p>整数索引的数组，可以直接使用变量名创建数组，关联数组则必须用带有 <code>-A</code> 选项的 <code>declare</code> 命令声明创建。</p>\n<p>访问关联数组成员的方式，几乎与整数索引数组相同。</p>\n<div><pre><code><span>echo</span> <span>${colors<span>[</span>\"blue\"<span>]</span>}</span>\n</code></pre><div aria-hidden=\"true\"><div></div></div></div>",
      "date_published": "2022-08-20T08:54:00.000Z",
      "date_modified": "2022-08-20T08:54:00.000Z",
      "authors": [
        {
          "name": "阮一峰"
        }
      ],
      "tags": [
        "Linux"
      ]
    },
    {
      "title": "条件判断",
      "url": "https://github.com/MisterChen9527/linux/bash/condition.html",
      "id": "https://github.com/MisterChen9527/linux/bash/condition.html",
      "summary": "本章介绍 Bash 脚本的条件判断语法。\n",
      "content_html": "<p>本章介绍 Bash 脚本的条件判断语法。</p>\n\n<h2 id=\"if-结构\" tabindex=\"-1\"> if 结构</h2>\n<p><code>if</code> 是最常用的条件判断结构，只有符合给定条件时，才会执行指定的命令。它的语法如下。</p>\n<div><pre><code><span>if</span> commands<span>;</span> <span>then</span>\n  commands\n<span>[</span>elif commands<span>;</span> <span>then</span>\n  commands<span>..</span>.<span>]</span>\n<span>[</span>else\n  commands<span>]</span>\n<span>fi</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>这个命令分成三个部分: <code>if</code>、<code>elif</code> 和 <code>else</code>。其中，后两个部分是可选的。</p>\n<p><code>if</code> 关键字后面是主要的判断条件，<code>elif</code> 用来添加在主条件不成立时的其他判断条件，<code>else</code> 则是所有条件都不成立时要执行的部分。</p>\n<div><pre><code><span>if</span> <span>test</span> <span>$USER</span> <span>=</span> <span>\"foo\"</span><span>;</span> <span>then</span>\n  <span>echo</span> <span>\"Hello foo.\"</span>\n<span>else</span>\n  <span>echo</span> <span>\"You are not foo.\"</span>\n<span>fi</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div></div></div><p>上面的例子中，判断条件是环境变量 <code>$USER</code> 是否等于 <code>foo</code>，如果等于就输出 <code>Hello foo.</code>，否则输出其他内容。</p>\n<p><code>if</code> 和 <code>then</code> 写在同一行时，需要分号分隔。分号是 Bash 的命令分隔符。它们也可以写成两行，这时不需要分号。</p>\n<div><pre><code><span>if</span> <span>true</span>\n<span>then</span>\n  <span>echo</span> <span>'hello world'</span>\n<span>fi</span>\n\n<span>if</span> <span>false</span>\n<span>then</span>\n  <span>echo</span> <span>'it is false'</span> <span># 本行不会执行</span>\n<span>fi</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面的例子中，<code>true</code> 和 <code>false</code> 是两个特殊命令，前者代表操作成功，后者代表操作失败。<code>if true</code> 意味着命令部分总是会执行，<code>if false</code> 意味着命令部分永远不会执行。</p>\n<p>除了多行的写法，<code>if</code> 结构也可以写成单行。</p>\n<div><pre><code>$ <span>if</span> <span>true</span><span>;</span> <span>then</span> <span>echo</span> <span>'hello world'</span><span>;</span> <span>fi</span>\nhello world\n\n$ <span>if</span> <span>false</span><span>;</span> <span>then</span> <span>echo</span> <span>\"It's true.\"</span><span>;</span> <span>fi</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div></div></div><p>注意，<code>if</code> 关键字后面也可以是一条命令，该条命令执行成功(返回值 <code>0</code>)，就意味着判断条件成立。</p>\n<div><pre><code>$ <span>if</span> <span>echo</span> <span>'hi'</span><span>;</span> <span>then</span> <span>echo</span> <span>'hello world'</span><span>;</span> <span>fi</span>\nhi\nhello world\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div></div></div><p>上面命令中，<code>if</code> 后面是一条命令 <code>echo 'hi'</code>。该命令会执行，如果返回值是 <code>0</code>，则执行 <code>then</code> 的部分。</p>\n<p><code>if</code> 后面可以跟任意数量的命令。这时，所有命令都会执行，但是判断真伪只看最后一个命令，即使前面所有命令都失败，只要最后一个命令返回 <code>0</code>，就会执行 <code>then</code> 的部分。</p>\n<div><pre><code>$ <span>if</span> <span>false</span><span>;</span> <span>true</span><span>;</span> <span>then</span> <span>echo</span> <span>'hello world'</span><span>;</span> <span>fi</span>\nhello world\n</code></pre><div aria-hidden=\"true\"><div></div><div></div></div></div><p>上面例子中，<code>if</code> 后面有两条命令 (<code>false;true;</code>)，第二条命令 (<code>true</code>) 决定了 <code>then</code> 的部分是否会执行。</p>\n<p><code>elif</code> 部分可以有多个。</p>\n<div><pre><code><span>#!/bin/bash</span>\n\n<span>echo</span> -n <span>\"输入一个 1 到 3 之间的数字(包含两端)> \"</span>\n<span>read</span> character\n<span>if</span> <span>[</span> <span>\"<span>$character</span>\"</span> <span>=</span> <span>\"1\"</span> <span>]</span><span>;</span> <span>then</span>\n    <span>echo</span> <span>1</span>\n<span>elif</span> <span>[</span> <span>\"<span>$character</span>\"</span> <span>=</span> <span>\"2\"</span> <span>]</span><span>;</span> <span>then</span>\n    <span>echo</span> <span>2</span>\n<span>elif</span> <span>[</span> <span>\"<span>$character</span>\"</span> <span>=</span> <span>\"3\"</span> <span>]</span><span>;</span> <span>then</span>\n    <span>echo</span> <span>3</span>\n<span>else</span>\n    <span>echo</span> 输入不符合要求\n<span>fi</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面例子中，如果用户输入 <code>3</code>，就会连续判断 3 次。</p>\n<h2 id=\"test-命令\" tabindex=\"-1\"> test 命令</h2>\n<p><code>if</code> 结构的判断条件，一般使用 <code>test</code> 命令，有三种形式。</p>\n<div><pre><code><span># 写法一</span>\n<span>test</span> expression\n\n<span># 写法二</span>\n<span>[</span> expression <span>]</span>\n\n<span># 写法三</span>\n<span>[</span><span>[</span> expression <span>]</span><span>]</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面三种形式是等价的，但是第三种形式还支持正则判断，前两种不支持。</p>\n<p>上面的 <code>expression</code> 是一个表达式。这个表达式为真，<code>test</code> 命令执行成功(返回值为 <code>0</code>)；表达式为伪，<code>test</code> 命令执行失败(返回值为 <code>1</code>)。注意，第二种和第三种写法，<code>[</code> 和 <code>]</code> 与内部的表达式之间必须有空格。</p>\n<div><pre><code>$ <span>test</span> -f /etc/hosts\n$ <span>echo</span> <span>$?</span>\n<span>0</span>\n\n$ <span>[</span> -f /etc/hosts <span>]</span>\n$  <span>echo</span> <span>$?</span>\n<span>0</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面的例子中，<code>test</code> 命令采用两种写法，判断 <code>/etc/hosts</code> 文件是否存在，这两种写法是等价的。命令执行后，返回值为 <code>0</code>，表示该文件确实存在。</p>\n<p>实际上，<code>[</code> 这个字符是 <code>test</code> 命令的一种简写形式，可以看作是一个独立的命令，这解释了为什么它后面必须有空格。</p>\n<p>下面把 <code>test</code> 命令的三种形式，用在 <code>if</code> 结构中，判断一个文件是否存在。</p>\n<div><pre><code><span># 写法一</span>\n<span>if</span> <span>test</span> -e /tmp/foo.txt <span>;</span> <span>then</span>\n  <span>echo</span> <span>\"Found foo.txt\"</span>\n<span>fi</span>\n\n<span># 写法二</span>\n<span>if</span> <span>[</span> -e /tmp/foo.txt <span>]</span> <span>;</span> <span>then</span>\n  <span>echo</span> <span>\"Found foo.txt\"</span>\n<span>fi</span>\n\n<span># 写法三</span>\n<span>if</span> <span>[</span><span>[</span> -e /tmp/foo.txt <span>]</span><span>]</span> <span>;</span> <span>then</span>\n  <span>echo</span> <span>\"Found foo.txt\"</span>\n<span>fi</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id=\"判断表达式\" tabindex=\"-1\"> 判断表达式</h2>\n<p><code>if</code> 关键字后面，跟的是一个命令。这个命令可以是 <code>test</code> 命令，也可以是其他命令。命令的返回值为 <code>0</code> 表示判断成立，否则表示不成立。因为这些命令主要是为了得到返回值，所以可以视为表达式。</p>\n<p>常用的判断表达式有下面这些。</p>\n<h3 id=\"文件判断\" tabindex=\"-1\"> 文件判断</h3>\n<p>以下表达式用来判断文件状态。</p>\n<ul>\n<li><code>[ -a file ]</code>: 如果 file 存在，则为 <code>true</code>。</li>\n<li><code>[ -b file ]</code>: 如果 file 存在并且是一个块(设备)文件，则为 <code>true</code>。</li>\n<li><code>[ -c file ]</code>: 如果 file 存在并且是一个字符(设备)文件，则为 <code>true</code>。</li>\n<li><code>[ -d file ]</code>: 如果 file 存在并且是一个目录，则为 <code>true</code>。</li>\n<li><code>[ -e file ]</code>: 如果 file 存在，则为 <code>true</code>。</li>\n<li><code>[ -f file ]</code>: 如果 file 存在并且是一个普通文件，则为 <code>true</code>。</li>\n<li><code>[ -g file ]</code>: 如果 file 存在并且设置了组 ID，则为 <code>true</code>。</li>\n<li><code>[ -G file ]</code>: 如果 file 存在并且属于有效的组 ID，则为 <code>true</code>。</li>\n<li><code>[ -h file ]</code>: 如果 file 存在并且是符号链接，则为 <code>true</code>。</li>\n<li><code>[ -k file ]</code>: 如果 file 存在并且设置了它的“sticky bit”，则为 <code>true</code>。</li>\n<li><code>[ -L file ]</code>: 如果 file 存在并且是一个符号链接，则为 <code>true</code>。</li>\n<li><code>[ -N file ]</code>: 如果 file 存在并且自上次读取后已被修改，则为 <code>true</code>。</li>\n<li><code>[ -O file ]</code>: 如果 file 存在并且属于有效的用户 ID，则为 <code>true</code>。</li>\n<li><code>[ -p file ]</code>: 如果 file 存在并且是一个命名管道，则为 <code>true</code>。</li>\n<li><code>[ -r file ]</code>: 如果 file 存在并且可读(当前用户有可读权限)，则为 <code>true</code>。</li>\n<li><code>[ -s file ]</code>: 如果 file 存在且其长度大于零，则为 <code>true</code>。</li>\n<li><code>[ -S file ]</code>: 如果 file 存在且是一个网络 socket，则为 <code>true</code>。</li>\n<li><code>[ -t fd ]</code>: 如果 fd 是一个文件描述符，并且重定向到终端，则为 <code>true</code>。这可以用来判断是否重定向了标准输入／输出错误。</li>\n<li><code>[ -u file ]</code>: 如果 file 存在并且设置了 setuid 位，则为 <code>true</code>。</li>\n<li><code>[ -w file ]</code>: 如果 file 存在并且可写(当前用户拥有可写权限)，则为 <code>true</code>。</li>\n<li><code>[ -x file ]</code>: 如果 file 存在并且可执行(有效用户有执行／搜索权限)，则为 <code>true</code>。</li>\n<li><code>[ file1 -nt file2 ]</code>: 如果 FILE1 比 FILE2 的更新时间最近，或者 FILE1 存在而 FILE2 不存在，则为 <code>true</code>。</li>\n<li><code>[ file1 -ot file2 ]</code>: 如果 FILE1 比 FILE2 的更新时间更旧，或者 FILE2 存在而 FILE1 不存在，则为 <code>true</code>。</li>\n<li><code>[ FILE1 -ef FILE2 ]</code>: 如果 FILE1 和 FILE2 引用相同的设备和 inode 编号，则为 <code>true</code>。</li>\n</ul>\n<p>下面是一个示例。</p>\n<div><pre><code><span>#!/bin/bash</span>\n\n<span>FILE</span><span>=~</span>/.bashrc\n\n<span>if</span> <span>[</span> -e <span>\"<span>$FILE</span>\"</span> <span>]</span><span>;</span> <span>then</span>\n  <span>if</span> <span>[</span> -f <span>\"<span>$FILE</span>\"</span> <span>]</span><span>;</span> <span>then</span>\n    <span>echo</span> <span>\"<span>$FILE</span> is a regular file.\"</span>\n  <span>fi</span>\n  <span>if</span> <span>[</span> -d <span>\"<span>$FILE</span>\"</span> <span>]</span><span>;</span> <span>then</span>\n    <span>echo</span> <span>\"<span>$FILE</span> is a directory.\"</span>\n  <span>fi</span>\n  <span>if</span> <span>[</span> -r <span>\"<span>$FILE</span>\"</span> <span>]</span><span>;</span> <span>then</span>\n    <span>echo</span> <span>\"<span>$FILE</span> is readable.\"</span>\n  <span>fi</span>\n  <span>if</span> <span>[</span> -w <span>\"<span>$FILE</span>\"</span> <span>]</span><span>;</span> <span>then</span>\n    <span>echo</span> <span>\"<span>$FILE</span> is writable.\"</span>\n  <span>fi</span>\n  <span>if</span> <span>[</span> -x <span>\"<span>$FILE</span>\"</span> <span>]</span><span>;</span> <span>then</span>\n    <span>echo</span> <span>\"<span>$FILE</span> is executable/searchable.\"</span>\n  <span>fi</span>\n<span>else</span>\n  <span>echo</span> <span>\"<span>$FILE</span> does not exist\"</span>\n  <span>exit</span> <span>1</span>\n<span>fi</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面代码中，<code>$FILE</code> 要放在双引号之中。这样可以防止 <code>$FILE</code> 为空，因为这时 <code>[ -e ]</code> 会判断为真。而放在双引号之中，返回的就总是一个空字符串，<code>[ -e &quot;&quot; ]</code> 会判断为伪。</p>\n<h3 id=\"字符串判断\" tabindex=\"-1\"> 字符串判断</h3>\n<p>以下表达式用来判断字符串。</p>\n<ul>\n<li><code>[ string ]</code>: 如果 <code>string</code> 不为空(长度大于 0)，则判断为真。</li>\n<li><code>[ -n string ]</code>: 如果字符串 <code>string</code> 的长度大于零，则判断为真。</li>\n<li><code>[ -z string ]</code>: 如果字符串 <code>string</code> 的长度为零，则判断为真。</li>\n<li><code>[ string1 = string2 ]</code>: 如果 <code>string1</code> 和 <code>string2</code> 相同，则判断为真。</li>\n<li><code>[ string1 == string2 ]</code> 等同于 <code>[ string1 = string2 ]</code>。</li>\n<li><code>[ string1 != string2 ]</code>: 如果 <code>string1</code> 和 <code>string2</code> 不相同，则判断为真。</li>\n<li><code>[ string1 '&gt;' string2 ]</code>: 如果按照字典顺序 <code>string1</code> 排列在 <code>string2</code> 之后，则判断为真。</li>\n<li><code>[ string1 '&lt;' string2 ]</code>: 如果按照字典顺序 <code>string1</code> 排列在 <code>string2</code> 之前，则判断为真。</li>\n</ul>\n<p>注意，<code>test</code> 命令内部的 <code>&gt;</code> 和 <code>&lt;</code>，必须用引号引起来(或者是用反斜杠转义)。否则，它们会被 shell 解释为重定向操作符。</p>\n<p>下面是一个示例。</p>\n<div><pre><code><span>#!/bin/bash</span>\n\n<span>ANSWER</span><span>=</span>maybe\n\n<span>if</span> <span>[</span> -z <span>\"<span>$ANSWER</span>\"</span> <span>]</span><span>;</span> <span>then</span>\n  <span>echo</span> <span>\"There is no answer.\"</span> <span>></span><span>&amp;2</span>\n  <span>exit</span> <span>1</span>\n<span>fi</span>\n<span>if</span> <span>[</span> <span>\"<span>$ANSWER</span>\"</span> <span>=</span> <span>\"yes\"</span> <span>]</span><span>;</span> <span>then</span>\n  <span>echo</span> <span>\"The answer is YES.\"</span>\n<span>elif</span> <span>[</span> <span>\"<span>$ANSWER</span>\"</span> <span>=</span> <span>\"no\"</span> <span>]</span><span>;</span> <span>then</span>\n  <span>echo</span> <span>\"The answer is NO.\"</span>\n<span>elif</span> <span>[</span> <span>\"<span>$ANSWER</span>\"</span> <span>=</span> <span>\"maybe\"</span> <span>]</span><span>;</span> <span>then</span>\n  <span>echo</span> <span>\"The answer is MAYBE.\"</span>\n<span>else</span>\n  <span>echo</span> <span>\"The answer is UNKNOWN.\"</span>\n<span>fi</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面代码中，首先确定 <code>$ANSWER</code> 字符串是否为空。如果为空，就终止脚本，并把退出状态设为 <code>1</code>。注意，这里的 <code>echo</code> 命令把错误信息 <code>There is no answer.</code> 重定向到标准错误，这是处理错误信息的常用方法。如果 <code>$ANSWER</code> 字符串不为空，就判断它的值是否等于 <code>yes</code>、<code>no</code> 或者 <code>maybe</code>。</p>\n<p>注意，字符串判断时，变量要放在双引号之中，比如 <code>[ -n &quot;$COUNT&quot; ]</code>，否则变量替换成字符串以后，<code>test</code> 命令可能会报错，提示参数过多。另外，如果不放在双引号之中，变量为空时，命令会变成 <code>[ -n ]</code>，这时会判断为真。如果放在双引号之中，<code>[ -n &quot;&quot; ]</code> 就判断为伪。</p>\n<h3 id=\"整数判断\" tabindex=\"-1\"> 整数判断</h3>\n<p>下面的表达式用于判断整数。</p>\n<ul>\n<li><code>[ integer1 -eq integer2 ]</code>: 如果 <code>integer1</code> 等于 <code>integer2</code>，则为 <code>true</code>。</li>\n<li><code>[ integer1 -ne integer2 ]</code>: 如果 <code>integer1</code> 不等于 <code>integer2</code>，则为 <code>true</code>。</li>\n<li><code>[ integer1 -le integer2 ]</code>: 如果 <code>integer1</code> 小于或等于 <code>integer2</code>，则为 <code>true</code>。</li>\n<li><code>[ integer1 -lt integer2 ]</code>: 如果 <code>integer1</code> 小于 <code>integer2</code>，则为 <code>true</code>。</li>\n<li><code>[ integer1 -ge integer2 ]</code>: 如果 <code>integer1</code> 大于或等于 <code>integer2</code>，则为 <code>true</code>。</li>\n<li><code>[ integer1 -gt integer2 ]</code>: 如果 <code>integer1</code> 大于 <code>integer2</code>，则为 <code>true</code>。</li>\n</ul>\n<p>下面是一个用法的例子。</p>\n<div><pre><code><span>#!/bin/bash</span>\n\n<span>INT</span><span>=</span>-5\n\n<span>if</span> <span>[</span> -z <span>\"<span>$INT</span>\"</span> <span>]</span><span>;</span> <span>then</span>\n  <span>echo</span> <span>\"INT is empty.\"</span> <span>></span><span>&amp;2</span>\n  <span>exit</span> <span>1</span>\n<span>fi</span>\n<span>if</span> <span>[</span> <span>$INT</span> -eq <span>0</span> <span>]</span><span>;</span> <span>then</span>\n  <span>echo</span> <span>\"INT is zero.\"</span>\n<span>else</span>\n  <span>if</span> <span>[</span> <span>$INT</span> -lt <span>0</span> <span>]</span><span>;</span> <span>then</span>\n    <span>echo</span> <span>\"INT is negative.\"</span>\n  <span>else</span>\n    <span>echo</span> <span>\"INT is positive.\"</span>\n  <span>fi</span>\n  <span>if</span> <span>[</span> <span><span>$((</span>INT <span>%</span> <span>2</span><span>))</span></span> -eq <span>0</span> <span>]</span><span>;</span> <span>then</span>\n    <span>echo</span> <span>\"INT is even.\"</span>\n  <span>else</span>\n    <span>echo</span> <span>\"INT is odd.\"</span>\n  <span>fi</span>\n<span>fi</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面例子中，先判断变量 <code>$INT</code> 是否为空，然后判断是否为 <code>0</code>，接着判断正负，最后通过求余数判断奇偶。</p>\n<h3 id=\"正则判断\" tabindex=\"-1\"> 正则判断</h3>\n<p><code>[[ expression ]]</code> 这种判断形式，支持正则表达式。</p>\n<div><pre><code><span>[</span><span>[</span> string1 <span>=~</span> regex <span>]</span><span>]</span>\n</code></pre><div aria-hidden=\"true\"><div></div></div></div><p>上面的语法中，<code>regex</code> 是一个正则表示式，<code>=~</code> 是正则比较运算符。</p>\n<p>下面是一个例子。</p>\n<div><pre><code><span>#!/bin/bash</span>\n\n<span>INT</span><span>=</span>-5\n\n<span>if</span> <span>[</span><span>[</span> <span>\"<span>$INT</span>\"</span> <span>=~</span> ^-?<span>[</span><span>0</span>-9<span>]</span>+$ <span>]</span><span>]</span><span>;</span> <span>then</span>\n  <span>echo</span> <span>\"INT is an integer.\"</span>\n  <span>exit</span> <span>0</span>\n<span>else</span>\n  <span>echo</span> <span>\"INT is not an integer.\"</span> <span>></span><span>&amp;2</span>\n  <span>exit</span> <span>1</span>\n<span>fi</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面代码中，先判断变量 <code>INT</code> 的字符串形式，是否满足 <code>^-?[0-9]+$</code> 的正则模式，如果满足就表明它是一个整数。</p>\n<h3 id=\"test-判断的逻辑运算\" tabindex=\"-1\"> test 判断的逻辑运算</h3>\n<p>通过逻辑运算，可以把多个 <code>test</code> 判断表达式结合起来，创造更复杂的判断。三种逻辑运算 <code>AND</code>，<code>OR</code>，和 <code>NOT</code>，都有自己的专用符号。</p>\n<ul>\n<li><code>AND</code> 运算: 符号 <code>&amp;&amp;</code>，也可使用参数 <code>-a</code>。</li>\n<li><code>OR</code> 运算: 符号 <code>||</code>，也可使用参数 <code>-o</code>。</li>\n<li><code>NOT</code> 运算: 符号 <code>!</code>。</li>\n</ul>\n<p>下面是一个 <code>AND</code> 的例子，判断整数是否在某个范围之内。</p>\n<div><pre><code><span>#!/bin/bash</span>\n\n<span>MIN_VAL</span><span>=</span><span>1</span>\n<span>MAX_VAL</span><span>=</span><span>100</span>\n\n<span>INT</span><span>=</span><span>50</span>\n\n<span>if</span> <span>[</span><span>[</span> <span>\"<span>$INT</span>\"</span> <span>=~</span> ^-?<span>[</span><span>0</span>-9<span>]</span>+$ <span>]</span><span>]</span><span>;</span> <span>then</span>\n  <span>if</span> <span>[</span><span>[</span> <span>$INT</span> -ge <span>$MIN_VAL</span> <span>&amp;&amp;</span> <span>$INT</span> -le <span>$MAX_VAL</span> <span>]</span><span>]</span><span>;</span> <span>then</span>\n    <span>echo</span> <span>\"<span>$INT</span> is within <span>$MIN_VAL</span> to <span>$MAX_VAL</span>.\"</span>\n  <span>else</span>\n    <span>echo</span> <span>\"<span>$INT</span> is out of range.\"</span>\n  <span>fi</span>\n<span>else</span>\n  <span>echo</span> <span>\"INT is not an integer.\"</span> <span>></span><span>&amp;2</span>\n  <span>exit</span> <span>1</span>\n<span>fi</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面例子中，<code>&amp;&amp;</code> 用来连接两个判断条件: 大于等于 <code>$MIN_VAL</code>，并且小于等于 <code>$MAX_VAL</code>。</p>\n<p>使用否定操作符 <code>!</code> 时，最好用圆括号确定转义的范围。</p>\n<div><pre><code><span>if</span> <span>[</span> <span>!</span> <span>\\</span><span>(</span> <span>$INT</span> -ge <span>$MIN_VAL</span> -a <span>$INT</span> -le <span>$MAX_VAL</span> <span>\\</span><span>)</span> <span>]</span><span>;</span> <span>then</span>\n    <span>echo</span> <span>\"<span>$INT</span> is outside <span>$MIN_VAL</span> to <span>$MAX_VAL</span>.\"</span>\n<span>else</span>\n    <span>echo</span> <span>\"<span>$INT</span> is in range.\"</span>\n<span>fi</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div></div></div><p>上面例子中，<code>test</code> 命令内部使用的圆括号，必须使用引号或者转义，否则会被 Bash 解释。</p>\n<h3 id=\"算术判断\" tabindex=\"-1\"> 算术判断</h3>\n<p>Bash 还提供了 <code>((...))</code> 作为算术条件，进行算术运算的判断。</p>\n<div><pre><code><span>if</span> <span><span>((</span><span>3</span> <span>></span> <span>2</span><span>))</span></span><span>;</span> <span>then</span>\n  <span>echo</span> <span>\"true\"</span>\n<span>fi</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div></div></div><p>上面代码执行后，会打印出 <code>true</code>。</p>\n<p>注意，算术判断不需要使用 <code>test</code> 命令，而是直接使用 <code>((...))</code> 结构。这个结构的返回值，决定了判断的真伪。</p>\n<p>如果算术计算的结果是非零值，则表示判断成立。这一点跟命令的返回值正好相反，需要小心。</p>\n<div><pre><code>$ <span>if</span> <span><span>((</span><span>1</span><span>))</span></span><span>;</span> <span>then</span> <span>echo</span> <span>\"It is true.\"</span><span>;</span> <span>fi</span>\nIt is true.\n$ <span>if</span> <span><span>((</span><span>0</span><span>))</span></span><span>;</span> <span>then</span> <span>echo</span> <span>\"It is true.\"</span><span>;</span> <span>else</span> <span>echo</span> <span>\"it is false.\"</span><span>;</span> <span>fi</span>\nIt is false.\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div></div></div><p>上面例子中，<code>((1))</code> 表示判断成立，<code>((0))</code> 表示判断不成立。</p>\n<p>算术条件 <code>((...))</code> 也可以用于变量赋值。</p>\n<div><pre><code>$ <span>if</span> <span><span>((</span> foo <span>=</span> <span>5</span> <span>))</span></span><span>;</span><span>then</span> <span>echo</span> <span>\"foo is <span>$foo</span>\"</span><span>;</span> <span>fi</span>\nfoo is <span>5</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div></div></div><p>上面例子中，<code>(( foo = 5 ))</code> 完成了两件事情。首先把 <code>5</code> 赋值给变量 <code>foo</code>，然后根据返回值 <code>5</code>，判断条件为真。</p>\n<p>注意，赋值语句返回等号右边的值，如果返回的是 <code>0</code>，则判断为假。</p>\n<div><pre><code>$ <span>if</span> <span><span>((</span> foo <span>=</span> <span>0</span> <span>))</span></span><span>;</span><span>then</span> <span>echo</span> <span>\"It is true.\"</span><span>;</span><span>else</span> <span>echo</span> <span>\"It is false.\"</span><span>;</span> <span>fi</span>\nIt is false.\n</code></pre><div aria-hidden=\"true\"><div></div><div></div></div></div><p>下面是用算术条件改写的数值判断脚本。</p>\n<div><pre><code><span>#!/bin/bash</span>\n\n<span>INT</span><span>=</span>-5\n\n<span>if</span> <span>[</span><span>[</span> <span>\"<span>$INT</span>\"</span> <span>=~</span> ^-?<span>[</span><span>0</span>-9<span>]</span>+$ <span>]</span><span>]</span><span>;</span> <span>then</span>\n  <span>if</span> <span><span>((</span>INT <span>==</span> <span>0</span><span>))</span></span><span>;</span> <span>then</span>\n    <span>echo</span> <span>\"INT is zero.\"</span>\n  <span>else</span>\n    <span>if</span> <span><span>((</span>INT <span>&lt;</span> <span>0</span><span>))</span></span><span>;</span> <span>then</span>\n      <span>echo</span> <span>\"INT is negative.\"</span>\n    <span>else</span>\n      <span>echo</span> <span>\"INT is positive.\"</span>\n    <span>fi</span>\n    <span>if</span> <span><span>((</span> <span>((</span>INT <span>%</span> <span>2</span><span>))</span></span> <span>==</span> <span>0</span><span>))</span><span>;</span> <span>then</span>\n      <span>echo</span> <span>\"INT is even.\"</span>\n    <span>else</span>\n      <span>echo</span> <span>\"INT is odd.\"</span>\n    <span>fi</span>\n  <span>fi</span>\n<span>else</span>\n  <span>echo</span> <span>\"INT is not an integer.\"</span> <span>></span><span>&amp;2</span>\n  <span>exit</span> <span>1</span>\n<span>fi</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>只要是算术表达式，都能用于 <code>((...))</code> 语法，详见 <a href=\"/linux/bash/arithmetic.html\">Bash 的算术运算</a> 一章。</p>\n<h3 id=\"普通命令的逻辑运算\" tabindex=\"-1\"> 普通命令的逻辑运算</h3>\n<p>如果 <code>if</code> 结构使用的不是 <code>test</code> 命令，而是普通命令，比如上一节的 <code>((...))</code> 算术运算，或者 <code>test</code> 命令与普通命令混用，那么可以使用 Bash 的命令控制操作符 <code>&amp;&amp;</code>(AND)和 <code>||</code>(OR)，进行多个命令的逻辑运算。</p>\n<div><pre><code>command1 <span>&amp;&amp;</span> command2\ncommand1 <span>||</span> command2\n</code></pre><div aria-hidden=\"true\"><div></div><div></div></div></div><p>对于 <code>&amp;&amp;</code> 操作符，先执行 <code>command1</code>，只有 <code>command1</code> 执行成功后， 才会执行 <code>command2</code>。对于 <code>||</code> 操作符，先执行 <code>command1</code>，只有 <code>command1</code> 执行失败后， 才会执行 <code>command2</code>。</p>\n<div><pre><code><span>mkdir</span> temp <span>&amp;&amp;</span> <span>cd</span> temp\n</code></pre><div aria-hidden=\"true\"><div></div></div></div><p>上面的命令会创建一个名为 <code>temp</code> 的目录，执行成功后，才会执行第二个命令，进入这个目录。</p>\n<div><pre><code><span>[</span> -d temp <span>]</span> <span>||</span> <span>mkdir</span> temp\n</code></pre><div aria-hidden=\"true\"><div></div></div></div><p>上面的命令会测试目录 <code>temp</code> 是否存在，如果不存在，就会执行第二个命令，创建这个目录。这种写法非常有助于在脚本中处理错误。</p>\n<div><pre><code><span>[</span> <span>!</span> -d temp <span>]</span> <span>&amp;&amp;</span> <span>exit</span> <span>1</span>\n</code></pre><div aria-hidden=\"true\"><div></div></div></div><p>上面的命令中，如果 <code>temp</code> 子目录不存在，脚本会终止，并且返回值为 <code>1</code>。</p>\n<p>下面就是 <code>if</code> 与 <code>&amp;&amp;</code> 结合使用的写法。</p>\n<div><pre><code><span>if</span> <span>[</span> condition <span>]</span> <span>&amp;&amp;</span> <span>[</span> condition <span>]</span><span>;</span> <span>then</span>\n  <span>command</span>\n<span>fi</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div></div></div><p>下面是一个示例。</p>\n<div><pre><code><span>#! /bin/bash</span>\n\n<span>filename</span><span>=</span><span>$1</span>\n<span>word1</span><span>=</span><span>$2</span>\n<span>word2</span><span>=</span><span>$3</span>\n\n<span>if</span> <span>grep</span> <span>$word1</span> <span>$filename</span> <span>&amp;&amp;</span> <span>grep</span> <span>$word2</span> <span>$filename</span>\n<span>then</span>\n  <span>echo</span> <span>\"<span>$word1</span> and <span>$word2</span> are both in <span>$filename</span>.\"</span>\n<span>fi</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面的例子只有在指定文件里面，同时存在搜索词 <code>word1</code> 和 <code>word2</code>，就会执行 <code>if</code> 的命令部分。</p>\n<p>下面的示例演示如何将一个 <code>&amp;&amp;</code> 判断表达式，改写成对应的 <code>if</code> 结构。</p>\n<div><pre><code><span>[</span><span>[</span> -d <span>\"<span>$dir_name</span>\"</span> <span>]</span><span>]</span> <span>&amp;&amp;</span> <span>cd</span> <span>\"<span>$dir_name</span>\"</span> <span>&amp;&amp;</span> <span>rm</span> *\n\n<span># 等同于</span>\n\n<span>if</span> <span>[</span><span>[</span> <span>!</span> -d <span>\"<span>$dir_name</span>\"</span> <span>]</span><span>]</span><span>;</span> <span>then</span>\n  <span>echo</span> <span>\"No such directory: '<span>$dir_name</span>'\"</span> <span>></span><span>&amp;2</span>\n  <span>exit</span> <span>1</span>\n<span>fi</span>\n<span>if</span> <span>!</span> <span>cd</span> <span>\"<span>$dir_name</span>\"</span><span>;</span> <span>then</span>\n  <span>echo</span> <span>\"Cannot cd to '<span>$dir_name</span>'\"</span> <span>></span><span>&amp;2</span>\n  <span>exit</span> <span>1</span>\n<span>fi</span>\n<span>if</span> <span>!</span> <span>rm</span> *<span>;</span> <span>then</span>\n  <span>echo</span> <span>\"File deletion failed. Check results\"</span> <span>></span><span>&amp;2</span>\n  <span>exit</span> <span>1</span>\n<span>fi</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id=\"case-结构\" tabindex=\"-1\"> case 结构</h2>\n<p><code>case</code> 结构用于多值判断，可以为每个值指定对应的命令，跟包含多个 <code>elif</code> 的 <code>if</code> 结构等价，但是语义更好。它的语法如下。</p>\n<div><pre><code><span>case</span> expression <span>in</span>\n  pattern <span>)</span>\n    commands <span>;</span><span>;</span>\n  pattern <span>)</span>\n    commands <span>;</span><span>;</span>\n  <span>..</span>.\n<span>esac</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面代码中，<code>expression</code> 是一个表达式，<code>pattern</code> 是表达式的值或者一个模式，可以有多条，用来匹配多个值，每条以两个分号 (<code>;</code>) 结尾。</p>\n<div><pre><code><span>#!/bin/bash</span>\n\n<span>echo</span> -n <span>\"输入一个 1 到 3 之间的数字(包含两端)> \"</span>\n<span>read</span> character\n<span>case</span> <span>$character</span> <span>in</span>\n  <span>1</span> <span>)</span> <span>echo</span> <span>1</span>\n    <span>;</span><span>;</span>\n  <span>2</span> <span>)</span> <span>echo</span> <span>2</span>\n    <span>;</span><span>;</span>\n  <span>3</span> <span>)</span> <span>echo</span> <span>3</span>\n    <span>;</span><span>;</span>\n  * <span>)</span> <span>echo</span> 输入不符合要求\n<span>esac</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面例子中，最后一条匹配语句的模式是 <code>*</code>，这个通配符可以匹配其他字符和没有输入字符的情况，类似 <code>if</code> 的 <code>else</code> 部分。</p>\n<p>下面是另一个例子。</p>\n<div><pre><code><span>#!/bin/bash</span>\n\n<span>OS</span><span>=</span><span><span>$(</span><span>uname</span> -s<span>)</span></span>\n\n<span>case</span> <span>\"<span>$OS</span>\"</span> <span>in</span>\n  FreeBSD<span>)</span> <span>echo</span> <span>\"This is FreeBSD\"</span> <span>;</span><span>;</span>\n  Darwin<span>)</span> <span>echo</span> <span>\"This is Mac OSX\"</span> <span>;</span><span>;</span>\n  AIX<span>)</span> <span>echo</span> <span>\"This is AIX\"</span> <span>;</span><span>;</span>\n  Minix<span>)</span> <span>echo</span> <span>\"This is Minix\"</span> <span>;</span><span>;</span>\n  Linux<span>)</span> <span>echo</span> <span>\"This is Linux\"</span> <span>;</span><span>;</span>\n  *<span>)</span> <span>echo</span> <span>\"Failed to identify this OS\"</span> <span>;</span><span>;</span>\n<span>esac</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面的例子判断当前是什么操作系统。</p>\n<p><code>case</code> 的匹配模式可以使用各种通配符，下面是一些例子。</p>\n<ul>\n<li><code>a)</code>: 匹配 <code>a</code>。</li>\n<li><code>a|b)</code>: 匹配 <code>a</code> 或 <code>b</code>。</li>\n<li><code>[[:alpha:]])</code>: 匹配单个字母。</li>\n<li><code>???)</code>: 匹配 3 个字符的单词。</li>\n<li><code>*.txt)</code>: 匹配 <code>.txt</code> 结尾。</li>\n<li><code>*)</code>: 匹配任意输入，通过作为 <code>case</code> 结构的最后一个模式。</li>\n</ul>\n<div><pre><code><span>#!/bin/bash</span>\n\n<span>echo</span> -n <span>\"输入一个字母或数字 > \"</span>\n<span>read</span> character\n<span>case</span> <span>$character</span> <span>in</span>\n  <span>[</span><span>[</span>:lower:<span>]</span><span>]</span> <span>|</span> <span>[</span><span>[</span>:upper:<span>]</span><span>]</span> <span>)</span> <span>echo</span> <span>\"输入了字母 <span>$character</span>\"</span>\n                              <span>;</span><span>;</span>\n  <span>[</span><span>0</span>-9<span>]</span> <span>)</span>                     <span>echo</span> <span>\"输入了数字 <span>$character</span>\"</span>\n                              <span>;</span><span>;</span>\n  * <span>)</span>                         <span>echo</span> <span>\"输入不符合要求\"</span>\n<span>esac</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面例子中，使用通配符 <code>[[:lower:]] | [[:upper:]]</code> 匹配字母，<code>[0-9]</code> 匹配数字。</p>\n<p>Bash 4.0 之前，<code>case</code> 结构只能匹配一个条件，然后就会退出 <code>case</code> 结构。Bash 4.0 之后，允许匹配多个条件，这时可以用 <code>;;&amp;</code> 终止每个条件块。</p>\n<div><pre><code><span>#!/bin/bash</span>\n<span># test.sh</span>\n\n<span>read</span> -n <span>1</span> -p <span>\"Type a character > \"</span>\n<span>echo</span>\n<span>case</span> <span>$REPLY</span> <span>in</span>\n  <span>[</span><span>[</span>:upper:<span>]</span><span>]</span><span>)</span>    <span>echo</span> <span>\"'<span>$REPLY</span>' is upper case.\"</span> <span>;</span><span>;</span><span>&amp;</span>\n  <span>[</span><span>[</span>:lower:<span>]</span><span>]</span><span>)</span>    <span>echo</span> <span>\"'<span>$REPLY</span>' is lower case.\"</span> <span>;</span><span>;</span><span>&amp;</span>\n  <span>[</span><span>[</span>:alpha:<span>]</span><span>]</span><span>)</span>    <span>echo</span> <span>\"'<span>$REPLY</span>' is alphabetic.\"</span> <span>;</span><span>;</span><span>&amp;</span>\n  <span>[</span><span>[</span>:digit:<span>]</span><span>]</span><span>)</span>    <span>echo</span> <span>\"'<span>$REPLY</span>' is a digit.\"</span> <span>;</span><span>;</span><span>&amp;</span>\n  <span>[</span><span>[</span>:graph:<span>]</span><span>]</span><span>)</span>    <span>echo</span> <span>\"'<span>$REPLY</span>' is a visible character.\"</span> <span>;</span><span>;</span><span>&amp;</span>\n  <span>[</span><span>[</span>:punct:<span>]</span><span>]</span><span>)</span>    <span>echo</span> <span>\"'<span>$REPLY</span>' is a punctuation symbol.\"</span> <span>;</span><span>;</span><span>&amp;</span>\n  <span>[</span><span>[</span>:space:<span>]</span><span>]</span><span>)</span>    <span>echo</span> <span>\"'<span>$REPLY</span>' is a whitespace character.\"</span> <span>;</span><span>;</span><span>&amp;</span>\n  <span>[</span><span>[</span>:xdigit:<span>]</span><span>]</span><span>)</span>   <span>echo</span> <span>\"'<span>$REPLY</span>' is a hexadecimal digit.\"</span> <span>;</span><span>;</span><span>&amp;</span>\n<span>esac</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>执行上面的脚本，会得到下面的结果。</p>\n<div><pre><code>$ test.sh\nType a character <span>></span> a\n<span>'a'</span> is lower case.\n<span>'a'</span> is alphabetic.\n<span>'a'</span> is a visible character.\n<span>'a'</span> is a hexadecimal digit.\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>可以看到条件语句结尾添加了 <code>;;&amp;</code> 以后，在匹配一个条件之后，并没有退出 <code>case</code> 结构，而是继续判断下一个条件。</p>\n<h2 id=\"参考链接\" tabindex=\"-1\"> 参考链接</h2>\n<ul>\n<li><a href=\"http://linuxcommand.org/tlcl.php\" target=\"_blank\" rel=\"noopener noreferrer\">The Linux command-line</a>, William Shotts</li>\n<li><a href=\"https://www.pcwdld.com/linux-commands-cheat-sheet\" target=\"_blank\" rel=\"noopener noreferrer\">Linux Commands Cheat Sheet</a> (一个很简短的 CheatSheet)</li>\n</ul>\n",
      "date_published": "2022-08-20T08:54:00.000Z",
      "date_modified": "2022-08-20T08:54:00.000Z",
      "authors": [
        {
          "name": "阮一峰"
        }
      ],
      "tags": [
        "Linux"
      ]
    },
    {
      "title": "脚本除错",
      "url": "https://github.com/MisterChen9527/linux/bash/debug.html",
      "id": "https://github.com/MisterChen9527/linux/bash/debug.html",
      "summary": "本章介绍如何对 Shell 脚本除错。\n",
      "content_html": "<p>本章介绍如何对 Shell 脚本除错。</p>\n\n<h2 id=\"常见错误\" tabindex=\"-1\"> 常见错误</h2>\n<p>编写 Shell 脚本的时候，一定要考虑到命令失败的情况，否则很容易出错。</p>\n<div><pre><code><span>#! /bin/bash</span>\n\n<span>dir_name</span><span>=</span>/path/not/exist\n\n<span>cd</span> <span>$dir_name</span>\n<span>rm</span> *\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面脚本中，如果目录 <code>$dir_name</code> 不存在，<code>cd $dir_name</code> 命令就会执行失败。这时，就不会改变当前目录，脚本会继续执行下去，导致 <code>rm *</code> 命令删光当前目录的文件。</p>\n<p>如果改成下面的样子，也会有问题。</p>\n<div><pre><code><span>cd</span> <span>$dir_name</span> <span>&amp;&amp;</span> <span>rm</span> *\n</code></pre><div aria-hidden=\"true\"><div></div></div></div><p>上面脚本中，只有 <code>cd $dir_name</code> 执行成功，才会执行 <code>rm *</code>。但是，如果变量 <code>$dir_name</code> 为空，<code>cd</code> 就会进入用户主目录，从而删光用户主目录的文件。</p>\n<p>下面的写法才是正确的。</p>\n<div><pre><code><span>[</span><span>[</span> -d <span>$dir_name</span> <span>]</span><span>]</span> <span>&amp;&amp;</span> <span>cd</span> <span>$dir_name</span> <span>&amp;&amp;</span> <span>rm</span> *\n</code></pre><div aria-hidden=\"true\"><div></div></div></div><p>上面代码中，先判断目录 <code>$dir_name</code> 是否存在，然后才执行其他操作。</p>\n<p>如果不放心删除什么文件，可以先打印出来看一下。</p>\n<div><pre><code><span>[</span><span>[</span> -d <span>$dir_name</span> <span>]</span><span>]</span> <span>&amp;&amp;</span> <span>cd</span> <span>$dir_name</span> <span>&amp;&amp;</span> <span>echo</span> <span>rm</span> *\n</code></pre><div aria-hidden=\"true\"><div></div></div></div><p>上面命令中，<code>echo rm *</code> 不会删除文件，只会打印出来要删除的文件。</p>\n<h2 id=\"bash-的-x-参数\" tabindex=\"-1\"> <code>bash</code> 的 <code>-x</code> 参数</h2>\n<p><code>bash</code> 的 <code>-x</code> 参数可以在执行每一行命令之前，打印该命令。这样就不用自己输出执行的命令，一旦出错，比较容易追查。</p>\n<p>下面是一个脚本 <code>script.sh</code>。</p>\n<div><pre><code><span># script.sh</span>\n<span>echo</span> hello world\n</code></pre><div aria-hidden=\"true\"><div></div><div></div></div></div><p>加上 <code>-x</code> 参数，执行每条命令之前，都会显示该命令。</p>\n<div><pre><code>$ <span>bash</span> -x script.sh\n+ <span>echo</span> hello world\nhello world\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div></div></div><p>上面例子中，行首为 <code>+</code> 的行，显示该行是所要执行的命令，下一行才是该命令的执行结果。</p>\n<p>下面再看一个 <code>-x</code> 写在脚本内部的例子。</p>\n<div><pre><code><span>#! /bin/bash -x</span>\n<span># trouble: script to demonstrate common errors</span>\n\n<span>number</span><span>=</span><span>1</span>\n<span>if</span> <span>[</span> <span>$number</span> <span>=</span> <span>1</span> <span>]</span><span>;</span> <span>then</span>\n  <span>echo</span> <span>\"Number is equal to 1.\"</span>\n<span>else</span>\n  <span>echo</span> <span>\"Number is not equal to 1.\"</span>\n<span>fi</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面的脚本执行之后，会输出每一行命令。</p>\n<div><pre><code>$ trouble\n+ <span>number</span><span>=</span><span>1</span>\n+ <span>'['</span> <span>1</span> <span>=</span> <span>1</span> <span>']'</span>\n+ <span>echo</span> <span>'Number is equal to 1.'</span>\nNumber is equal to <span>1</span>.\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div></div></div><p>输出的命令之前的 <code>+</code> 号，是由系统变量 <code>PS4</code> 决定，可以修改这个变量。</p>\n<div><pre><code>$ <span>export</span> <span><span>PS4</span></span><span>=</span><span>'$LINENO + '</span>\n$ trouble\n<span>5</span> + <span>number</span><span>=</span><span>1</span>\n<span>7</span> + <span>'['</span> <span>1</span> <span>=</span> <span>1</span> <span>']'</span>\n<span>8</span> + <span>echo</span> <span>'Number is equal to 1.'</span>\nNumber is equal to <span>1</span>.\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>另外，<code>set</code> 命令也可以设置 Shell 的行为参数，有利于脚本除错，详见 <a href=\"/linux/bash/set.html\">set 命令</a> 一章。</p>\n<h2 id=\"环境变量\" tabindex=\"-1\"> 环境变量</h2>\n<p>有一些环境变量常用于除错。</p>\n<h3 id=\"lineno\" tabindex=\"-1\"> LINENO</h3>\n<p>变量 <code>LINENO</code> 返回它在脚本里面的行号。</p>\n<div><pre><code><span>#!/bin/bash</span>\n\n<span>echo</span> <span>\"This is line <span>$LINENO</span>\"</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div></div></div><p>执行上面的脚本 <code>test.sh</code>，<code>$LINENO</code> 会返回 <code>3</code>。</p>\n<div><pre><code>$ ./test.sh\nThis is line <span>3</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div></div></div><h3 id=\"funcname\" tabindex=\"-1\"> FUNCNAME</h3>\n<p>变量 <code>FUNCNAME</code> 返回一个数组，内容是当前的函数调用堆栈。该数组的 0 号成员是当前调用的函数，1 号成员是调用当前函数的函数，以此类推。</p>\n<div><pre><code><span>#!/bin/bash</span>\n\n<span>function</span> <span>func1</span><span>(</span><span>)</span>\n<span>{</span>\n  <span>echo</span> <span>\"func1: FUNCNAME0 is <span>${FUNCNAME<span>[</span>0<span>]</span>}</span>\"</span>\n  <span>echo</span> <span>\"func1: FUNCNAME1 is <span>${FUNCNAME<span>[</span>1<span>]</span>}</span>\"</span>\n  <span>echo</span> <span>\"func1: FUNCNAME2 is <span>${FUNCNAME<span>[</span>2<span>]</span>}</span>\"</span>\n  func2\n<span>}</span>\n\n<span>function</span> <span>func2</span><span>(</span><span>)</span>\n<span>{</span>\n  <span>echo</span> <span>\"func2: FUNCNAME0 is <span>${FUNCNAME<span>[</span>0<span>]</span>}</span>\"</span>\n  <span>echo</span> <span>\"func2: FUNCNAME1 is <span>${FUNCNAME<span>[</span>1<span>]</span>}</span>\"</span>\n  <span>echo</span> <span>\"func2: FUNCNAME2 is <span>${FUNCNAME<span>[</span>2<span>]</span>}</span>\"</span>\n<span>}</span>\n\nfunc1\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>执行上面的脚本 <code>test.sh</code>，结果如下。</p>\n<div><pre><code>$ ./test.sh\nfunc1: FUNCNAME0 is func1\nfunc1: FUNCNAME1 is main\nfunc1: FUNCNAME2 is\nfunc2: FUNCNAME0 is func2\nfunc2: FUNCNAME1 is func1\nfunc2: FUNCNAME2 is main\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面例子中，执行 <code>func1</code> 时，变量 <code>FUNCNAME</code> 的 0 号成员是 <code>func1</code>，1 号成员是调用 <code>func1</code> 的主脚本 <code>main</code>。执行 <code>func2</code> 时，变量 <code>FUNCNAME</code> 的 0 号成员是 <code>func2</code>，1 号成员是调用 <code>func2</code> 的 <code>func1</code>。</p>\n<h3 id=\"bash-source\" tabindex=\"-1\"> BASH_SOURCE</h3>\n<p>变量 <code>BASH_SOURCE</code> 返回一个数组，内容是当前的脚本调用堆栈。该数组的 0 号成员是当前执行的脚本，1 号成员是调用当前脚本的脚本，以此类推，跟变量 <code>FUNCNAME</code> 是一一对应关系。</p>\n<p>下面有两个子脚本 <code>lib1.sh</code> 和 <code>lib2.sh</code>。</p>\n<div><pre><code><span># lib1.sh</span>\n<span>function</span> <span>func1</span><span>(</span><span>)</span>\n<span>{</span>\n  <span>echo</span> <span>\"func1: BASH_SOURCE0 is <span>${<span>BASH_SOURCE</span><span>[</span>0<span>]</span>}</span>\"</span>\n  <span>echo</span> <span>\"func1: BASH_SOURCE1 is <span>${<span>BASH_SOURCE</span><span>[</span>1<span>]</span>}</span>\"</span>\n  <span>echo</span> <span>\"func1: BASH_SOURCE2 is <span>${<span>BASH_SOURCE</span><span>[</span>2<span>]</span>}</span>\"</span>\n  func2\n<span>}</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><div><pre><code><span># lib2.sh</span>\n<span>function</span> <span>func2</span><span>(</span><span>)</span>\n<span>{</span>\n  <span>echo</span> <span>\"func2: BASH_SOURCE0 is <span>${<span>BASH_SOURCE</span><span>[</span>0<span>]</span>}</span>\"</span>\n  <span>echo</span> <span>\"func2: BASH_SOURCE1 is <span>${<span>BASH_SOURCE</span><span>[</span>1<span>]</span>}</span>\"</span>\n  <span>echo</span> <span>\"func2: BASH_SOURCE2 is <span>${<span>BASH_SOURCE</span><span>[</span>2<span>]</span>}</span>\"</span>\n<span>}</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>然后，主脚本 <code>main.sh</code> 调用上面两个子脚本。</p>\n<div><pre><code><span>#!/bin/bash</span>\n<span># main.sh</span>\n\n<span>source</span> lib1.sh\n<span>source</span> lib2.sh\n\nfunc1\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>执行主脚本 <code>main.sh</code>，会得到下面的结果。</p>\n<div><pre><code>$ ./main.sh\nfunc1: BASH_SOURCE0 is lib1.sh\nfunc1: BASH_SOURCE1 is ./main.sh\nfunc1: BASH_SOURCE2 is\nfunc2: BASH_SOURCE0 is lib2.sh\nfunc2: BASH_SOURCE1 is lib1.sh\nfunc2: BASH_SOURCE2 is ./main.sh\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面例子中，执行函数 <code>func1</code> 时，变量 <code>BASH_SOURCE</code> 的 0 号成员是 <code>func1</code> 所在的脚本 <code>lib1.sh</code>，1 号成员是主脚本 <code>main.sh</code>；执行函数 <code>func2</code> 时，变量 <code>BASH_SOURCE</code> 的 0 号成员是 <code>func2</code> 所在的脚本 <code>lib2.sh</code>，1 号成员是调用 <code>func2</code> 的脚本 <code>lib1.sh</code>。</p>\n<h3 id=\"bash-lineno\" tabindex=\"-1\"> BASH_LINENO</h3>\n<p>变量 <code>BASH_LINENO</code> 返回一个数组，内容是每一轮调用对应的行号。<code>${BASH_LINENO[$i]}</code> 跟 <code>${FUNCNAME[$i]}</code> 是一一对应关系，表示 <code>${FUNCNAME[$i]}</code> 在调用它的脚本文件 <code>${BASH_SOURCE[$i+1]}</code> 里面的行号。</p>\n<p>下面有两个子脚本 <code>lib1.sh</code> 和 <code>lib2.sh</code>。</p>\n<div><pre><code><span># lib1.sh</span>\n<span>function</span> <span>func1</span><span>(</span><span>)</span>\n<span>{</span>\n  <span>echo</span> <span>\"func1: BASH_LINENO is <span>${<span>BASH_LINENO</span><span>[</span>0<span>]</span>}</span>\"</span>\n  <span>echo</span> <span>\"func1: FUNCNAME is <span>${FUNCNAME<span>[</span>0<span>]</span>}</span>\"</span>\n  <span>echo</span> <span>\"func1: BASH_SOURCE is <span>${<span>BASH_SOURCE</span><span>[</span>1<span>]</span>}</span>\"</span>\n\n  func2\n<span>}</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><div><pre><code><span># lib2.sh</span>\n<span>function</span> <span>func2</span><span>(</span><span>)</span>\n<span>{</span>\n  <span>echo</span> <span>\"func2: BASH_LINENO is <span>${<span>BASH_LINENO</span><span>[</span>0<span>]</span>}</span>\"</span>\n  <span>echo</span> <span>\"func2: FUNCNAME is <span>${FUNCNAME<span>[</span>0<span>]</span>}</span>\"</span>\n  <span>echo</span> <span>\"func2: BASH_SOURCE is <span>${<span>BASH_SOURCE</span><span>[</span>1<span>]</span>}</span>\"</span>\n<span>}</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>然后，主脚本 <code>main.sh</code> 调用上面两个子脚本。</p>\n<div><pre><code><span>#!/bin/bash</span>\n<span># main.sh</span>\n\n<span>source</span> lib1.sh\n<span>source</span> lib2.sh\n\nfunc1\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>执行主脚本 <code>main.sh</code>，会得到下面的结果。</p>\n<div><pre><code>$ ./main.sh\nfunc1: <span>BASH_LINENO</span> is <span>7</span>\nfunc1: FUNCNAME is func1\nfunc1: <span>BASH_SOURCE</span> is main.sh\nfunc2: <span>BASH_LINENO</span> is <span>8</span>\nfunc2: FUNCNAME is func2\nfunc2: <span>BASH_SOURCE</span> is lib1.sh\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面例子中，函数 <code>func1</code> 是在 <code>main.sh</code> 的第 7 行调用，函数 <code>func2</code> 是在 <code>lib1.sh</code> 的第 8 行调用的。</p>\n",
      "date_published": "2022-08-20T08:54:00.000Z",
      "date_modified": "2022-08-20T08:54:00.000Z",
      "authors": [
        {
          "name": "阮一峰"
        }
      ],
      "tags": [
        "Linux"
      ]
    },
    {
      "title": "Bash 的模式扩展",
      "url": "https://github.com/MisterChen9527/linux/bash/expansion.html",
      "id": "https://github.com/MisterChen9527/linux/bash/expansion.html",
      "content_html": "<h2 id=\"简介\" tabindex=\"-1\"> 简介</h2>\n<p>Shell 接收到用户输入的命令以后，会根据空格将用户的输入，拆分成一个个词元(token)。然后，Shell 会扩展词元里面的特殊字符，扩展完成后才会调用相应的命令。</p>\n<p>这种特殊字符的扩展，称为模式扩展(globbing)。其中有些用到通配符，又称为通配符扩展(wildcard expansion)。Bash 一共提供八种扩展。</p>\n<ul>\n<li>波浪线扩展</li>\n<li><code>?</code> 字符扩展</li>\n<li><code>*</code> 字符扩展</li>\n<li>方括号扩展</li>\n<li>大括号扩展</li>\n<li>变量扩展</li>\n<li>子命令扩展</li>\n<li>算术扩展</li>\n</ul>\n<p>本章介绍这八种扩展。</p>\n<p>Bash 是先进行扩展，再执行命令。因此，扩展的结果是由 Bash 负责的，与所要执行的命令无关。命令本身并不存在参数扩展，收到什么参数就原样执行。这一点务必需要记住。</p>\n<p><code>globbing</code> 这个词，来自于早期的 Unix 系统有一个 <code>/etc/glob</code> 文件，保存扩展的模板。后来 Bash 内置了这个功能，但是这个名字就保留了下来。</p>\n<p>模式扩展与正则表达式的关系是，模式扩展早于正则表达式出现，可以看作是原始的正则表达式。它的功能没有正则那么强大灵活，但是优点是简单和方便。</p>\n<p>Bash 允许用户关闭扩展。</p>\n<div><pre><code>$ <span>set</span> -o noglob\n<span># 或者</span>\n$ <span>set</span> -f\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div></div></div><p>下面的命令可以重新打开扩展。</p>\n<div><pre><code>$ <span>set</span> +o noglob\n<span># 或者</span>\n$ <span>set</span> +f\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div></div></div><h2 id=\"波浪线扩展\" tabindex=\"-1\"> 波浪线扩展</h2>\n<p>波浪线 <code>~</code> 会自动扩展成当前用户的主目录。</p>\n<div><pre><code>$ <span>echo</span> ~\n/home/me\n</code></pre><div aria-hidden=\"true\"><div></div><div></div></div></div><p><code>~/dir</code> 表示扩展成主目录的某个子目录，<code>dir</code> 是主目录里面的一个子目录名。</p>\n<div><pre><code><span># 进入 /home/me/foo 目录</span>\n$ <span>cd</span> ~/foo\n</code></pre><div aria-hidden=\"true\"><div></div><div></div></div></div><p><code>~user</code> 表示扩展成用户 <code>user</code> 的主目录。</p>\n<div><pre><code>$ <span>echo</span> ~foo\n/home/foo\n\n$ <span>echo</span> ~root\n/root\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div></div></div><p>上面例子中，Bash 会根据波浪号后面的用户名，返回该用户的主目录。</p>\n<p>如果 <code>~user</code> 的 <code>user</code> 是不存在的用户名，则波浪号扩展不起作用。</p>\n<div><pre><code>$ <span>echo</span> ~nonExistedUser\n~nonExistedUser\n</code></pre><div aria-hidden=\"true\"><div></div><div></div></div></div><p><code>~+</code> 会扩展成当前所在的目录，等同于 <code>pwd</code> 命令。</p>\n<div><pre><code>$ <span>cd</span> ~/foo\n$ <span>echo</span> ~+\n/home/me/foo\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div></div></div><h2 id=\"字符扩展\" tabindex=\"-1\"> <code>?</code> 字符扩展</h2>\n<p><code>?</code> 字符代表文件路径里面的任意单个字符，不包括空字符。比如，<code>Data???</code> 匹配所有 <code>Data</code> 后面跟着三个字符的文件名。</p>\n<div><pre><code><span># 存在文件 a.txt 和 b.txt</span>\n$ <span>ls</span> ?.txt\na.txt b.txt\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div></div></div><p>上面命令中，<code>?</code> 表示单个字符，所以会同时匹配 <code>a.txt</code> 和 <code>b.txt</code>。</p>\n<p>如果匹配多个字符，就需要多个 <code>?</code> 连用。</p>\n<div><pre><code><span># 存在文件 a.txt、b.txt 和 ab.txt</span>\n$ <span>ls</span> ??.txt\nab.txt\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div></div></div><p>上面命令中，<code>??</code> 匹配了两个字符。</p>\n<p><code>?</code> 字符扩展属于文件名扩展，只有文件确实存在的前提下，才会发生扩展。如果文件不存在，扩展就不会发生。</p>\n<div><pre><code><span># 当前目录有 a.txt 文件</span>\n$ <span>echo</span> ?.txt\na.txt\n\n<span># 当前目录为空目录</span>\n$ <span>echo</span> ?.txt\n?.txt\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面例子中，如果 <code>?.txt</code> 可以扩展成文件名，<code>echo</code> 命令会输出扩展后的结果；如果不能扩展成文件名，<code>echo</code> 就会原样输出 <code>?.txt</code>。</p>\n<h2 id=\"字符扩展-1\" tabindex=\"-1\"> <code>*</code> 字符扩展</h2>\n<p><code>*</code> 字符代表文件路径里面的任意数量的任意字符，包括零个字符。</p>\n<div><pre><code><span># 存在文件 a.txt、b.txt 和 ab.txt</span>\n$ <span>ls</span> *.txt\na.txt b.txt ab.txt\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div></div></div><p>上面例子中，<code>*.txt</code> 代表后缀名为 <code>.txt</code> 的所有文件。</p>\n<p>如果想输出当前目录的所有文件，直接用 <code>*</code> 即可。</p>\n<div><pre><code><span>ls</span> *\n</code></pre><div aria-hidden=\"true\"><div></div></div></div><p><code>*</code> 可以匹配空字符，下面是一个例子。</p>\n<div><pre><code><span># 存在文件 a.txt、b.txt 和 ab.txt</span>\n$ <span>ls</span> a*.txt\na.txt ab.txt\n\n$ <span>ls</span> *b*\nb.txt ab.txt\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>注意，<code>*</code> 不会匹配隐藏文件(以 <code>.</code> 开头的文件)，即 <code>ls *</code> 不会输出隐藏文件。</p>\n<p>如果要匹配隐藏文件，需要写成 <code>.*</code>。</p>\n<div><pre><code><span># 显示所有隐藏文件</span>\n$ <span>echo</span> .*\n</code></pre><div aria-hidden=\"true\"><div></div><div></div></div></div><p>如果要匹配隐藏文件，同时要排除 <code>.</code> 和 <code>..</code> 这两个特殊的隐藏文件，可以与方括号扩展结合使用，写成 <code>.[!.]*</code>。</p>\n<div><pre><code><span>echo</span> .<span>[</span><span>!</span>.<span>]</span>*\n</code></pre><div aria-hidden=\"true\"><div></div></div></div><p>注意，<code>*</code> 字符扩展属于文件名扩展，只有文件确实存在的前提下才会扩展。如果文件不存在，就会原样输出。</p>\n<div><pre><code><span># 当前目录不存在 c 开头的文件</span>\n$ <span>echo</span> c*.txt\nc*.txt\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div></div></div><p>上面例子中，当前目录里面没有 <code>c</code> 开头的文件，导致 <code>c*.txt</code> 会原样输出。</p>\n<p><code>*</code> 只匹配当前目录，不会匹配子目录。</p>\n<div><pre><code><span># 子目录有一个 a.txt</span>\n<span># 无效的写法</span>\n$ <span>ls</span> *.txt\n\n<span># 有效的写法</span>\n$ <span>ls</span> */*.txt\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面的例子，文本文件在子目录，<code>*.txt</code> 不会产生匹配，必须写成 <code>*/*.txt</code>。有几层子目录，就必须写几层星号。</p>\n<p>Bash 4.0 引入了一个参数 <code>globstar</code>，当该参数打开时，允许 <code>**</code> 匹配零个或多个子目录。因此，<code>**/*.txt</code> 可以匹配顶层的文本文件和任意深度子目录的文本文件。详细介绍请看后面 <code>shopt</code> 命令的介绍。</p>\n<h2 id=\"方括号扩展\" tabindex=\"-1\"> 方括号扩展</h2>\n<p>方括号扩展的形式是 <code>[...]</code>，只有文件确实存在的前提下才会扩展。如果文件不存在，就会原样输出。括号之中的任意一个字符。比如，<code>[aeiou]</code> 可以匹配五个元音字母中的任意一个。</p>\n<div><pre><code><span># 存在文件 a.txt 和 b.txt</span>\n$ <span>ls</span> <span>[</span>ab<span>]</span>.txt\na.txt b.txt\n\n<span># 只存在文件 a.txt</span>\n$ <span>ls</span> <span>[</span>ab<span>]</span>.txt\na.txt\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面例子中，<code>[ab]</code> 可以匹配 <code>a</code> 或 <code>b</code>，前提是确实存在相应的文件。</p>\n<p>方括号扩展属于文件名匹配，即扩展后的结果必须符合现有的文件路径。如果不存在匹配，就会保持原样，不进行扩展。</p>\n<div><pre><code><span># 不存在文件 a.txt 和 b.txt</span>\n$ <span>ls</span> <span>[</span>ab<span>]</span>.txt\nls: 无法访问<span>'[ab].txt'</span><span>:</span> 没有那个文件或目录\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div></div></div><p>上面例子中，由于扩展后的文件不存在，<code>[ab].txt</code> 就原样输出了，导致 <code>ls</code> 命名报错。</p>\n<p>方括号扩展还有两种变体: <code>[^...]</code> 和 <code>[!...]</code>。它们表示匹配不在方括号里面的字符，这两种写法是等价的。比如，<code>[^abc]</code> 或 <code>[!abc]</code> 表示匹配除了 <code>a</code>、<code>b</code>、<code>c</code> 以外的字符。</p>\n<div><pre><code><span># 存在 aaa、bbb、aba 三个文件</span>\n$ <span>ls</span> ?<span>[</span><span>!</span>a<span>]</span>?\naba bbb\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div></div></div><p>上面命令中，<code>[!a]</code> 表示文件名第二个字符不是 <code>a</code> 的文件名，所以返回了 <code>aba</code> 和 <code>bbb</code> 两个文件。</p>\n<p>注意，如果需要匹配 <code>[</code> 字符，可以放在方括号内，比如 <code>[[aeiou]</code>。如果需要匹配连字号 <code>-</code>，只能放在方括号内部的开头或结尾，比如 <code>[-aeiou]</code> 或 <code>[aeiou-]</code>。</p>\n<h2 id=\"start-end-扩展\" tabindex=\"-1\"> [start-end] 扩展</h2>\n<p>方括号扩展有一个简写形式 <code>[start-end]</code>，表示匹配一个连续的范围。比如，<code>[a-c]</code> 等同于 <code>[abc]</code>，<code>[0-9]</code> 匹配 <code>[0123456789]</code>。</p>\n<div><pre><code><span># 存在文件 a.txt、b.txt 和 c.txt</span>\n$ <span>ls</span> <span>[</span>a-c<span>]</span>.txt\na.txt\nb.txt\nc.txt\n\n<span># 存在文件 report1.txt、report2.txt 和 report3.txt</span>\n$ <span>ls</span> report<span>[</span><span>0</span>-9<span>]</span>.txt\nreport1.txt\nreport2.txt\nreport3.txt\n<span>..</span>.\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>下面是一些常用简写的例子。</p>\n<ul>\n<li><code>[a-z]</code>: 所有小写字母。</li>\n<li><code>[a-zA-Z]</code>: 所有小写字母与大写字母。</li>\n<li><code>[a-zA-Z0-9]</code>: 所有小写字母、大写字母与数字。</li>\n<li><code>[abc]*</code>: 所有以 <code>a</code>、<code>b</code>、<code>c</code> 字符之一开头的文件名。</li>\n<li><code>program.[co]</code>: 文件 <code>program.c</code> 与文件 <code>program.o</code>。</li>\n<li><code>BACKUP.[0-9][0-9][0-9]</code>: 所有以 <code>BACKUP.</code> 开头，后面是三个数字的文件名。</li>\n</ul>\n<p>这种简写形式有一个否定形式 <code>[!start-end]</code>，表示匹配不属于这个范围的字符。比如，<code>[!a-zA-Z]</code> 表示匹配非英文字母的字符。</p>\n<div><pre><code>$ <span>echo</span> report<span>[</span><span>!</span><span>1</span>–3<span>]</span>.txt\nreport4.txt report5.txt\n</code></pre><div aria-hidden=\"true\"><div></div><div></div></div></div><p>上面代码中，<code>[!1-3]</code> 表示排除 1、2 和 3。</p>\n<h2 id=\"大括号扩展\" tabindex=\"-1\"> 大括号扩展</h2>\n<p>大括号扩展 <code>{...}</code> 表示分别扩展成大括号里面的所有值，各个值之间使用逗号分隔。比如，<code>{1,2,3}</code> 扩展成 <code>1 2 3</code>。</p>\n<div><pre><code>$ <span>echo</span> <span>{</span><span>1,2</span>,3<span>}</span>\n<span>1</span> <span>2</span> <span>3</span>\n\n$ <span>echo</span> d<span>{</span>a,e,i,u,o<span>}</span>g\ndag deg <span>dig</span> dug dog\n\n$ <span>echo</span> Front-<span>{</span>A,B,C<span>}</span>-Back\nFront-A-Back Front-B-Back Front-C-Back\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>注意，大括号扩展不是文件名扩展。它会扩展成所有给定的值，而不管是否有对应的文件存在。</p>\n<div><pre><code>$ <span>ls</span> <span>{</span>a,b,c<span>}</span>.txt\nls: 无法访问<span>'a.txt'</span><span>:</span> 没有那个文件或目录\nls: 无法访问<span>'b.txt'</span><span>:</span> 没有那个文件或目录\nls: 无法访问<span>'c.txt'</span><span>:</span> 没有那个文件或目录\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div></div></div><p>上面例子中，即使不存在对应的文件，<code>{a,b,c}</code> 依然扩展成三个文件名，导致 <code>ls</code> 命令报了三个错误。</p>\n<p>另一个需要注意的地方是，大括号内部的逗号前后不能有空格。否则，大括号扩展会失效。</p>\n<div><pre><code>$ <span>echo</span> <span>{</span><span>1</span> , <span>2</span><span>}</span>\n<span>{</span><span>1</span> , <span>2</span><span>}</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div></div></div><p>上面例子中，逗号前后有空格，Bash 就会认为这不是大括号扩展，而是三个独立的参数。</p>\n<p>逗号前面可以没有值，表示扩展的第一项为空。</p>\n<div><pre><code>$ <span>cp</span> a.log<span>{</span>,.bak<span>}</span>\n\n<span># 等同于</span>\n<span># cp a.log a.log.bak</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div></div></div><p>大括号可以嵌套。</p>\n<div><pre><code>$ <span>echo</span> <span>{</span>j<span>{</span>p,pe<span>}</span>g,png<span>}</span>\njpg jpeg png\n\n$ <span>echo</span> a<span>{</span>A<span>{</span><span>1,2</span><span>}</span>,B<span>{</span><span>3,4</span><span>}</span><span>}</span>b\naA1b aA2b aB3b aB4b\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div></div></div><p>大括号也可以与其他模式联用，并且总是先于其他模式进行扩展。</p>\n<div><pre><code>$ <span>echo</span> <span>{</span>cat,d*<span>}</span>\n<span>cat</span> dawg dg <span>dig</span> dog doug dug\n</code></pre><div aria-hidden=\"true\"><div></div><div></div></div></div><p>上面例子中，会先进行大括号扩展，然后进行 <code>*</code> 扩展。</p>\n<p>大括号可以用于多字符的模式，方括号不行(只能匹配单字符)。</p>\n<div><pre><code>$ <span>echo</span> <span>{</span>cat,dog<span>}</span>\n<span>cat</span> dog\n</code></pre><div aria-hidden=\"true\"><div></div><div></div></div></div><p>由于大括号扩展 <code>{...}</code> 不是文件名扩展，所以它总是会扩展的。这与方括号扩展 <code>[...]</code> 完全不同，如果匹配的文件不存在，方括号就不会扩展。这一点要注意区分。</p>\n<div><pre><code><span># 不存在 a.txt 和 b.txt</span>\n$ <span>echo</span> <span>[</span>ab<span>]</span>.txt\n<span>[</span>ab<span>]</span>.txt\n\n$ <span>echo</span> <span>{</span>a,b<span>}</span>.txt\na.txt b.txt\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面例子中，如果不存在 <code>a.txt</code> 和 <code>b.txt</code>，那么 <code>[ab].txt</code> 就会变成一个普通的文件名，而 <code>{a,b}.txt</code> 可以照样扩展。</p>\n<h2 id=\"start-end-扩展-1\" tabindex=\"-1\"> {start..end} 扩展</h2>\n<p>大括号扩展有一个简写形式 <code>{start..end}</code>，表示扩展成一个连续序列。比如，<code>{a..z}</code> 可以扩展成 26 个小写英文字母。</p>\n<div><pre><code>$ <span>echo</span> <span>{</span>a<span>..</span>c<span>}</span>\na b c\n\n$ <span>echo</span> d<span>{</span>a<span>..</span>d<span>}</span>g\ndag dbg dcg ddg\n\n$ <span>echo</span> <span>{</span><span>1</span><span>..</span><span>4</span><span>}</span>\n<span>1</span> <span>2</span> <span>3</span> <span>4</span>\n\n$ <span>echo</span> Number_<span>{</span><span>1</span><span>..</span><span>5</span><span>}</span>\nNumber_1 Number_2 Number_3 Number_4 Number_5\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>这种简写形式支持逆序。</p>\n<div><pre><code>$ <span>echo</span> <span>{</span>c<span>..</span>a<span>}</span>\nc b a\n\n$ <span>echo</span> <span>{</span><span>5</span><span>..</span><span>1</span><span>}</span>\n<span>5</span> <span>4</span> <span>3</span> <span>2</span> <span>1</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div></div></div><p>注意，如果遇到无法理解的简写，大括号模式就会原样输出，不会扩展。</p>\n<div><pre><code>$ <span>echo</span> <span>{</span>a1<span>..</span>3c<span>}</span>\n<span>{</span>a1<span>..</span>3c<span>}</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div></div></div><p>这种简写形式可以嵌套使用，形成复杂的扩展。</p>\n<div><pre><code>$ <span>echo</span> .<span>{</span>mp<span>{</span><span>3</span><span>..</span><span>4</span><span>}</span>,m4<span>{</span>a,b,p,v<span>}</span><span>}</span>\n.mp3 .mp4 .m4a .m4b .m4p .m4v\n</code></pre><div aria-hidden=\"true\"><div></div><div></div></div></div><p>大括号扩展的常见用途为新建一系列目录。</p>\n<div><pre><code><span>mkdir</span> <span>{</span><span>2007</span><span>..</span><span>2009</span><span>}</span>-<span>{</span>01<span>..</span><span>12</span><span>}</span>\n</code></pre><div aria-hidden=\"true\"><div></div></div></div><p>上面命令会新建 36 个子目录，每个子目录的名字都是”年份-月份“。</p>\n<p>这个写法的另一个常见用途，是直接用于 <code>for</code> 循环。</p>\n<div><pre><code><span>for</span> <span>i</span> <span>in</span> <span>{</span><span>1</span><span>..</span><span>4</span><span>}</span>\n<span>do</span>\n  <span>echo</span> <span>$i</span>\n<span>done</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div></div></div><p>上面例子会循环 4 次。</p>\n<p>如果整数前面有前导 <code>0</code>，扩展输出的每一项都有前导 <code>0</code>。</p>\n<div><pre><code>$ <span>echo</span> <span>{</span>01<span>..</span><span>5</span><span>}</span>\n01 02 03 04 05\n\n$ <span>echo</span> <span>{</span>001<span>..</span><span>5</span><span>}</span>\n001 002 003 004 005\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div></div></div><p>这种简写形式还可以使用第二个双点号(<code>start..end..step</code>)，用来指定扩展的步长。</p>\n<div><pre><code>$ <span>echo</span> <span>{</span><span>0</span><span>..</span><span>8</span><span>..</span><span>2</span><span>}</span>\n<span>0</span> <span>2</span> <span>4</span> <span>6</span> <span>8</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div></div></div><p>上面代码将 <code>0</code> 扩展到 <code>8</code>，每次递增的长度为 <code>2</code>，所以一共输出 5 个数字。</p>\n<p>多个简写形式连用，会有循环处理的效果。</p>\n<div><pre><code>$ <span>echo</span> <span>{</span>a<span>..</span>c<span>}</span><span>{</span><span>1</span><span>..</span><span>3</span><span>}</span>\na1 a2 a3 b1 b2 b3 c1 c2 c3\n</code></pre><div aria-hidden=\"true\"><div></div><div></div></div></div><h2 id=\"变量扩展\" tabindex=\"-1\"> 变量扩展</h2>\n<p>Bash 将美元符号 <code>$</code> 开头的词元视为变量，将其扩展成变量值，详见<a href=\"/linux/bash/variable.html\">Bash 变量</a> 一章。</p>\n<div><pre><code>$ <span>echo</span> <span>$SHELL</span>\n/bin/bash\n</code></pre><div aria-hidden=\"true\"><div></div><div></div></div></div><p>变量名除了放在美元符号后面，也可以放在 <code>${}</code> 里面。</p>\n<div><pre><code>$ <span>echo</span> <span>${<span>SHELL</span>}</span>\n/bin/bash\n</code></pre><div aria-hidden=\"true\"><div></div><div></div></div></div><p><code>${!string*}</code> 或 <code>${!string@}</code> 返回所有匹配给定字符串 <code>string</code> 的变量名。</p>\n<div><pre><code>$ <span>echo</span> <span>${<span>!</span>S*}</span>\n<span>SECONDS</span> <span>SHELL</span> <span>SHELLOPTS</span> <span>SHLVL</span> SSH_AGENT_PID <span>SSH_AUTH_SOCK</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div></div></div><p>上面例子中，<code>${!S*}</code> 扩展成所有以 <code>S</code> 开头的变量名。</p>\n<h2 id=\"子命令扩展\" tabindex=\"-1\"> 子命令扩展</h2>\n<p><code>$(...)</code> 可以扩展成另一个命令的运行结果，该命令的所有输出都会作为返回值。</p>\n<div><pre><code>$ <span>echo</span> <span><span>$(</span><span>date</span><span>)</span></span>\nTue Jan <span>28</span> 00:01:13 CST <span>2020</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div></div></div><p>上面例子中，<code>$(date)</code> 返回 <code>date</code> 命令的运行结果。</p>\n<p>还有另一种较老的语法，子命令放在反引号之中，也可以扩展成命令的运行结果。</p>\n<div><pre><code>$ <span>echo</span> <span><span>`</span><span>date</span><span>`</span></span>\nTue Jan <span>28</span> 00:01:13 CST <span>2020</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div></div></div><p><code>$(...)</code> 可以嵌套，比如 <code>$(ls $(pwd))</code>。</p>\n<h2 id=\"算术扩展\" tabindex=\"-1\"> 算术扩展</h2>\n<p><code>$((...))</code> 可以扩展成整数运算的结果，详见 <a href=\"/linux/bash/arithmetic.html\">Bash 的算术运算</a> 一章。</p>\n<div><pre><code>$ <span>echo</span> <span><span>$((</span><span>2</span> <span>+</span> <span>2</span><span>))</span></span>\n<span>4</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div></div></div><h2 id=\"字符类\" tabindex=\"-1\"> 字符类</h2>\n<p><code>[[:class:]]</code> 表示一个字符类，扩展成某一类特定字符之中的一个。常用的字符类如下。</p>\n<ul>\n<li><code>[[:alnum:]]</code>: 匹配任意英文字母与数字</li>\n<li><code>[[:alpha:]]</code>: 匹配任意英文字母</li>\n<li><code>[[:blank:]]</code>: 空格和 Tab 键。</li>\n<li><code>[[:cntrl:]]</code>: ASCII 码 0-31 的不可打印字符。</li>\n<li><code>[[:digit:]]</code>: 匹配任意数字 0-9。</li>\n<li><code>[[:graph:]]</code>: A-Z、a-z、0-9 和标点符号。</li>\n<li><code>[[:lower:]]</code>: 匹配任意小写字母 a-z。</li>\n<li><code>[[:print:]]</code>: ASCII 码 32-127 的可打印字符。</li>\n<li><code>[[:punct:]]</code>: 标点符号(除了 A-Z、a-z、0-9 的可打印字符)。</li>\n<li><code>[[:space:]]</code>: 空格、Tab、LF(10)、VT(11)、FF(12)、CR(13)。</li>\n<li><code>[[:upper:]]</code>: 匹配任意大写字母 A-Z。</li>\n<li><code>[[:xdigit:]]</code>: 16 进制字符(A-F、a-f、0-9)。</li>\n</ul>\n<p>请看下面的例子。</p>\n<div><pre><code><span>echo</span> <span>[</span><span>[</span>:upper:<span>]</span><span>]</span>*\n</code></pre><div aria-hidden=\"true\"><div></div></div></div><p>上面命令输出所有大写字母开头的文件名。</p>\n<p>字符类的第一个方括号后面，可以加上感叹号 <code>!</code>，表示否定。比如，<code>[![:digit:]]</code> 匹配所有非数字。</p>\n<div><pre><code><span>echo</span> <span>[</span><span>!</span><span>[</span>:digit:<span>]</span><span>]</span>*\n</code></pre><div aria-hidden=\"true\"><div></div></div></div><p>上面命令输出所有不以数字开头的文件名。</p>\n<p>字符类也属于文件名扩展，如果没有匹配的文件名，字符类就会原样输出。</p>\n<div><pre><code><span># 不存在以大写字母开头的文件</span>\n$ <span>echo</span> <span>[</span><span>[</span>:upper:<span>]</span><span>]</span>*\n<span>[</span><span>[</span>:upper:<span>]</span><span>]</span>*\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div></div></div><p>上面例子中，由于没有可匹配的文件，字符类就原样输出了。</p>\n<h2 id=\"使用注意点\" tabindex=\"-1\"> 使用注意点</h2>\n<p>通配符有一些使用注意点，不可不知。</p>\n<p>(1)<strong>通配符是先解释，再执行。</strong></p>\n<p>Bash 接收到命令以后，发现里面有通配符，会进行通配符扩展，然后再执行命令。</p>\n<div><pre><code>$ <span>ls</span> a*.txt\nab.txt\n</code></pre><div aria-hidden=\"true\"><div></div><div></div></div></div><p>上面命令的执行过程是，Bash 先将 <code>a*.txt</code> 扩展成 <code>ab.txt</code>，然后再执行 <code>ls ab.txt</code>。</p>\n<p>(2)<strong>文件名扩展在不匹配时，会原样输出。</strong></p>\n<p>文件名扩展在没有可匹配的文件时，会原样输出。</p>\n<div><pre><code><span># 不存在 r 开头的文件名</span>\n$ <span>echo</span> r*\nr*\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div></div></div><p>上面代码中，由于不存在 <code>r</code> 开头的文件名，<code>r*</code> 会原样输出。</p>\n<p>下面是另一个例子。</p>\n<div><pre><code>$ <span>ls</span> *.csv\nls: *.csv: No such <span>file</span> or directory\n</code></pre><div aria-hidden=\"true\"><div></div><div></div></div></div><p>另外，前面已经说过，大括号扩展 <code>{...}</code> 不是文件名扩展。</p>\n<p>(3)<strong>只适用于单层路径。</strong></p>\n<p>所有文件名扩展只匹配单层路径，不能跨目录匹配，即无法匹配子目录里面的文件。或者说，<code>?</code> 或 <code>*</code> 这样的通配符，不能匹配路径分隔符 (<code>/</code>)。</p>\n<p>如果要匹配子目录里面的文件，可以写成下面这样。</p>\n<div><pre><code><span>ls</span> */*.txt\n</code></pre><div aria-hidden=\"true\"><div></div></div></div><p>Bash 4.0 新增了一个 <code>globstar</code> 参数，允许 <code>**</code> 匹配零个或多个子目录，详见后面 <code>shopt</code> 命令的介绍。</p>\n<p>(4)<strong>文件名可以使用通配符。</strong></p>\n<p>Bash 允许文件名使用通配符，即文件名包括特殊字符。这时引用文件名，需要把文件名放在单引号里面。</p>\n<div><pre><code>$ <span>touch</span> <span>'fo*'</span>\n$ <span>ls</span>\nfo*\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div></div></div><p>上面代码创建了一个 <code>fo*</code> 文件，这时 <code>*</code> 就是文件名的一部分。</p>\n<h2 id=\"量词语法\" tabindex=\"-1\"> 量词语法</h2>\n<p>量词语法用来控制模式匹配的次数。它只有在 Bash 的 <code>extglob</code> 参数打开的情况下才能使用，不过一般是默认打开的。下面的命令可以查询。</p>\n<div><pre><code>$ <span>shopt</span> extglob\nextglob         on\n</code></pre><div aria-hidden=\"true\"><div></div><div></div></div></div><p>量词语法有下面几个。</p>\n<ul>\n<li><code>?(pattern-list)</code>: 匹配零个或一个模式。</li>\n<li><code>*(pattern-list)</code>: 匹配零个或多个模式。</li>\n<li><code>+(pattern-list)</code>: 匹配一个或多个模式。</li>\n<li><code>@(pattern-list)</code>: 只匹配一个模式。</li>\n<li><code>!(pattern-list)</code>: 匹配零个或一个以上的模式，但不匹配单独一个的模式。</li>\n</ul>\n<div><pre><code>$ <span>ls</span> abc?<span>(</span>.<span>)</span>txt\nabctxt abc.txt\n</code></pre><div aria-hidden=\"true\"><div></div><div></div></div></div><p>上面例子中，<code>?(.)</code> 匹配零个或一个点。</p>\n<div><pre><code>$ <span>ls</span> abc?<span>(</span>def<span>)</span>\nabc abcdef\n</code></pre><div aria-hidden=\"true\"><div></div><div></div></div></div><p>上面例子中，<code>?(def)</code> 匹配零个或一个 <code>def</code>。</p>\n<div><pre><code>$ <span>ls</span> abc+<span>(</span>.txt<span>|</span>.php<span>)</span>\nabc.php abc.txt\n</code></pre><div aria-hidden=\"true\"><div></div><div></div></div></div><p>上面例子中，<code>+(.txt|.php)</code> 匹配文件有一个 <code>.txt</code> 或 <code>.php</code> 后缀名。</p>\n<div><pre><code>$ <span>ls</span> abc+<span>(</span>.txt<span>)</span>\nabc.txt abc.txt.txt\n</code></pre><div aria-hidden=\"true\"><div></div><div></div></div></div><p>上面例子中，<code>+(.txt)</code> 匹配文件有一个或多个 <code>.txt</code> 后缀名。</p>\n<p>量词语法也属于文件名扩展，如果不存在可匹配的文件，就会原样输出。</p>\n<div><pre><code><span># 没有 abc 开头的文件名</span>\n$ <span>ls</span> abc?<span>(</span>def<span>)</span>\nls: 无法访问<span>'abc?(def)'</span><span>:</span> 没有那个文件或目录\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div></div></div><p>上面例子中，由于没有可匹配的文件，<code>abc?(def)</code> 就原样输出，导致 <code>ls</code> 命令报错。</p>\n<h2 id=\"shopt-命令\" tabindex=\"-1\"> shopt 命令</h2>\n<p><code>shopt</code> 命令可以调整 Bash 的行为。它有好几个参数跟通配符扩展有关。</p>\n<p><code>shopt</code> 命令的使用方法如下。</p>\n<div><pre><code><span># 打开某个参数</span>\n$ <span>shopt</span> -s <span>[</span>optionname<span>]</span>\n\n<span># 关闭某个参数</span>\n$ <span>shopt</span> -u <span>[</span>optionname<span>]</span>\n\n<span># 查询某个参数关闭还是打开</span>\n$ <span>shopt</span> <span>[</span>optionname<span>]</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><ol>\n<li>\n<p><strong>dotglob 参数</strong></p>\n<p><code>dotglob</code> 参数可以让扩展结果包括隐藏文件(即点开头的文件)。</p>\n<p>正常情况下，扩展结果不包括隐藏文件。</p>\n<div><pre><code>$ <span>ls</span> *\nabc.txt\n</code></pre><div aria-hidden=\"true\"><div></div><div></div></div></div><p>打开 <code>dotglob</code>，就会包括隐藏文件。</p>\n<div><pre><code>$ <span>shopt</span> -s dotglob\n$ <span>ls</span> *\nabc.txt .config\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div></div></div></li>\n<li>\n<p><strong>nullglob 参数</strong></p>\n<p><code>nullglob</code> 参数可以让通配符不匹配任何文件名时，返回空字符。</p>\n<p>默认情况下，通配符不匹配任何文件名时，会保持不变。</p>\n<div><pre><code>$ <span>rm</span> b*\nrm: 无法删除<span>'b*'</span><span>:</span> 没有那个文件或目录\n</code></pre><div aria-hidden=\"true\"><div></div><div></div></div></div><p>上面例子中，由于当前目录不包括 <code>b</code> 开头的文件名，导致 <code>b*</code> 不会发生文件名扩展，保持原样不变，所以 <code>rm</code> 命令报错没有 <code>b*</code> 这个文件。</p>\n<p>打开 <code>nullglob</code> 参数，就可以让不匹配的通配符返回空字符串。</p>\n<div><pre><code>$ <span>shopt</span> -s nullglob\n$ <span>rm</span> b*\nrm: 缺少操作数\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div></div></div><p>上面例子中，由于没有 <code>b*</code> 匹配的文件名，所以 <code>rm b*</code> 扩展成了 <code>rm</code>，导致报错变成了”缺少操作数“。</p>\n</li>\n<li>\n<p><strong>failglob 参数</strong></p>\n<p><code>failglob</code> 参数使得通配符不匹配任何文件名时，Bash 会直接报错，而不是让各个命令去处理。</p>\n<div><pre><code>$ <span>shopt</span> -s failglob\n$ <span>rm</span> b*\nbash: 无匹配: b*\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div></div></div><p>上面例子中，打开 <code>failglob</code> 以后，由于 <code>b*</code> 不匹配任何文件名，Bash 直接报错了，不再让 <code>rm</code> 命令去处理。</p>\n</li>\n<li>\n<p><strong>extglob 参数</strong></p>\n<p><code>extglob</code> 参数使得 Bash 支持 ksh 的一些扩展语法。它默认应该是打开的。</p>\n<div><pre><code>$ <span>shopt</span> extglob\nextglob         on\n</code></pre><div aria-hidden=\"true\"><div></div><div></div></div></div><p>它的主要应用是支持量词语法。如果不希望支持量词语法，可以用下面的命令关闭。</p>\n<div><pre><code><span>shopt</span> -u extglob\n</code></pre><div aria-hidden=\"true\"><div></div></div></div></li>\n<li>\n<p><strong>nocaseglob 参数</strong></p>\n<p><code>nocaseglob</code> 参数可以让通配符扩展不区分大小写。</p>\n<div><pre><code>$ <span>shopt</span> -s nocaseglob\n$ <span>ls</span> /windows/program*\n/windows/ProgramData\n/windows/Program Files\n/windows/Program Files <span>(</span>x86<span>)</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div></div></div><p>上面例子中，打开 <code>nocaseglob</code> 以后，<code>program*</code> 就不区分大小写了，可以匹配 <code>ProgramData</code> 等。</p>\n</li>\n<li>\n<p><strong>globstar 参数</strong></p>\n<p><code>globstar</code> 参数可以使得 <code>**</code> 匹配零个或多个子目录。该参数默认是关闭的。</p>\n<p>假设有下面的文件结构。</p>\n<div><pre><code>a.txt\nsub1/b.txt\nsub1/sub2/c.txt\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div></div></div><p>上面的文件结构中，顶层目录、第一级子目录 <code>sub1</code>、第二级子目录 <code>sub1\\sub2</code> 里面各有一个文本文件。请问怎样才能使用通配符，将它们显示出来?</p>\n<p>默认情况下，只能写成下面这样。</p>\n<div><pre><code>$ <span>ls</span> *.txt */*.txt */*/*.txt\na.txt  sub1/b.txt  sub1/sub2/c.txt\n</code></pre><div aria-hidden=\"true\"><div></div><div></div></div></div><p>这是因为 <code>*</code> 只匹配当前目录，如果要匹配子目录，只能一层层写出来。</p>\n<p>打开 <code>globstar</code> 参数以后，<code>**</code> 匹配零个或多个子目录。因此，<code>**/*.txt</code> 就可以得到想要的结果。</p>\n<div><pre><code>$ <span>shopt</span> -s globstar\n$ <span>ls</span> **/*.txt\na.txt  sub1/b.txt  sub1/sub2/c.txt\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div></div></div></li>\n</ol>\n<h2 id=\"参考链接\" tabindex=\"-1\"> 参考链接</h2>\n<ul>\n<li><a href=\"https://medium.com/@leedowthwaite/why-most-people-only-think-they-understand-wildcards-63bb9c2024ab\" target=\"_blank\" rel=\"noopener noreferrer\">Think You Understand Wildcards? Think Again</a></li>\n<li><a href=\"https://appcodelabs.com/advanced-wildcard-patterns-most-people-dont-know\" target=\"_blank\" rel=\"noopener noreferrer\">Advanced Wildcard Patterns Most People Don’t Know</a></li>\n</ul>\n",
      "date_published": "2022-08-20T08:54:00.000Z",
      "date_modified": "2022-08-20T08:54:00.000Z",
      "authors": [
        {
          "name": "阮一峰"
        }
      ],
      "tags": [
        "Linux"
      ]
    },
    {
      "title": "Bash 函数",
      "url": "https://github.com/MisterChen9527/linux/bash/function.html",
      "id": "https://github.com/MisterChen9527/linux/bash/function.html",
      "summary": "本章介绍 Bash 函数的用法。\n",
      "content_html": "<p>本章介绍 Bash 函数的用法。</p>\n\n<h2 id=\"简介\" tabindex=\"-1\"> 简介</h2>\n<p>函数(function)是可以重复使用的代码片段，有利于代码的复用。它与别名(alias)的区别是，别名只适合封装简单的单个命令，函数则可以封装复杂的多行命令。</p>\n<p>函数总是在当前 Shell 执行，这是跟脚本的一个重大区别，Bash 会新建一个子 Shell 执行脚本。如果函数与脚本同名，函数会优先执行。但是，函数的优先级不如别名，即如果函数与别名同名，那么别名优先执行。</p>\n<p>Bash 函数定义的语法有两种。</p>\n<div><pre><code><span># 第一种</span>\n<span>fn</span><span>(</span><span>)</span> <span>{</span>\n  <span># codes</span>\n<span>}</span>\n\n<span># 第二种</span>\n<span>function</span> <span>fn</span><span>(</span><span>)</span> <span>{</span>\n  <span># codes</span>\n<span>}</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面代码中，<code>fn</code> 是自定义的函数名，函数代码就写在大括号之中。这两种写法是等价的。</p>\n<p>下面是一个简单函数的例子。</p>\n<div><pre><code><span>hello</span><span>(</span><span>)</span> <span>{</span>\n  <span>echo</span> <span>\"Hello <span>$1</span>\"</span>\n<span>}</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div></div></div><p>上面代码中，函数体里面的 <code>$1</code> 表示函数调用时的第一个参数。</p>\n<p>调用时，就直接写函数名，参数跟在函数名后面。</p>\n<div><pre><code>$ hello world\nhello world\n</code></pre><div aria-hidden=\"true\"><div></div><div></div></div></div><p>下面是一个多行函数的例子，显示当前日期时间。</p>\n<div><pre><code><span>today</span><span>(</span><span>)</span> <span>{</span>\n  <span>echo</span> -n <span>\"Today's date is: \"</span>\n  <span>date</span> +<span>\"%A, %B %-d, %Y\"</span>\n<span>}</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div></div></div><p>删除一个函数，可以使用 <code>unset</code> 命令。</p>\n<div><pre><code><span>unset</span> -f functionName\n</code></pre><div aria-hidden=\"true\"><div></div></div></div><p>查看当前 Shell 已经定义的所有函数，可以使用 <code>declare</code> 命令。</p>\n<div><pre><code><span>declare</span> -f\n</code></pre><div aria-hidden=\"true\"><div></div></div></div><p>上面的 <code>declare</code> 命令不仅会输出函数名，还会输出所有定义。输出顺序是按照函数名的字母表顺序。由于会输出很多内容，最好通过管道命令配合 <code>more</code> 或 <code>less</code> 使用。</p>\n<p><code>declare</code> 命令还支持查看单个函数的定义。</p>\n<div><pre><code><span>declare</span> -f functionName\n</code></pre><div aria-hidden=\"true\"><div></div></div></div><p><code>declare -F</code> 可以输出所有已经定义的函数名，不含函数体。</p>\n<div><pre><code><span>declare</span> -F\n</code></pre><div aria-hidden=\"true\"><div></div></div></div><h2 id=\"参数变量\" tabindex=\"-1\"> 参数变量</h2>\n<p>函数体内可以使用参数变量，获取函数参数。函数的参数变量，与脚本参数变量是一致的。</p>\n<ul>\n<li><code>$1</code> ~ <code>$9</code>: 函数的第一个到第 9 个的参数。</li>\n<li><code>$0</code>: 函数所在的脚本名。</li>\n<li><code>$#</code>: 函数的参数总数。</li>\n<li><code>$@</code>: 函数的全部参数，参数之间使用空格分隔。</li>\n<li><code>$*</code>: 函数的全部参数，参数之间使用变量 <code>$IFS</code> 值的第一个字符分隔，默认为空格，但是可以自定义。</li>\n</ul>\n<p>如果函数的参数多于 9 个，那么第 10 个参数可以用 <code>${10}</code> 的形式引用，以此类推。</p>\n<p>下面是一个示例脚本 <code>test.sh</code>。</p>\n<div><pre><code><span>#!/bin/bash</span>\n<span># test.sh</span>\n\n<span>function</span> <span>alice</span> <span>{</span>\n  <span>echo</span> <span>\"alice: <span>$@</span>\"</span>\n  <span>echo</span> <span>\"<span>$0</span>: <span>$1</span> <span>$2</span> <span>$3</span> <span>$4</span>\"</span>\n  <span>echo</span> <span>\"<span>$#</span> arguments\"</span>\n\n<span>}</span>\n\nalice <span>in</span> wonderland\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>运行该脚本，结果如下。</p>\n<div><pre><code>$ <span>bash</span> test.sh\nalice: <span>in</span> wonderland\ntest.sh: <span>in</span> wonderland\n<span>2</span> arguments\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div></div></div><p>上面例子中，由于函数 <code>alice</code> 只有第一个和第二个参数，所以第三个和第四个参数为空。</p>\n<p>下面是一个日志函数的例子。</p>\n<div><pre><code><span>function</span> <span>log_msg</span> <span>{</span>\n  <span>echo</span> <span>\"[<span><span>`</span><span>date</span> <span>'+ %F %T'</span><span>`</span></span> ]: <span>$@</span>\"</span>\n<span>}</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div></div></div><p>使用方法如下。</p>\n<div><pre><code>$ log_msg <span>\"This is sample log message\"</span>\n<span>[</span> <span>2018</span>-08-16 <span>19</span>:56:34 <span>]</span>: This is sample log message\n</code></pre><div aria-hidden=\"true\"><div></div><div></div></div></div><h2 id=\"return-命令\" tabindex=\"-1\"> return 命令</h2>\n<p><code>return</code> 命令用于从函数返回一个值。函数执行到这条命令，就不再往下执行了，直接返回了。</p>\n<div><pre><code><span>function</span> <span>func_return_value</span> <span>{</span>\n  <span>return</span> <span>10</span>\n<span>}</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div></div></div><p>函数将返回值返回给调用者。如果命令行直接执行函数，下一个命令可以用 <code>$?</code> 拿到返回值。</p>\n<div><pre><code>$ func_return_value\n$ <span>echo</span> <span>\"Value returned by function is: <span>$?</span>\"</span>\nValue returned by <span>function</span> is: <span>10</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div></div></div><p><code>return</code> 后面不跟参数，只用于返回也是可以的。</p>\n<div><pre><code><span>function</span> <span>name</span> <span>{</span>\n  commands\n  <span>return</span>\n<span>}</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div></div></div><h2 id=\"全局变量和局部变量-local-命令\" tabindex=\"-1\"> 全局变量和局部变量，local 命令</h2>\n<p>Bash 函数体内直接声明的变量，属于全局变量，整个脚本都可以读取。这一点需要特别小心。</p>\n<div><pre><code><span># 脚本 test.sh</span>\n<span>fn</span> <span>(</span><span>)</span> <span>{</span>\n  <span>foo</span><span>=</span><span>1</span>\n  <span>echo</span> <span>\"fn: foo = <span>$foo</span>\"</span>\n<span>}</span>\n\nfn\n<span>echo</span> <span>\"global: foo = <span>$foo</span>\"</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面脚本的运行结果如下。</p>\n<div><pre><code>$ <span>bash</span> test.sh\nfn: foo <span>=</span> <span>1</span>\nglobal: foo <span>=</span> <span>1</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div></div></div><p>上面例子中，变量 <code>$foo</code> 是在函数 <code>fn</code> 内部声明的，函数体外也可以读取。</p>\n<p>函数体内不仅可以声明全局变量，还可以修改全局变量。</p>\n<div><pre><code><span>foo</span><span>=</span><span>1</span>\n\n<span>fn</span> <span>(</span><span>)</span> <span>{</span>\n  <span>foo</span><span>=</span><span>2</span>\n<span>}</span>\n\n<span>echo</span> <span>$foo</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面代码执行后，输出的变量 <code>$foo</code> 值为 2。</p>\n<p>函数里面可以用 <code>local</code> 命令声明局部变量。</p>\n<div><pre><code><span># 脚本 test.sh</span>\n<span>fn</span> <span>(</span><span>)</span> <span>{</span>\n  <span>local</span> foo\n  <span>foo</span><span>=</span><span>1</span>\n  <span>echo</span> <span>\"fn: foo = <span>$foo</span>\"</span>\n<span>}</span>\n\nfn\n<span>echo</span> <span>\"global: foo = <span>$foo</span>\"</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面脚本的运行结果如下。</p>\n<div><pre><code>$ <span>bash</span> test.sh\nfn: foo <span>=</span> <span>1</span>\nglobal: foo <span>=</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div></div></div><p>上面例子中，<code>local</code> 命令声明的 <code>$foo</code> 变量，只在函数体内有效，函数体外没有定义。</p>\n<h2 id=\"参考链接\" tabindex=\"-1\"> 参考链接</h2>\n<ul>\n<li><a href=\"https://www.linuxtechi.com/define-use-functions-linux-shell-script/\" target=\"_blank\" rel=\"noopener noreferrer\">How to define and use functions in Linux Shell Script</a>, by Pradeep Kumar</li>\n</ul>\n",
      "date_published": "2022-08-20T08:54:00.000Z",
      "date_modified": "2022-08-20T08:54:00.000Z",
      "authors": [
        {
          "name": "阮一峰"
        }
      ],
      "tags": [
        "Linux"
      ]
    },
    {
      "title": "Bash 的基本语法",
      "url": "https://github.com/MisterChen9527/linux/bash/grammar.html",
      "id": "https://github.com/MisterChen9527/linux/bash/grammar.html",
      "summary": "本章介绍 Bash 的最基本语法。\n",
      "content_html": "<p>本章介绍 Bash 的最基本语法。</p>\n\n<h2 id=\"echo-命令\" tabindex=\"-1\"> echo 命令</h2>\n<p>由于后面的例子会大量用到 <code>echo</code> 命令，这里先介绍这个命令。</p>\n<p><code>echo</code> 命令的作用是在屏幕输出一行文本，可以将该命令的参数原样输出。</p>\n<div><pre><code>$ <span>echo</span> hello world\nhello world\n</code></pre><div aria-hidden=\"true\"><div></div><div></div></div></div><p>上面例子中，<code>echo</code> 的参数是 <code>hello world</code>，可以原样输出。</p>\n<p>如果想要输出的是多行文本，即包括换行符。这时需要把多行文本放在引号里面。</p>\n<div><pre><code>$ <span>echo</span> <span>\"&lt;HTML>\n    &lt;HEAD>\n          &lt;TITLE>Page Title&lt;/TITLE>\n    &lt;/HEAD>\n    &lt;BODY>\n          Page body.\n    &lt;/BODY>\n&lt;/HTML>\"</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面例子中，<code>echo</code> 可以原样输出多行文本。</p>\n<h3 id=\"n-参数\" tabindex=\"-1\"> <code>-n</code> 参数</h3>\n<p>默认情况下，<code>echo</code> 输出的文本末尾会有一个回车符。<code>-n</code> 参数可以取消末尾的回车符，使得下一个提示符紧跟在输出内容的后面。</p>\n<div><pre><code>$ <span>echo</span> -n hello world\nhello world$\n</code></pre><div aria-hidden=\"true\"><div></div><div></div></div></div><p>上面例子中，<code>world</code> 后面直接就是下一行的提示符 <code>$</code>。</p>\n<div><pre><code>$ <span>echo</span> a<span>;</span><span>echo</span> b\na\nb\n\n$ <span>echo</span> -n a<span>;</span><span>echo</span> b\nab\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面例子中，<code>-n</code> 参数可以让两个 <code>echo</code> 命令的输出连在一起，出现在同一行。</p>\n<h3 id=\"e-参数\" tabindex=\"-1\"> <code>-e</code> 参数</h3>\n<p><code>-e</code> 参数会解释引号(双引号和单引号)里面的特殊字符(比如换行符 <code>\\n</code>)。如果不使用 <code>-e</code> 参数，即默认情况下，引号会让特殊字符变成普通字符，<code>echo</code> 不解释它们，原样输出。</p>\n<div><pre><code>$ <span>echo</span> <span>\"Hello<span title=\"\\n\">\\n</span>World\"</span>\nHello<span>\\</span>nWorld\n\n<span># 双引号的情况</span>\n$ <span>echo</span> -e <span>\"Hello<span title=\"\\n\">\\n</span>World\"</span>\nHello\nWorld\n\n<span># 单引号的情况</span>\n$ <span>echo</span> -e <span>'Hello\\nWorld'</span>\nHello\nWorld\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面代码中，<code>-e</code> 参数使得 <code>\\n</code> 解释为换行符，导致输出内容里面出现换行。</p>\n<h2 id=\"命令格式\" tabindex=\"-1\"> 命令格式</h2>\n<p>命令行环境中，主要通过使用 Shell 命令，进行各种操作。Shell 命令基本都是下面的格式。</p>\n<div><pre><code><span>command</span> <span>[</span> arg1 <span>..</span>. <span>[</span> argN <span>]</span><span>]</span>\n</code></pre><div aria-hidden=\"true\"><div></div></div></div><p>上面代码中，<code>command</code> 是具体的命令或者一个可执行文件，<code>arg1 ... argN</code> 是传递给命令的参数，它们是可选的。</p>\n<div><pre><code><span>ls</span> -l\n</code></pre><div aria-hidden=\"true\"><div></div></div></div><p>上面这个命令中，<code>ls</code> 是命令，<code>-l</code> 是参数。</p>\n<p>有些参数是命令的配置项，这些配置项一般都以一个连词线开头，比如上面的 <code>-l</code>。同一个配置项往往有长和短两种形式，比如 <code>-l</code> 是短形式，<code>--list</code> 是长形式，它们的作用完全相同。短形式便于手动输入，长形式一般用在脚本之中，可读性更好，利于解释自身的含义。</p>\n<div><pre><code><span># 短形式</span>\n$ <span>ls</span> -r\n\n<span># 长形式</span>\n$ <span>ls</span> --reverse\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div></div></div><p>上面命令中，<code>-r</code> 是短形式，<code>--reverse</code> 是长形式，作用完全一样。前者便于输入，后者便于理解。</p>\n<p>Bash 单个命令一般都是一行，用户按下回车键，就开始执行。有些命令比较长，写成多行会有利于阅读和编辑，这时可以在每一行的结尾加上反斜杠，Bash 就会将下一行跟当前行放在一起解释。</p>\n<div><pre><code>$ <span>echo</span> foo bar\n\n<span># 等同于</span>\n$ <span>echo</span> foo <span>\\</span>\nbar\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div></div></div><h2 id=\"空格\" tabindex=\"-1\"> 空格</h2>\n<p>Bash 使用空格(或 Tab 键)区分不同的参数。</p>\n<div><pre><code><span>command</span> foo bar\n</code></pre><div aria-hidden=\"true\"><div></div></div></div><p>上面命令中，<code>foo</code> 和 <code>bar</code> 之间有一个空格，所以 Bash 认为它们是两个参数。</p>\n<p>如果参数之间有多个空格，Bash 会自动忽略多余的空格。</p>\n<div><pre><code>$ <span>echo</span> this is a     <span>test</span>\nthis is a <span>test</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div></div></div><p>上面命令中，<code>a</code> 和 <code>test</code> 之间有多个空格，Bash 会忽略多余的空格。</p>\n<h2 id=\"分号\" tabindex=\"-1\"> 分号</h2>\n<p>分号(<code>;</code>)是命令的结束符，使得一行可以放置多个命令，上一个命令执行结束后，再执行第二个命令。</p>\n<div><pre><code><span>clear</span><span>;</span> <span>ls</span>\n</code></pre><div aria-hidden=\"true\"><div></div></div></div><p>上面例子中，Bash 先执行 <code>clear</code> 命令，执行完成后，再执行 <code>ls</code> 命令。</p>\n<p>注意，使用分号时，第二个命令总是接着第一个命令执行，不管第一个命令执行成功或失败。</p>\n<h2 id=\"命令的组合符-和\" tabindex=\"-1\"> 命令的组合符 <code>&amp;&amp;</code> 和 <code>||</code></h2>\n<p>除了分号，Bash 还提供两个命令组合符 <code>&amp;&amp;</code> 和 <code>||</code>，允许更好地控制多个命令之间的继发关系。</p>\n<div><pre><code>Command1 <span>&amp;&amp;</span> Command2\n</code></pre><div aria-hidden=\"true\"><div></div></div></div><p>上面命令的意思是，如果 <code>Command1</code> 命令运行成功，则继续运行 <code>Command2</code> 命令。</p>\n<div><pre><code>Command1 <span>||</span> Command2\n</code></pre><div aria-hidden=\"true\"><div></div></div></div><p>上面命令的意思是，如果 <code>Command1</code> 命令运行失败，则继续运行 <code>Command2</code> 命令。</p>\n<p>下面是一些例子。</p>\n<div><pre><code><span>cat</span> filelist.txt <span>;</span> <span>ls</span> -l filelist.txt\n</code></pre><div aria-hidden=\"true\"><div></div></div></div><p>上面例子中，只要 <code>cat</code> 命令执行结束，不管成功或失败，都会继续执行 <code>ls</code> 命令。</p>\n<div><pre><code><span>cat</span> filelist.txt <span>&amp;&amp;</span> <span>ls</span> -l filelist.txt\n</code></pre><div aria-hidden=\"true\"><div></div></div></div><p>上面例子中，只有 <code>cat</code> 命令执行成功，才会继续执行 <code>ls</code> 命令。如果 <code>cat</code> 执行失败(比如不存在文件 <code>flielist.txt</code>)，那么 <code>ls</code> 命令就不会执行。</p>\n<div><pre><code><span>mkdir</span> foo <span>||</span> <span>mkdir</span> bar\n</code></pre><div aria-hidden=\"true\"><div></div></div></div><p>上面例子中，只有 <code>mkdir foo</code> 命令执行失败(比如 <code>foo</code> 目录已经存在)，才会继续执行 <code>mkdir bar</code> 命令。如果 <code>mkdir foo</code> 命令执行成功，就不会创建 <code>bar</code> 目录了。</p>\n<h2 id=\"type-命令\" tabindex=\"-1\"> type 命令</h2>\n<p>Bash 本身内置了很多命令，同时也可以执行外部程序。怎么知道一个命令是内置命令，还是外部程序呢?</p>\n<p><code>type</code> 命令用来判断命令的来源。</p>\n<div><pre><code>$ <span>type</span> <span>echo</span>\n<span>echo</span> is a shell <span>builtin</span>\n$ <span>type</span> <span>ls</span>\n<span>ls</span> is hashed <span>(</span>/bin/ls<span>)</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div></div></div><p>上面代码中，<code>type</code> 命令告诉我们，<code>echo</code> 是内部命令，<code>ls</code> 是外部程序 (<code>/bin/ls</code>)。</p>\n<p><code>type</code> 命令本身也是内置命令。</p>\n<div><pre><code>$ <span>type</span> <span>type</span>\n<span>type</span> is a shell <span>builtin</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div></div></div><p>如果要查看一个命令的所有定义，可以使用 <code>type</code> 命令的 <code>-a</code> 参数。</p>\n<div><pre><code>$ <span>type</span> -a <span>echo</span>\n<span>echo</span> is shell <span>builtin</span>\n<span>echo</span> is /usr/bin/echo\n<span>echo</span> is /bin/echo\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div></div></div><p>上面代码表示，<code>echo</code> 命令即是内置命令，也有对应的外部程序。</p>\n<p><code>type</code> 命令的 <code>-t</code> 参数，可以返回一个命令的类型: 别名(alias)，关键词(keyword)，函数(function)，内置命令(builtin)和文件(file)。</p>\n<div><pre><code>$ <span>type</span> -t <span>bash</span>\n<span>file</span>\n$ <span>type</span> -t <span>if</span>\nkeyword\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div></div></div><p>上面例子中，<code>bash</code> 是文件，<code>if</code> 是关键词。</p>\n<h2 id=\"快捷键\" tabindex=\"-1\"> 快捷键</h2>\n<p>Bash 提供很多快捷键，可以大大方便操作。下面是一些最常用的快捷键，完整的介绍参见 <a href=\"/linux/bash/readline.html\">行操作</a> 一章。</p>\n<ul>\n<li><code>Ctrl + L</code>: 清除屏幕并将当前行移到页面顶部。</li>\n<li><code>Ctrl + C</code>: 中止当前正在执行的命令。</li>\n<li><code>Shift + PageUp</code>: 向上滚动。</li>\n<li><code>Shift + PageDown</code>: 向下滚动。</li>\n<li><code>Ctrl + U</code>: 从光标位置删除到行首。</li>\n<li><code>Ctrl + K</code>: 从光标位置删除到行尾。</li>\n<li><code>Ctrl + D</code>: 关闭 Shell 会话。</li>\n<li><code>↑</code>，<code>↓</code>: 浏览已执行命令的历史记录。</li>\n</ul>\n<p>除了上面的快捷键，Bash 还具有自动补全功能。命令输入到一半的时候，可以按下 Tab 键，Bash 会自动完成剩下的部分。比如，输入 <code>pw</code>，然后按一下 Tab 键，Bash 会自动补上 <code>d</code>。</p>\n<p>除了命令的自动补全，Bash 还支持路径的自动补全。有时，需要输入很长的路径，这时只需要输入前面的部分，然后按下 Tab 键，就会自动补全后面的部分。如果有多个可能的选择，按两次 Tab 键，Bash 会显示所有选项，让您选择。</p>\n",
      "date_published": "2022-08-20T08:54:00.000Z",
      "date_modified": "2022-08-20T08:54:00.000Z",
      "authors": [
        {
          "name": "阮一峰"
        }
      ],
      "tags": [
        "Linux"
      ]
    },
    {
      "title": "Bash 简介",
      "url": "https://github.com/MisterChen9527/linux/bash/intro.html",
      "id": "https://github.com/MisterChen9527/linux/bash/intro.html",
      "summary": "Bash 是 Unix 系统和 Linux 系统的一种 Shell(命令行环境)，是目前绝大多数 Linux 发行版的默认 Shell。\n",
      "content_html": "<p>Bash 是 Unix 系统和 Linux 系统的一种 Shell(命令行环境)，是目前绝大多数 Linux 发行版的默认 Shell。</p>\n\n<h2 id=\"shell-的含义\" tabindex=\"-1\"> Shell 的含义</h2>\n<p>学习 Bash，首先需要理解 Shell 是什么。Shell 这个单词的原意是“外壳”，跟 kernel(内核)相对应，比喻内核外面的一层，即用户跟内核交互的对话界面。</p>\n<p>具体来说，Shell 这个词有多种含义。</p>\n<p>首先，Shell 是一个程序，提供一个与用户对话的环境。这个环境只有一个命令提示符，让用户从键盘输入命令，所以又称为命令行环境(commandline，简写为 CLI)。Shell 接收到用户输入的命令，将命令送入操作系统执行，并将结果返回给用户。本书中，除非特别指明，Shell 指的就是命令行环境。</p>\n<p>其次，Shell 是一个命令解释器，解释用户输入的命令。它支持变量、条件判断、循环操作等语法，所以用户可以用 Shell 命令写出各种小程序，又称为脚本(script)。这些脚本都通过 Shell 的解释执行，而不通过编译。</p>\n<p>最后，Shell 是一个工具箱，提供了各种小工具，供用户方便地使用操作系统的功能。</p>\n<h2 id=\"shell-的种类\" tabindex=\"-1\"> Shell 的种类</h2>\n<p>Shell 有很多种，只要能给用户提供命令行环境的程序，都可以看作是 Shell。</p>\n<p>历史上，主要的 Shell 有下面这些。</p>\n<ul>\n<li>Bourne Shell(sh)</li>\n<li>Bourne Again shell(bash)</li>\n<li>C Shell(csh)</li>\n<li>TENEX C Shell(tcsh)</li>\n<li>Korn shell(ksh)</li>\n<li>Z Shell(zsh)</li>\n<li>Friendly Interactive Shell(fish)</li>\n</ul>\n<p>Bash 是目前最常用的 Shell，除非特别指明，下文的 Shell 和 Bash 当作同义词使用，可以互换。</p>\n<p>下面的命令可以查看当前运行的 Shell。</p>\n<div><pre><code>$ <span>echo</span> <span>$SHELL</span>\n/bin/bash\n</code></pre><div aria-hidden=\"true\"><div></div><div></div></div></div><p>下面的命令可以查看当前的 Linux 系统安装的所有 Shell。</p>\n<div><pre><code><span>cat</span> /etc/shells\n</code></pre><div aria-hidden=\"true\"><div></div></div></div><p>上面两个命令中，<code>$</code> 是命令行环境的提示符，用户只需要输入提示符后面的内容。</p>\n<p>Linux 允许每个用户使用不同的 Shell，用户的默认 Shell 一般都是 Bash，或者与 Bash 兼容。</p>\n<h2 id=\"命令行环境\" tabindex=\"-1\"> 命令行环境</h2>\n<h3 id=\"终端模拟器\" tabindex=\"-1\"> 终端模拟器</h3>\n<p>如果是不带有图形环境的 Linux 系统(比如专用于服务器的系统)，启动后就直接是命令行环境。</p>\n<p>不过，现在大部分的 Linux 发行版，尤其是针对普通用户的发行版，都是图形环境。用户登录系统后，自动进入图形环境，需要自己启动终端模拟器，才能进入命令行环境。</p>\n<p>所谓“终端模拟器”(terminal emulator)就是一个模拟命令行窗口的程序，让用户在一个窗口中使用命令行环境，并且提供各种附加功能，比如调整颜色、字体大小、行距等等。</p>\n<p>不同 Linux 发行版(准确地说是不同的桌面环境)带有的终端程序是不一样的，比如 KDE 桌面环境的终端程序是 konsole，Gnome 桌面环境的终端程序是 gnome-terminal，用户也可以安装第三方的终端程序。所有终端程序，尽管名字不同，基本功能都是一样的，就是让用户可以进入命令行环境，使用 Shell。</p>\n<h3 id=\"命令行提示符\" tabindex=\"-1\"> 命令行提示符</h3>\n<p>进入命令行环境以后，用户会看到 Shell 的提示符。提示符往往是一串前缀，最后以一个美元符号 <code>$</code> 结尾，用户可以在这个符号后面输入各种命令。</p>\n<div><pre><code><span>[</span>user@hostname<span>]</span> $\n</code></pre><div aria-hidden=\"true\"><div></div></div></div><p>上面例子中，完整的提示符是 <code>[user@hostname] $</code>，其中前缀是用户名(<code>user</code>)加上 <code>@</code>，再加主机名(<code>hostname</code>)。比如，用户名是 <code>bill</code>，主机名是 <code>home-machine</code>，前缀就是 <code>bill@home-machine</code>。</p>\n<p>注意，根用户(root)的提示符，不以美元符号 (<code>$</code>) 结尾，而以井号 (<code>#</code>) 结尾，用来提醒用户，现在具有根权限，可以执行各种操作，务必小心，不要出现误操作。这个符号是可以自己定义的，详见《命令提示符》一章。</p>\n<p>为了简洁，后文的命令行提示符都只使用 <code>$</code> 表示。</p>\n<h3 id=\"进入和退出方法\" tabindex=\"-1\"> 进入和退出方法</h3>\n<p>进入命令行环境以后，一般就已经打开 Bash 了。如果您的 Shell 不是 Bash，可以输入 <code>bash</code> 命令启动 Bash。</p>\n<div><pre><code><span>bash</span>\n</code></pre><div aria-hidden=\"true\"><div></div></div></div><p>退出 Bash 环境，可以使用 <code>exit</code> 命令，也可以同时按下 <code>Ctrl + d</code>。</p>\n<div><pre><code><span>exit</span>\n</code></pre><div aria-hidden=\"true\"><div></div></div></div><p>Bash 的基本用法就是在命令行输入各种命令，非常直观。作为练习，可以试着输入 <code>pwd</code> 命令。按下回车键，就会显示当前所在的目录。</p>\n<div><pre><code>$ <span>pwd</span>\n/home/me\n</code></pre><div aria-hidden=\"true\"><div></div><div></div></div></div><p>如果不小心输入了 <code>pwe</code>，会返回一个提示，表示输入出错，没有对应的可执行程序。</p>\n<div><pre><code>$ pwe\nbash: pwe: 未找到命令\n</code></pre><div aria-hidden=\"true\"><div></div><div></div></div></div><h2 id=\"shell-和-bash-的历史\" tabindex=\"-1\"> Shell 和 Bash 的历史</h2>\n<p>Shell 伴随着 Unix 系统的诞生而诞生。</p>\n<p>1969 年，Ken Thompson 和 Dennis Ritchie 开发了第一版的 Unix。</p>\n<p>1971 年，Ken Thompson 编写了最初的 Shell，称为 Thompson shell，程序名是 <code>sh</code>，方便用户使用 Unix。</p>\n<p>1973 年至 1975 年间，John R. Mashey 扩展了最初的 Thompson shell，添加了编程功能，使得 Shell 成为一种编程语言。这个版本的 Shell 称为 Mashey shell。</p>\n<p>1976 年，Stephen Bourne 结合 Mashey shell 的功能，重写一个新的 Shell，称为 Bourne shell。</p>\n<p>1978 年，加州大学伯克利分校的 Bill Joy 开发了 C shell，为 Shell 提供 C 语言的语法，程序名是 <code>csh</code>。它是第一个真正替代 <code>sh</code> 的 UNIX shell，被合并到 Berkeley UNIX 的 2BSD 版本中。</p>\n<p>1979 年，UNIX 第七版发布，内置了 Bourne Shell，导致它成为 Unix 的默认 Shell。注意，Thompson shell、Mashey shell 和 Bourne shell 都是贝尔实验室的产品，程序名都是 <code>sh</code>。对于用户来说，它们是同一个东西，只是底层代码不同而已。</p>\n<p>1983 年，David Korn 开发了 Korn shell，程序名是 <code>ksh</code>。</p>\n<p>1985 年，Richard Stallman 成立了自由软件基金会(FSF)，由于 Shell 的版权属于贝尔公司，所以他决定写一个自由版权的、使用 GNU 许可证的 Shell 程序，避免 Unix 的版权争议。</p>\n<p>1988 年，自由软件基金会的第一个付薪程序员 Brian Fox 写了一个 Shell，功能基本上是 Bourne shell 的克隆，叫做 Bourne-Again SHell，简称 Bash，程序名为 <code>bash</code>，任何人都可以免费使用。后来，它逐渐成为 Linux 系统的标准 Shell。</p>\n<p>1989 年，Bash 发布 1.0 版。</p>\n<p>1996 年，Bash 发布 2.0 版。</p>\n<p>2004 年，Bash 发布 3.0 版。</p>\n<p>2009 年，Bash 发布 4.0 版。</p>\n<p>2019 年，Bash 发布 5.0 版。</p>\n<p>用户可以通过 <code>bash</code> 命令的 <code>--version</code> 参数或者环境变量 <code>$BASH_VERSION</code>，查看本机的 Bash 版本。</p>\n<div><pre><code>$ <span>bash</span> --version\nGNU bash，版本 <span>5.0</span>.3<span>(</span><span>1</span><span>)</span>-release <span>(</span>x86_64-pc-linux-gnu<span>)</span>\n\n<span># 或者</span>\n$ <span>echo</span> <span>$BASH_VERSION</span>\n<span>5.0</span>.3<span>(</span><span>1</span><span>)</span>-release\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div></div></div>",
      "date_published": "2022-08-20T08:54:00.000Z",
      "date_modified": "2022-08-20T08:54:00.000Z",
      "authors": [
        {
          "name": "阮一峰"
        }
      ],
      "tags": [
        "Linux"
      ]
    },
    {
      "title": "循环",
      "url": "https://github.com/MisterChen9527/linux/bash/loop.html",
      "id": "https://github.com/MisterChen9527/linux/bash/loop.html",
      "summary": "Bash 提供三种循环语法 for、while 和 until。\n",
      "content_html": "<p>Bash 提供三种循环语法 <code>for</code>、<code>while</code> 和 <code>until</code>。</p>\n\n<h2 id=\"while-循环\" tabindex=\"-1\"> while 循环</h2>\n<p><code>while</code> 循环有一个判断条件，只要符合条件，就不断循环执行指定的语句。</p>\n<div><pre><code><span>while</span> condition<span>;</span> <span>do</span>\n  commands\n<span>done</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div></div></div><p>上面代码中，只要满足条件 <code>condition</code>，就会执行命令 <code>commands</code>。然后，再次判断是否满足条件 <code>condition</code>，只要满足，就会一直执行下去。只有不满足条件，才会退出循环。</p>\n<p>循环条件 <code>condition</code> 可以使用 <code>test</code> 命令，跟 <code>if</code> 结构的判断条件写法一致。</p>\n<div><pre><code><span>#!/bin/bash</span>\n\n<span>number</span><span>=</span><span>0</span>\n<span>while</span> <span>[</span> <span>\"<span>$number</span>\"</span> -lt <span>10</span> <span>]</span><span>;</span> <span>do</span>\n  <span>echo</span> <span>\"Number = <span>$number</span>\"</span>\n  <span>number</span><span>=</span><span><span>$((</span>number <span>+</span> <span>1</span><span>))</span></span>\n<span>done</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面例子中，只要变量 <code>$number</code> 小于 10，就会不断加 1，直到 <code>$number</code> 等于 10，然后退出循环。</p>\n<p>关键字 <code>do</code> 可以跟 <code>while</code> 不在同一行，这时两者之间不需要使用分号分隔。</p>\n<div><pre><code><span>while</span> <span>true</span>\n<span>do</span>\n  <span>echo</span> <span>'Hi, while looping ...'</span><span>;</span>\n<span>done</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div></div></div><p>上面的例子会无限循环，可以按下 <code>Ctrl + c</code> 停止。</p>\n<p><code>while</code> 循环写成一行，也是可以的。</p>\n<div><pre><code><span>while</span> <span>true</span><span>;</span> <span>do</span> <span>echo</span> <span>'Hi, while looping ...'</span><span>;</span> <span>done</span>\n</code></pre><div aria-hidden=\"true\"><div></div></div></div><p><code>while</code> 的条件部分也可以是执行一个命令。</p>\n<div><pre><code><span>while</span> <span>echo</span> <span>'ECHO'</span><span>;</span> <span>do</span> <span>echo</span> <span>'Hi, while looping ...'</span><span>;</span> <span>done</span>\n</code></pre><div aria-hidden=\"true\"><div></div></div></div><p>上面例子中，判断条件是 <code>echo 'ECHO'</code>。由于这个命令总是执行成功，所以上面命令会产生无限循环。</p>\n<p><code>while</code> 的条件部分可以执行任意数量的命令，但是执行结果的真伪只看最后一个命令的执行结果。</p>\n<div><pre><code><span>while</span> <span>true</span><span>;</span> <span>false</span><span>;</span> <span>do</span> <span>echo</span> <span>'Hi, looping ...'</span><span>;</span> <span>done</span>\n</code></pre><div aria-hidden=\"true\"><div></div></div></div><p>上面代码运行后，不会有任何输出，因为 <code>while</code> 的最后一个命令是 <code>false</code>。</p>\n<h2 id=\"until-循环\" tabindex=\"-1\"> until 循环</h2>\n<p><code>until</code> 循环与 <code>while</code> 循环恰好相反，只要不符合判断条件(判断条件失败)，就不断循环执行指定的语句。一旦符合判断条件，就退出循环。</p>\n<div><pre><code><span>until</span> condition<span>;</span> <span>do</span>\n  commands\n<span>done</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div></div></div><p>关键字 <code>do</code> 可以与 <code>until</code> 不写在同一行，这时两者之间不需要分号分隔。</p>\n<div><pre><code><span>until</span> condition\n<span>do</span>\n  commands\n<span>done</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div></div></div><p>下面是一个例子。</p>\n<div><pre><code>$ <span>until</span> <span>false</span><span>;</span> <span>do</span> <span>echo</span> <span>'Hi, until looping ...'</span><span>;</span> <span>done</span>\nHi, <span>until</span> looping <span>..</span>.\nHi, <span>until</span> looping <span>..</span>.\nHi, <span>until</span> looping <span>..</span>.\n^C\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div></div></div><p>上面代码中，<code>until</code> 的部分一直为 <code>false</code>，导致命令无限运行，必须按下 <code>Ctrl + c</code> 终止。</p>\n<div><pre><code><span>#!/bin/bash</span>\n\n<span>number</span><span>=</span><span>0</span>\n<span>until</span> <span>[</span> <span>\"<span>$number</span>\"</span> -ge <span>10</span> <span>]</span><span>;</span> <span>do</span>\n  <span>echo</span> <span>\"Number = <span>$number</span>\"</span>\n  <span>number</span><span>=</span><span><span>$((</span>number <span>+</span> <span>1</span><span>))</span></span>\n<span>done</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面例子中，只要变量 <code>number</code> 小于 10，就会不断加 1，直到 <code>number</code> 大于等于 10，就退出循环。</p>\n<p><code>until</code> 的条件部分也可以是一个命令，表示在这个命令执行成功之前，不断重复尝试。</p>\n<div><pre><code><span>until</span> <span>cp</span> <span>$1</span> <span>$2</span><span>;</span> <span>do</span>\n  <span>echo</span> <span>'Attempt to copy failed. waiting...'</span>\n  <span>sleep</span> <span>5</span>\n<span>done</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div></div></div><p>上面例子表示，只要 <code>cp $1 $2</code> 这个命令执行不成功，就 5 秒钟后再尝试一次，直到成功为止。</p>\n<p><code>until</code> 循环都可以转为 <code>while</code> 循环，只要把条件设为否定即可。上面这个例子可以改写如下。</p>\n<div><pre><code><span>while</span> <span>!</span> <span>cp</span> <span>$1</span> <span>$2</span><span>;</span> <span>do</span>\n  <span>echo</span> <span>'Attempt to copy failed. waiting...'</span>\n  <span>sleep</span> <span>5</span>\n<span>done</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div></div></div><p>一般来说，<code>until</code> 用得比较少，完全可以统一都使用 <code>while</code>。</p>\n<h2 id=\"for-in-循环\" tabindex=\"-1\"> <code>for...in</code> 循环</h2>\n<p><code>for...in</code> 循环用于遍历列表的每一项。</p>\n<div><pre><code><span>for</span> <span>variable</span> <span>in</span> list\n<span>do</span>\n  commands\n<span>done</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div></div></div><p>上面语法中，<code>for</code> 循环会依次从 <code>list</code> 列表中取出一项，作为变量 <code>variable</code>，然后在循环体中进行处理。</p>\n<p>关键词 <code>do</code> 可以跟 <code>for</code> 写在同一行，两者使用分号分隔。</p>\n<div><pre><code><span>for</span> <span>variable</span> <span>in</span> list<span>;</span> <span>do</span>\n  commands\n<span>done</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div></div></div><p>下面是一个例子。</p>\n<div><pre><code><span>#!/bin/bash</span>\n\n<span>for</span> <span>i</span> <span>in</span> word1 word2 word3<span>;</span> <span>do</span>\n  <span>echo</span> <span>$i</span>\n<span>done</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div></div></div><p>上面例子中，<code>word1 word2 word3</code> 是一个包含三个单词的列表，变量 <code>i</code> 依次等于 <code>word1</code>、<code>word2</code>、<code>word3</code>，命令 <code>echo $i</code> 则会相应地执行三次。</p>\n<p>列表可以由通配符产生。</p>\n<div><pre><code><span>for</span> <span>i</span> <span>in</span> *.png<span>;</span> <span>do</span>\n  <span>ls</span> -l <span>$i</span>\n<span>done</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div></div></div><p>上面例子中，<code>*.png</code> 会替换成当前目录中所有 PNG 图片文件，变量 <code>i</code> 会依次等于每一个文件。</p>\n<p>列表也可以通过子命令产生。</p>\n<div><pre><code><span>#!/bin/bash</span>\n\n<span>count</span><span>=</span><span>0</span>\n<span>for</span> <span>i</span> <span>in</span> <span><span>$(</span><span>cat</span> ~/.bash_profile<span>)</span></span><span>;</span> <span>do</span>\n  <span>count</span><span>=</span><span><span>$((</span>count <span>+</span> <span>1</span><span>))</span></span>\n  <span>echo</span> <span>\"Word <span>$count</span> (<span>$i</span>) contains <span><span>$(</span><span>echo</span> -n $i <span>|</span> <span>wc</span> -c<span>)</span></span> characters\"</span>\n<span>done</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面例子中，<code>cat ~/.bash_profile</code> 命令会输出 <code>~/.bash_profile</code> 文件的内容，然后通过遍历每一个词，计算该文件一共包含多少个词，以及每个词有多少个字符。</p>\n<p><code>in list</code> 的部分可以省略，这时 <code>list</code> 默认等于脚本的所有参数 <code>$@</code>。但是，为了可读性，最好还是不要省略，参考下面的例子。</p>\n<div><pre><code><span>for</span> filename<span>;</span> <span>do</span>\n  <span>echo</span> <span>\"<span>$filename</span>\"</span>\n<span>done</span>\n\n<span># 等同于</span>\n\n<span>for</span> <span>filename</span> <span>in</span> <span>\"<span>$@</span>\"</span> <span>;</span> <span>do</span>\n  <span>echo</span> <span>\"<span>$filename</span>\"</span>\n<span>done</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>在函数体中也是一样的，<code>for...in</code> 循环省略 <code>in list</code> 的部分，则 <code>list</code> 默认等于函数的所有参数。</p>\n<h2 id=\"for-循环\" tabindex=\"-1\"> for 循环</h2>\n<p><code>for</code> 循环还支持 C 语言的循环语法。</p>\n<div><pre><code><span>for</span> <span><span>((</span> expression1<span>;</span> expression2<span>;</span> expression3 <span>))</span></span><span>;</span> <span>do</span>\n  commands\n<span>done</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div></div></div><p>上面代码中，<code>expression1</code> 用来初始化循环条件，<code>expression2</code> 用来决定循环结束的条件，<code>expression3</code> 在每次循环迭代的末尾执行，用于更新值。</p>\n<p>注意，循环条件放在双重圆括号之中。另外，圆括号之中使用变量，不必加上美元符号 <code>$</code>。</p>\n<p>它等同于下面的 <code>while</code> 循环。</p>\n<div><pre><code><span><span>((</span> expression1 <span>))</span></span>\n<span>while</span> <span><span>((</span> expression2 <span>))</span></span><span>;</span> <span>do</span>\n  commands\n  <span><span>((</span> expression3 <span>))</span></span>\n<span>done</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div></div></div><p>下面是一个例子。</p>\n<div><pre><code><span>for</span> <span><span>((</span> i<span>=</span><span>0</span><span>;</span> i<span>&lt;</span><span>5</span><span>;</span> i<span>=</span>i<span>+</span><span>1</span> <span>))</span></span><span>;</span> <span>do</span>\n  <span>echo</span> <span>$i</span>\n<span>done</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div></div></div><p>上面代码中，初始化变量 <code>i</code> 的值为 0，循环执行的条件是 <code>i</code> 小于 5。每次循环迭代结束时，<code>i</code> 的值加 1。</p>\n<p><code>for</code> 条件部分的三个语句，都可以省略。</p>\n<div><pre><code><span>for</span> <span><span>((</span><span>;</span><span>;</span><span>))</span></span>\n<span>do</span>\n  <span>read</span> var\n  <span>if</span> <span>[</span> <span>\"<span>$var</span>\"</span> <span>=</span> <span>\".\"</span> <span>]</span><span>;</span> <span>then</span>\n    <span>break</span>\n  <span>fi</span>\n<span>done</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面脚本会反复读取命令行输入，直到用户输入了一个点(<code>.</code>)位为止，才会跳出循环。</p>\n<h2 id=\"break-continue\" tabindex=\"-1\"> break，continue</h2>\n<p>Bash 提供了两个内部命令 <code>break</code> 和 <code>continue</code>，用来在循环内部跳出循环。</p>\n<p><code>break</code> 命令立即终止循环，程序继续执行循环块之后的语句，即不再执行剩下的循环。</p>\n<div><pre><code><span>#!/bin/bash</span>\n\n<span>for</span> <span>number</span> <span>in</span> <span>1</span> <span>2</span> <span>3</span> <span>4</span> <span>5</span> <span>6</span>\n<span>do</span>\n  <span>echo</span> <span>\"number is <span>$number</span>\"</span>\n  <span>if</span> <span>[</span> <span>\"<span>$number</span>\"</span> <span>=</span> <span>\"3\"</span> <span>]</span><span>;</span> <span>then</span>\n    <span>break</span>\n  <span>fi</span>\n<span>done</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面例子只会打印 3 行结果。一旦变量 <code>$number</code> 等于 3，就会跳出循环，不再继续执行。</p>\n<p><code>continue</code> 命令立即终止本轮循环，开始执行下一轮循环。</p>\n<div><pre><code><span>#!/bin/bash</span>\n\n<span>while</span> <span>read</span> -p <span>\"What file do you want to test?\"</span> filename\n<span>do</span>\n  <span>if</span> <span>[</span> <span>!</span> -e <span>\"<span>$filename</span>\"</span> <span>]</span><span>;</span> <span>then</span>\n    <span>echo</span> <span>\"The file does not exist.\"</span>\n    <span>continue</span>\n  <span>fi</span>\n\n  <span>echo</span> <span>\"You entered a valid file..\"</span>\n<span>done</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面例子中，只要用户输入的文件不存在，<code>continue</code> 命令就会生效，直接进入下一轮循环(让用户重新输入文件名)，不再执行后面的打印语句。</p>\n<h2 id=\"select-结构\" tabindex=\"-1\"> select 结构</h2>\n<p><code>select</code> 结构主要用来生成简单的菜单。它的语法与 <code>for...in</code> 循环基本一致。</p>\n<div><pre><code><span>select</span> name\n<span>[</span>in list<span>]</span>\n<span>do</span>\n  commands\n<span>done</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div></div></div><p>Bash 会对 <code>select</code> 依次进行下面的处理。</p>\n<ol>\n<li><code>select</code> 生成一个菜单，内容是列表 <code>list</code> 的每一项，并且每一项前面还有一个数字编号。</li>\n<li>Bash 提示用户选择一项，输入它的编号。</li>\n<li>用户输入以后，Bash 会将该项的内容存在变量 <code>name</code>，该项的编号存入环境变量 <code>REPLY</code>。如果用户没有输入，就按回车键，Bash 会重新输出菜单，让用户选择。</li>\n<li>执行命令体 <code>commands</code>。</li>\n<li>执行结束后，回到第一步，重复这个过程。</li>\n</ol>\n<p>下面是一个例子。</p>\n<div><pre><code><span>#!/bin/bash</span>\n<span># select.sh</span>\n\n<span>select</span> <span>brand</span> <span>in</span> Samsung Sony iphone symphony Walton\n<span>do</span>\n  <span>echo</span> <span>\"You have chosen <span>$brand</span>\"</span>\n<span>done</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>执行上面的脚本，Bash 会输出一个品牌的列表，让用户选择。</p>\n<div><pre><code>$ ./select.sh\n<span>1</span><span>)</span> Samsung\n<span>2</span><span>)</span> Sony\n<span>3</span><span>)</span> iphone\n<span>4</span><span>)</span> symphony\n<span>5</span><span>)</span> Walton\n<span>#?</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>如果用户没有输入编号，直接按回车键。Bash 就会重新输出一遍这个菜单，直到用户按下 <code>Ctrl + c</code>，退出执行。</p>\n<p><code>select</code> 可以与 <code>case</code> 结合，针对不同项，执行不同的命令。</p>\n<div><pre><code><span>#!/bin/bash</span>\n\n<span>echo</span> <span>\"Which Operating System do you like?\"</span>\n\n<span>select</span> <span>os</span> <span>in</span> Ubuntu LinuxMint Windows8 Windows7 WindowsXP\n<span>do</span>\n  <span>case</span> <span>$os</span> <span>in</span>\n    <span>\"Ubuntu\"</span><span>|</span><span>\"LinuxMint\"</span><span>)</span>\n      <span>echo</span> <span>\"I also use <span>$os</span>.\"</span>\n    <span>;</span><span>;</span>\n    <span>\"Windows8\"</span> <span>|</span> <span>\"Windows10\"</span> <span>|</span> <span>\"WindowsXP\"</span><span>)</span>\n      <span>echo</span> <span>\"Why don't you try Linux?\"</span>\n    <span>;</span><span>;</span>\n    *<span>)</span>\n      <span>echo</span> <span>\"Invalid entry.\"</span>\n      <span>break</span>\n    <span>;</span><span>;</span>\n  <span>esac</span>\n<span>done</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面例子中，<code>case</code> 针对用户选择的不同项，执行不同的命令。</p>\n<h2 id=\"参考链接\" tabindex=\"-1\"> 参考链接</h2>\n<ul>\n<li><a href=\"https://linuxhint.com/bash_select_command/\" target=\"_blank\" rel=\"noopener noreferrer\">Bash Select Command</a>, Fahmida Yesmin</li>\n</ul>\n",
      "date_published": "2022-08-20T08:54:00.000Z",
      "date_modified": "2022-08-20T08:54:00.000Z",
      "authors": [
        {
          "name": "阮一峰"
        }
      ],
      "tags": [
        "Linux"
      ]
    }
  ]
}